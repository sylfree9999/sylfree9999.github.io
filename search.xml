<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>math-basics</title>
      <link href="/2018/09/12/math-basics/"/>
      <url>/2018/09/12/math-basics/</url>
      <content type="html"><![CDATA[<p>与其恐惧，不如直面它吧！</p><h2 id="对数函数"><a href="#对数函数" class="headerlink" title="对数函数"></a>对数函数</h2><p>基本公式为：<br>$\log_a{MN} = \log_aM + \log_aN$<br>$\log_a{\frac{M}{N}} = \log_aM - \log_aN$<br>$\log_a{M^n} = n\log_aM$<br>$\log_{a^n}M = \frac{1}{n}\log_aM$<br>换底公式$\log_ba = \frac{\log_ca}{\log_cb}$<br>倒数公式$\frac{1}{\log_ab} = \log_ba$</p><h2 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h2><p>[Ref:<a href="https://zhuanlan.zhihu.com/p/20102140]" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/20102140]</a><br>[Ref:<a href="https://www.youtube.com/watch?v=diMjCkwL9Xo&amp;list=PLF38FCD363F7184B0&amp;index=7]" target="_blank" rel="noopener">https://www.youtube.com/watch?v=diMjCkwL9Xo&amp;list=PLF38FCD363F7184B0&amp;index=7]</a></p><h3 id="基础定义"><a href="#基础定义" class="headerlink" title="基础定义"></a>基础定义</h3><p>设角$\alpha$的的终边与单位圆交于点P(x,y),则有<br>$\sin\alpha =y, \cos\alpha = x$<br>$\tan\alpha = \frac{y}{x}, \cot\alpha = \frac{x}{y}$<br>$\sec\alpha = \frac{1}{x},\csc\alpha = \frac{1}{y}$<br><strong>sec pronounces secant</strong><br><strong>csc pronounces cosecant</strong></p><a id="more"></a><h3 id="同角三角函数基本关系"><a href="#同角三角函数基本关系" class="headerlink" title="同角三角函数基本关系"></a>同角三角函数基本关系</h3><p>可以由上面的式子直接推导：<br>$\tan\alpha\cot\alpha=1$<br>$\sin\alpha\csc\alpha=1$<br>$\cos\alpha\sec\alpha=1$<br>还可以得出：<br>$\frac{\sin\alpha}{\cos\alpha}=\tan\alpha=\frac{\sec\alpha}{\csc\alpha}$ $\frac{\cos\alpha}{\sin\alpha} = \frac{\csc\alpha}{\sec\alpha}$<br>同时结合勾股定理，还可以得到<br>$\sin^2\alpha + \cos^2\alpha =1$</p><p>可以结合下面的图进行定义<br><img src="/2018/09/12/math-basics/tri_6p.png"><br><img src="/2018/09/12/math-basics/tri_6p_2.png"></p><p>基本公式的记忆方法<br>根据一个单位圆就可以得出：<br>$1^2+\tan^2\alpha=\sec^2\alpha$<br>$1^2+\cot^2\alpha=\csc^2\alpha$</p><img src="/2018/09/12/math-basics/unit_circle_1.png"><img src="/2018/09/12/math-basics/unit_circle_2.png"><p>广义角的定义与传统第一象限的三角函数定义相同，只不过带上了各个象限的讯息，就是到底是在x轴上下，还是y轴左右，还是x,y是同号还是异号。广义角的定义可以推出后面的傅里叶变换</p><h3 id="角度制，弧度制"><a href="#角度制，弧度制" class="headerlink" title="角度制，弧度制"></a>角度制，弧度制</h3><p>弧度制也是描述角度的一种单位<br>弧度制的含义就是一个单位圆，我把半径为1的长度放到周长上面，这个时候对应的角叫做一个Rad。<br>那么如果我这个弧度角转一周，产生出来的角度是多少？也就是说可以用多少长度为1的线段来描述这个圆周，其实就是<br>$$2\pi\text{r} = 360°$$<br>也就是$2\pi = 360°$<br>这样的话，对于弧长s/圆周长，就=这个时候的弧度角/一周的角，也就是：<br>$$\frac{s}{2\pi\text{r}} = \frac{\theta}{2\pi}$$<br>$$s=r\theta$$</p><img src="/2018/09/12/math-basics/radius_1.png"><p>那么同理，对于面积：<br>$$\frac{A}{\pi\text{r}^2} = \frac{\theta}{2\pi}$$<br>也就是$A=\frac{\theta\text{r}^2}{2}$,又因为$s=\theta\text{r}$,所以：<br>$$A = \frac{1}{2}sr$$<br>有一点点像是一个三角形的面积，以s为底，r为高</p><h3 id="偶函数与奇函数"><a href="#偶函数与奇函数" class="headerlink" title="偶函数与奇函数"></a>偶函数与奇函数</h3><p>偶函数 f(x) = f(-x)，对y轴在做对称，cos(x)是偶函数, tan(x)也是偶函数 tan(x) = tan(-x)<br>奇函数 f(x) = -f(-x),对原点在做对称，sin(x)是奇函数，cot(x)也是奇函数 </p><h3 id="三角函数的诱导公式"><a href="#三角函数的诱导公式" class="headerlink" title="三角函数的诱导公式"></a>三角函数的诱导公式</h3>]]></content>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Concept </tag>
            
            <tag> MachineLearning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linear-algebra-graphics</title>
      <link href="/2018/09/03/linear-algebra-graphics/"/>
      <url>/2018/09/03/linear-algebra-graphics/</url>
      <content type="html"><![CDATA[<p>没想到我有生之年，还要再次学习一下线性代数。</p><p>凹！被数学支配的恐惧还涌在心头，依稀记得在大学的时候学的时候感觉都懂，过一个暑假全忘了（这种特殊技能同样包括各种电视剧，比方说什么射雕英雄传，鹿鼎记，还珠格格这种，看的时候那是比谁都清楚，看完就忘）</p><p>我也是佩服我自己的。<br>好了，废话不多说了，现在毕竟科技发达了，不如以往，只能靠老师教的方法学。现在各种网上的资源很是丰富啊。</p><p>在众多资源中，一个3Blue1Brown的大神还有meetmath做的系列脱颖而出，我决定引用他们的例子，用这种图形化的学习方式重温一下线性代数。</p><p>MeetMath:[Ref: <a href="https://mp.weixin.qq.com/s?__biz=MzAxNzg3MTE3Ng==&amp;mid=2247485798&amp;idx=1&amp;sn=15a52a1e1fc3a2ba51353b66faa735db&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxNzg3MTE3Ng==&amp;mid=2247485798&amp;idx=1&amp;sn=15a52a1e1fc3a2ba51353b66faa735db&amp;scene=21#wechat_redirect</a>]</p><p>3Blue1Brown: [Ref:<a href="https://www.bilibili.com/video/av6240005/?spm_id_from=333.788.videocard.2" target="_blank" rel="noopener">https://www.bilibili.com/video/av6240005/?spm_id_from=333.788.videocard.2</a>]</p><h2 id="向量的加法"><a href="#向量的加法" class="headerlink" title="向量的加法"></a>向量的加法</h2><p>向量的加法这种，是唯一一个情况需要把一个向量移开原点的情况。<br>为什么要移开呢？因为可以理解为从 $\vec{v}$ ,<span style="color: red;">走到</span> $\vec{w}$ 就相当于$\vec{v}$+$\vec{w}$</p><img src="/2018/09/03/linear-algebra-graphics/vector_Add.png"><h2 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h2><p>概念：必须具有两个性质，首先直线必须在变换后还是直线，且原点不能变<br><img src="/2018/09/03/linear-algebra-graphics/linear_function.png"></p><p>如何用数值来描述线性变换？<br>变换后的向量都可以用基本的$\hat{i}$和$\hat{j}$来表示,只要告诉你变换后$\hat{i}$和$\hat{j}$的坐标，你就可以计算出$\begin{bmatrix}x\\\y\end{bmatrix}$</p><p>你就可以计算出$\begin{bmatrix}x\\\y\end{bmatrix}$ -&gt; x$\begin{bmatrix} 1 \\\ -2\end{bmatrix}$ + y$\begin{bmatrix}3 \\\ 0\end{bmatrix}$ = $\begin{bmatrix}1x+3y \\\ -2x+0y \end{bmatrix}$</p><img src="/2018/09/03/linear-algebra-graphics/ihat.png"><p><code>shear</code>的意思是保持x轴不变，然后转y轴</p><a id="more"></a><h2 id="矩阵相乘"><a href="#矩阵相乘" class="headerlink" title="矩阵相乘"></a>矩阵相乘</h2><p>对于矩阵$\begin{bmatrix}a &amp; b\\\ c&amp;d \end{bmatrix}$$\begin{bmatrix} e&amp;f\\\ g&amp;h \end{bmatrix}$,其实就是相当于先做了$\begin{bmatrix} e&amp;f\\\ g&amp;h \end{bmatrix}$矩阵变换，然后做了$\begin{bmatrix}a &amp; b\\\ c&amp;d \end{bmatrix}$矩阵变换，所以得出的结果就是：<br><img src="/2018/09/03/linear-algebra-graphics/matrix_multiplication.png"></p><p>所以如果根据矩阵相乘图形变化来思考M$_1$M$_2$ 是否= M$_2$M$_1$就很容易理解，因为两次矩阵变换的结果是不同的</p><h2 id="行列式-Determinant"><a href="#行列式-Determinant" class="headerlink" title="行列式 Determinant"></a>行列式 Determinant</h2><p>How much the transformation strech/squish the areas?<br>How much are areas scaled?</p><p>Determinant is just how much your area scaled? from ASpace to X times ASpace, then A is the determinant of the matrix<br><img src="/2018/09/03/linear-algebra-graphics/determint_definition.png"></p><p>行列式也可以是负数，负数的意思就是按照矩阵描述的变换方法变换，但结果这个平面翻转了，比方说原来$\hat{j}$在$\hat{i}$的左边，但是变换后$\hat{j}$在$\hat{i}$右边，这就造成了翻转</p><p>如果是3D的情况，则是volume被变了<br>行列式的计算公式：</p><p>det$(\begin{bmatrix}a &amp; b\\\ c&amp;d \end{bmatrix})$ = ad-bc<br><img src="/2018/09/03/linear-algebra-graphics/determint_definition.png"></p><h2 id="逆矩阵-Inverse-Matrices-列空间Column-Space，秩Rank与零空间-Null-Space"><a href="#逆矩阵-Inverse-Matrices-列空间Column-Space，秩Rank与零空间-Null-Space" class="headerlink" title="逆矩阵 Inverse Matrices 列空间Column Space，秩Rank与零空间 Null Space"></a>逆矩阵 Inverse Matrices 列空间Column Space，秩Rank与零空间 Null Space</h2><p>对于$A\vec{x}=\vec{v}$,图形含义是对于向量$\vec{x}$，经过矩阵A的变换，与向量$\vec{v}$重合,也就是说A的行列式会变成0（也就是压缩成了一条线或者一个平面），还是strech/squish成之前一样的2/3维，也就是行列式不等于0</p><img src="/2018/09/03/linear-algebra-graphics/inverse_matrix.png"><p>如果行列式不等于0：<br>逆矩阵的意思是逆过来再做一次A矩阵，所以先做一次A矩阵，再做一次A逆矩阵，就相当于什么也没有做<br>$A^{-1}A = \begin{bmatrix} 1&amp;0 \\\ 0&amp;1 \end{bmatrix}$<br>这个时候：<br>$A\vec{x} = \vec{v}$就可以写成<br>$A^{-1}A\vec{x} = A^{-1}\vec{v}$,也就是$\vec{x} = A^{-1}\vec{v}$<br>这个含义就是<code>You are playing the transformation in reverse and following v</code></p><p><strong><span style="color:red">如果行列式等于0,则没有逆矩阵的情况，因为不可能有一个逆操作，从一条线变成一个平面</span></strong></p><h2 id="方程组的解"><a href="#方程组的解" class="headerlink" title="方程组的解"></a>方程组的解</h2><script type="math/tex; mode=display">\begin{cases}a_1x+b_1y+c_1z=d_1 \\\ a_2x+b_2y+c_2z=d_2 \\\ a_3x+b_3y+c_3z=d_3\end{cases}</script><p>上面用方程写成的矩阵向量相乘，也可以表示成<br>$\begin{pmatrix} a_1&amp;b_1&amp;c_1 \\\ a_2&amp;b_2&amp;c_2 \\\ a_3&amp;b_3&amp;c_3 \end{pmatrix}$$\begin{pmatrix} x \\\ y \\\ z \end{pmatrix} = \begin{pmatrix} d_1 \\\ d_2 \\\ d_3 \end{pmatrix}$</p><p>常系数矩阵A，未知量向量$\vec{x}$，两者的乘积得到列向量$\vec{v}$<br>所以求解Ax = v就意味着我们要找到一个向量x，使得它再变换后与v完全重合<br>如果有逆矩阵$\vec{x} = A^{-1}\vec{v}$来理解，也就是向量v经过矩阵A的逆变换到达了x</p><p>或者，对于方程组：</p><script type="math/tex; mode=display">\begin{cases}x+y=2 \\\ 2x+2y=1 \\\ \end{cases}</script><p>从列视图可以看作向量$\begin{pmatrix} 2 \\\ 1 \end{pmatrix}$没有落在矩阵$A=\begin{pmatrix} 1&amp;1 \\\ 2&amp;2 \end{pmatrix}$所指向的空间内(其实就是基向量$\begin{pmatrix} 1&amp;0 \\\ 0&amp;1 \end{pmatrix}$做矩阵A的变化)，从下图的动画中可以看到经过矩阵变换后，空间最终被压缩成了一条直线，而变化全程向量$\vec{v}$都处在直线外，所以这个方程组无解</p><p><strong><span style="color: red">这个方程组有解就代表矩阵A所代表的变换没有将空间进行扁平化的压缩。即$det(A) \neq 0$</span></strong></p><p>width=100% height=600px frameborder=”0” scrolling=”no” src=”<a href="http://mmbiz.qpic.cn/mmbiz_gif/WBqG5VGfdMEA8wxqLQrofiaN5OAAEiaMduI9WiaiaibPHWf4O5kHdGodlgp1WBEDvJLY1Iuze2yCyO13DCM8PghGfmw/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" target="_blank" rel="noopener">http://mmbiz.qpic.cn/mmbiz_gif/WBqG5VGfdMEA8wxqLQrofiaN5OAAEiaMduI9WiaiaibPHWf4O5kHdGodlgp1WBEDvJLY1Iuze2yCyO13DCM8PghGfmw/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1</a>“</p><h3 id="Rank矩阵的秩"><a href="#Rank矩阵的秩" class="headerlink" title="Rank矩阵的秩"></a>Rank矩阵的秩</h3><p>When the output of transformation is a line, meaning it’s one-dimensional, then we say the transformation has a rank of 1</p><p>If all the vectors land on some two-dimensional plane, we say the transformation has a rank of 2.</p><p>也就是说矩阵的秩代表着变换后，其空间的维数</p><h3 id="Column-Space"><a href="#Column-Space" class="headerlink" title="Column Space"></a>Column Space</h3><p>This set of all possible outputs for your matrix, whether it’s a line, a plane, 3-D space whatever, is called the “column space” of your matrix</p><h3 id="Full-Rank满秩"><a href="#Full-Rank满秩" class="headerlink" title="Full Rank满秩"></a>Full Rank满秩</h3><p>When this rank is as high as it can be, meaning it equals the numner of columns, we call the matrix “full rank”</p><h3 id="Null-Space-Kernal零空间，核"><a href="#Null-Space-Kernal零空间，核" class="headerlink" title="Null Space/Kernal零空间，核"></a>Null Space/Kernal零空间，核</h3><p>This set of vectors that lands on the origin is called the “null space” or the “kernal” of your matrix,一般表示成dim Ker(X),也就是零空间的维度</p><h3 id="维数定理"><a href="#维数定理" class="headerlink" title="维数定理"></a>维数定理</h3><p>如果A是m*n 矩阵，维数定理就是：<br>$dim Ker(A) + rank(A) = n$</p><h2 id="点积Dot-Product与对偶性duality"><a href="#点积Dot-Product与对偶性duality" class="headerlink" title="点积Dot Product与对偶性duality"></a>点积Dot Product与对偶性duality</h2><h3 id="点积Dot-Product"><a href="#点积Dot-Product" class="headerlink" title="点积Dot Product"></a>点积Dot Product</h3><p>[Ref:<a href="https://betterexplained.com/articles/vector-calculus-understanding-the-dot-product/" target="_blank" rel="noopener">https://betterexplained.com/articles/vector-calculus-understanding-the-dot-product/</a>]</p><p>Think of the dot product as <strong><span style="color:red">directional multiplication</span></strong>.<br>If a vector is “growth in a direction”, there’s a few operations we can do:</p><ul><li>Add vectors, Accumulate the growth contained in several vectors</li><li>Multiply by a constant: Make an existing vector stronger</li><li>Dot product: Applyt the directional growth of one vector to another. The result is how much stronger we’ve made the original.</li></ul><p>所以当有两个不同方向的向量相乘，这代表什么意思呢？<br>可以理解为两个向量不同组成部分的相乘<br>由于$\vec{a}$可以由$a_x$和$a_y$来表示，$\vec{b}$也可以由$b_x$和$b_y$来表示，那么$\vec{a} \cdot \vec{b}$ = $a_x \cdot b_x$ + $a_y \cdot b_x$(=0) + $a_x \cdot b_y$(=0) + $a_y \cdot b_y$来表示</p><p>由于两个垂直的向量相乘=0，所以$\vec{a} \cdot \vec{b}$也就可以表示成：</p><script type="math/tex; mode=display">a_x \cdot b_x + a_y \cdot b_y</script><img src="/2018/09/03/linear-algebra-graphics/dot_product_components.png"><p>或者通过<strong>Rotate</strong>来理解点积<br>由于想要知道两个向量的growth,可以把其中一个向量投影到另一个向量（即与另一个向量相同部分），这样两个向量就是相同的方向，其点积也就是相同方向向量的点积。</p><p>所以$\vec{a}$在$\vec{b}$上面相同的部分就是$\vec{a}$在$\vec{b}$上面的投影，也就是$|a|\cos(\theta) \cdot |b|$</p><img src="/2018/09/03/linear-algebra-graphics/dot_product_rotation.png"><p>点积的图形意义就是向量$\vec{w}$在向量$\vec{v}$上的投影长度 * 向量$\vec{v}$的长度，如果是反方向，则点积为负，如果是相同方向，点积为正，如果两个向量成直角，则点积为0.<br><img src="/2018/09/03/linear-algebra-graphics/dot_product_1.png"></p><p>并且$(2\vec{v} \cdot \vec{w}) = 2(\vec{v} \cdot \vec{w})$</p><p>但是为什么点积的计算方式（就是对应变量相乘然后相加）会与Projection（投影）有关呢？<br><img src="/2018/09/03/linear-algebra-graphics/dot_product_2.png"></p><p>点积的几何意义：<br>What it means to apply one of these transofrmations to a vector.<br>例如对于向量$\begin{bmatrix} 4 \\\ 3 \end{bmatrix}$,有一个线性变换，将$\hat{i}$和$\hat{j}$变换至1和-2，也就是说这个transform matrix就是$\begin{bmatrix} 1&amp;-2 \end{bmatrix} $,要跟踪向量$\begin{bmatrix} 4 \\\ 3 \end{bmatrix}$变换后的去向，就将这个向量分解成为4*$\hat{i}$ + 3*$\hat{j}$，由于线性性质，所以在变换后，这个向量的位置就是4*变换后的$\hat{i}$，也就是1,加上变换后的$\hat{j}$，也就是3(-2)，所以最终它变换成-2</p><img src="/2018/09/03/linear-algebra-graphics/dot_product_3.png"><h3 id="Duality对偶性-我觉得我看了不下5遍…"><a href="#Duality对偶性-我觉得我看了不下5遍…" class="headerlink" title="Duality对偶性(我觉得我看了不下5遍…)"></a>Duality对偶性(我觉得我看了不下5遍…)</h3><p>那么为什么点积坐标的相加与投影有关系呢？</p><p>在坐标中可以定义一个u轴穿越原点。我们的目标就是将坐标中的任意一个向量，变成u轴上面的一个数字。换句话说，我们要能找到一个1*2的矩阵，能够描述这个变化。或者说，任意变量经过线性变换后，跑到了U轴上变成一个点，这个时候$\hat{i}$与$\hat{j}$也在U轴上面。那么$\hat{i}$和$\hat{j}$的值又是什么呢？</p><p>这个时候，我们可以加一条对称线来辅助计算。变换后的$\hat{i}$和$\hat{j}$就是这个矩阵的列值。根据对称性，变换后的$\hat{i}$其实就是$\vec{u}$在x轴上面的投影，也就是$u_x$,同理，变换后的$\hat{j}$其实就是$u_y$，也就是说这个变化矩阵transform matrix就是$\begin{bmatrix} u_x&amp;u_y \end{bmatrix}$</p><img src="/2018/09/03/linear-algebra-graphics/dot_product_duality_1.webp"><p>那么，对于空间中任意一个向量$\begin{bmatrix} x \\\ y \end{bmatrix}$,从自身一个二维向量映射到U轴上面的数值的这一变化，就可以描述成</p><script type="math/tex; mode=display">\begin{bmatrix} u_x&u_y \end{bmatrix}\begin{bmatrix} x \\\ y \end{bmatrix} = u_x \cdot x + u_y \cdot y$$，也就是向量在U轴上面投影的长度对于这种二维向量变成一维数值，其本身的定义就是$$\begin{bmatrix} u_x \\\ u_y \end{bmatrix} \cdot \begin{bmatrix} x \\\ y \end{bmatrix} = u_x \cdot x + u_y \cdot y</script><p>这么一来，可以发现$\begin{bmatrix} u_x&amp;u_y \end{bmatrix}\begin{bmatrix} x \\\ y \end{bmatrix} = u_x \cdot x + u_y \cdot y$与$\begin{bmatrix} u_x \\\ u_y \end{bmatrix} \cdot \begin{bmatrix} x \\\ y \end{bmatrix} = u_x \cdot x + u_y \cdot y$相等</p><p>也就是说，对于单位向量的点积可以解读为将向量投影到单位向量所在的直线上所得到的长度</p><p>至此，两个向量点积，就是将其中一个向量转化为线性变换</p><script type="math/tex; mode=display">\begin{bmatrix} x_1 \\\ y_1 \end{bmatrix} \cdot \begin{bmatrix} x_2 \\\ y_2 \end{bmatrix}</script><script type="math/tex; mode=display">\begin{bmatrix} x_1&y_1 \end{bmatrix}\begin{bmatrix} x_2 \\\ y_2 \end{bmatrix}</script><h2 id="Cross-products叉积"><a href="#Cross-products叉积" class="headerlink" title="Cross products叉积"></a>Cross products叉积</h2><p>[Ref:<a href="https://betterexplained.com/articles/cross-product/" target="_blank" rel="noopener">https://betterexplained.com/articles/cross-product/</a>]</p><p>点积关注的是相同部分的interaction,而叉积关注的是不同部分，见下图： 而面积其实就是不同部分造成的一种结果。比方说两个相同方向的变量，是没有面积的，只有不同方向且不在一条线上的变量才有面积/体积的概念。在物理中比方说力矩(torque)，只有在不同方向上才有力矩的概念<br><img src="/2018/09/03/linear-algebra-graphics/cross-product-grid.png"></p><p>叉积就是想定义一个rule,把所有不同的部分加起来<br>再看一遍上面的图，根据右手定理，x cross y能够定义一个正z，但是y cross x就是一个负z<br>y cross z is x, z cross z is -x;<br>所以记住这个Order XYZXYZ（这个就是一个正的顺序，只要按照这个顺序做，就是正的方向）。那么：</p><script type="math/tex; mode=display">(1,2,3) \times (4,5,6) = ?</script><p>先看z，z由x,y来定义，根据XYZ这个顺序，只要是x cross y，则z为正，所以</p><script type="math/tex; mode=display">z = 1 \times 5 - 2 \times 4 = -3</script><p>再看y，y由x,z来决定，根据XYZXYZ这个顺序。只要是z cross x，则y为正，所以</p><script type="math/tex; mode=display">y = -1 \times 6 + 3 \times 4 = 6</script><p>最后看x，x由y,z决定，根据XYZ这个顺序，y cross z = positive x:</p><script type="math/tex; mode=display">x = 2 \times 6 - 3 \times 5 = -3</script><p>所以最终结果为(-3,6,-3)</p><p>—————————————————3Blue1Brown——————————————————</p><p>叉积的定义就是两个向量组成的平行四边形的面积</p><script type="math/tex; mode=display">\vec{v} \times \vec{w} =  \text{Area of parallelogram}</script><p>如果$\vec{v}$在$\vec{w}$的右边，叉积为正，如果在左边，叉积为负</p><p>由于变换后的向量构成面积就相当于行列式，所以</p><script type="math/tex; mode=display">\vec{v} \times \vec{w} =  det(\begin{bmatrix} 3&2 \\\ 1&-1 \end{bmatrix})</script><p>更为准确的理解是在3D视图中，叉积是指以两个向量的面积为长度，右手定理大拇指为方向的一个向量，<span style="color: red">注意，这里$\vec{p}$是一个向量</span></p><script type="math/tex; mode=display">\vec{v} \times \vec{w} = \vec{p}</script><p>$\vec{p}$的长度就是$\vec{v}$和$\vec{w}$所形成的平行四边形的面积<br>同时$\vec{p}$的方向与这个平行四边形垂直<br><img src="/2018/09/03/linear-algebra-graphics/cross_product_3d.png"></p><p>更为通用的公式：<br><img src="/2018/09/03/linear-algebra-graphics/cross_product_formula.png"></p><p>这里就有一个疑问了，我为什么行列式第一列要放$\hat{i},\hat{j},\hat{k}$?<br>这里要用对偶性来解释</p><p><strong>对偶性</strong>：无论何时你看到一个二维到一维的线性变换，你都能在平面中这个到这个向量。用这个线性变换得到的结果与用这个向量做点积是一样的结，比方说$\begin{bmatrix} 4&amp;1 \end{bmatrix}$这个线性变换，线性变换后的结果与以$\begin{bmatrix} 4 \\\ 1 \end{bmatrix}$做点积结果相同.<br><img src="/2018/09/03/linear-algebra-graphics/cross_product_duality.png"></p><p>数值上来解释的话，这是因为这类线性变换可以用一个只有一行的矩阵来描述，而这个矩阵的每一列给出了变换后基向量的位置。<br><img src="/2018/09/03/linear-algebra-graphics/cross_product_duality_base.png"></p><p>这里的收获在于，每当你看到一个从空间到数轴的线性变换，你就能找到一个向量（成为这个线性变换的对偶向量），使得应用线性变换和对偶向量点乘等价。<br><img src="/2018/09/03/linear-algebra-graphics/cross_product_duality_equal.png"></p><p>回到叉积上面<br>1，叉积就是要根据给定的$\vec{v}$和$\vec{w}$做一个从3维空间到一维的线性变换（回忆一下，二维到一维的变换就是给定了一个$\vec{u}$）<br>2，然后我们要根据这个变换找到其对应的对偶向量<br>3，这个对偶向量就会是$\vec{v}$和$\vec{w}$的叉积</p><p>对于空间中任意一个向量$\begin{bmatrix} x \\\ y \\\ z \end{bmatrix}$<br>,其与$\vec{v}$与$\vec{w}$形成的平行四边形的体积可以表示成：</p><script type="math/tex; mode=display">f(\begin{bmatrix} x\\ y\\ z \end{bmatrix}) = det(\begin{bmatrix} x&v_1&w_1 \\\ y&v_2&w_2 \\\ z&v_3&w_3 \end{bmatrix})</script><p>这个函数一个重要特征就是，这是个线性函数：(平行，等距，固定原点)<br>1.易知，当u取原点时，这一变换会使之缩到原点，因为这个平行六面体已经没有高了.<br>2.根据相似的原理，当u在一条直线上运动时，这个平行六面体的体积与u的长度成正比<br>3.所以在这条直线上等距取u时，这一变换会使得这些点在数轴上等距分布</p><p>一旦你知道这个是线性的，我们就可以运用对偶性来解决问题，也就是f()部分可以改成一个1x3矩阵与向量$\begin{bmatrix} x \\ y \\z \end{bmatrix}$的线性变换：</p><script type="math/tex; mode=display">\begin{bmatrix} ?&?&? \end{bmatrix}\begin{bmatrix} x \\\ y \\\ z \end{bmatrix} = det(\begin{bmatrix} x&v_1&w_1 \\\ y&v_2&w_2 \\\ z&v_3&w_3 \end{bmatrix})</script><p>并且由于对偶性（也就是线性变换可以用这个矩阵的倒置与特定向量(x,y,z)来做点积来表示）</p><script type="math/tex; mode=display">\begin{bmatrix} ?\\\?\\\? \end{bmatrix} \cdot \begin{bmatrix} x \\ y \\ z \end{bmatrix} = det(\begin{bmatrix} x&v_1&w_1 \\\ y&v_2&w_2 \\\ z&v_3&w_3 \end{bmatrix})</script><p>所以说我们要找的就是这个特殊的3D向量$\vec{p}$，使得向量p与其他任一向量(x,y,z)的点积等于一个3x3矩阵的行列式(这个矩阵第一列为这个任一向量(x,y,z),其余两列分别为v和w的坐标)</p><img src="/2018/09/03/linear-algebra-graphics/cross_product_p.png"><p>这个时候我们<strong>从计算的角度</strong>来看，p的值单纯就由向量$\vec{v}$与向量$\vec{w}$来表示<br><img src="/2018/09/03/linear-algebra-graphics/cross-product-p.png"></p><script type="math/tex; mode=display">\begin{cases}p_1 = v_2 \cdot w_3 - v_3 \cdot w_2 \\\ p_2 = v_3 \cdot w_1 - v_1 \cdot w_3 \\\ p_3 = v_1 \cdot w_2 - v_2 \cdot w_1\end{cases}</script><p>这个计算过程与叉积的计算定义是如此的相似,而叉积定义中的$\hat{i},\hat{j},\hat{k}$只不过在传递一个信号，也就是我们应该把这些系数解读为一个向量的坐标<br><img src="/2018/09/03/linear-algebra-graphics/cross_product_p2.png"><br><img src="/2018/09/03/linear-algebra-graphics/cross-product-definec.png"></p><p><strong>从Geomatrically理解</strong></p><p>首先$\vec{p} \cdot \begin{bmatrix} x\\\y\\\z \end{bmatrix}$的几何意义就是将这个(x,y,z)向量映射到向量$\vec{p}$上，然后将这个投影长度与p的长度相乘:<br><img src="/2018/09/03/linear-algebra-graphics/cross_product_pdot.png"></p><p>然后再从平行六边形体积的计算方式来看，首先是一个平行四边形面积(向量$\vec{v}$,$\vec{w}$)的底乘以向量(x,y,z)在垂直于平行四边形方向上的分量<br><img src="/2018/09/03/linear-algebra-graphics/cross-product-geo1.png"></p><p>这个时候我们来看这个公式：</p><script type="math/tex; mode=display">\vec{p} \cdot \begin{bmatrix} x \\ y \\ z \end{bmatrix} = det(\begin{bmatrix} x&v_1&w_1 \\ y&v_2&w_2 \\ z&v_3&w_3 \end{bmatrix})</script><p>就可以看成：</p><script type="math/tex; mode=display">\vec{p} \cdot \begin{bmatrix} x \\ y \\ z \end{bmatrix} = \text{(Area of the parallelogram)} \times \text{(Component of }\begin{bmatrix} x\\y\\z \end{bmatrix} \text{perpendicular to v and w)}</script><p>其中左边代表<strong>向量(x,y,z)映射到$\vec{p}$的长度</strong>再$\times \vec{p}$的长度，右边(Component….)刚好与“向量(x,y,z)映射到$\vec{p}$的长度”的意义相同，所以<strong>$\vec{p}$的长度也就是(Area of the parallelogram)</strong></p><h2 id="基变换"><a href="#基变换" class="headerlink" title="基变换"></a>基变换</h2><img src="/2018/09/03/linear-algebra-graphics/basis_transform_1.png"><p>用我们的基变量替换别人的基变量得到在我们坐标下变换后的变量<br>其实这个计算过程，就相当于矩阵的相乘：<br><img src="/2018/09/03/linear-algebra-graphics/basis_transform_2.png"></p>]]></content>
      
      
        <tags>
            
            <tag> Concept </tag>
            
            <tag> Maths </tag>
            
            <tag> LinearAlgebra </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python-crawler</title>
      <link href="/2018/08/14/python-crawler/"/>
      <url>/2018/08/14/python-crawler/</url>
      <content type="html"><![CDATA[<h2 id="XPath"><a href="#XPath" class="headerlink" title="XPath"></a>XPath</h2><h3 id="路径表达式"><a href="#路径表达式" class="headerlink" title="路径表达式"></a>路径表达式</h3><pre><code>*    nodename选取此节点的所有子节点*    /从根节点选取*    //从匹配的当前节点选择文档中的节点，而不考虑他们的位置*    . 选取当前节点*    .. 选取当前节点的父节点*    @选取属性</code></pre><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;bookstore&gt;    &lt;book&gt;        &lt;title lang=&quot;eng&quot;&gt;Harry Potter&lt;/title&gt;        &lt;price&gt;29.99&lt;/price&gt;    &lt;/book&gt;    &lt;book&gt;        &lt;title lang=&quot;eng&quot;&gt;Learn XML&lt;/title&gt;        &lt;price&gt;75&lt;/price&gt;    &lt;/book&gt;&lt;/bookstore&gt;</code></pre><a id="more"></a><p>例子</p><pre><code>*    bookstore 选取bookstore元素的所有子节点*    /bookstore 选取根元素bookstore*    /bookstore/book 选取属于bookstore的子元素的所有book元素*    //book 选取所有book元素，而不管它们在文档中的位置。*    bookstore//book 选择属于bookstore元素的后代的所有book元素*    //@lang 选取名为lang的所有属性</code></pre><p>谓语</p><pre><code>*    嵌在[]中用来查找某个特定节点或包含某个指定值得节点。*    /bookstore/book[1] 第一个book元素*    /bookstore/book[last()] 最后一个book元素*    /bookstore/book[position()&lt;3] 选择前2个*    //title[@lang] 选择所拥有有名为lang的属性的title元素*    /bookstore/book[price&gt;35.00]</code></pre><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>基本匹配规则</p><pre><code>*    [0-9] 任意一个数字，等价\d*    [a-z] 任意一个小写字母*    [A-Z]任意一个大写字母*    [^0-9] 匹配非数字，等价\D*    \w 等价[a-z0-9_]，字母数字下划线*    \W 等价对\w取非*    . 任意字符*    [] 匹配内部任意字符或子表达式*    [^] 对字符集合取非*    * 匹配前面的字符或者子表达式0次或多次*    + 匹配前一个字符至少1次*    ？ 匹配前一个字符0次或1次*    ^ 匹配字符串开头*    $ 匹配字符串结束    *    </code></pre><h2 id="用selenium模拟用户打开浏览器然后抓数据"><a href="#用selenium模拟用户打开浏览器然后抓数据" class="headerlink" title="用selenium模拟用户打开浏览器然后抓数据"></a>用selenium模拟用户打开浏览器然后抓数据</h2><h3 id="包含如果网页有惰性加载的情况，需要scroll到页面最底部"><a href="#包含如果网页有惰性加载的情况，需要scroll到页面最底部" class="headerlink" title="包含如果网页有惰性加载的情况，需要scroll到页面最底部"></a>包含如果网页有惰性加载的情况，需要scroll到页面最底部</h3><pre><code class="python">from selenium import webdriverimport timebrowser = webdriver.Chrome()browser.set_page_load_timeout(30)browser.get(&#39;http://www.17huo.com/search.html?sq=2&amp;keyword=%E7%BE%8A%E6%AF%9B&#39;)page_info = browser.find_element_by_css_selector(&#39;body &gt; div.wrap &gt; div.pagem.product_list_pager &gt; div&#39;)# print(page_info.text)pages = int((page_info.text.split(&#39;，&#39;)[0]).split(&#39; &#39;)[1])for page in range(pages):    if page &gt; 2:        break    url = &#39;http://www.17huo.com/?mod=search&amp;sq=2&amp;keyword=%E7%BE%8A%E6%AF%9B&amp;page=&#39; + str(page + 1)    browser.get(url)    browser.execute_script(&quot;window.scrollTo(0, document.body.scrollHeight);&quot;)    time.sleep(3)   # 不然会load不完整    goods = browser.find_element_by_css_selector(&#39;body &gt; div.wrap &gt; div:nth-child(2) &gt; div.p_main &gt; ul&#39;).find_elements_by_tag_name(&#39;li&#39;)    print(&#39;%d页有%d件商品&#39; % ((page + 1), len(goods)))    for good in goods:        try:            title = good.find_element_by_css_selector(&#39;a:nth-child(1) &gt; p:nth-child(2)&#39;).text            price = good.find_element_by_css_selector(&#39;div &gt; a &gt; span&#39;).text            print(title, price)        except:            print(good.text)</code></pre><h2 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h2><h3 id="用Requests"><a href="#用Requests" class="headerlink" title="用Requests"></a>用Requests</h3><pre><code class="python">import requestsfrom PIL import Imagefrom io import BytesIOr = requests.get(&#39;https://images.unsplash.com/photo-1504714146340-959ca07e1f38?ixlib=rb-0.3.5&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;s=2c5ef407d31cf63f60bd7782132ee877&amp;auto=format&amp;fit=crop&amp;w=925&amp;q=80&#39;)image = Image.open(BytesIO(r.content))image.save(&#39;scenary.png&#39;)#原始数据处理,例stream数据，一点点读出来，而不是一次性读出来r = requests.get(&#39;https://images.unsplash.com/photo-1504714146340-959ca07e1f38?ixlib=rb-0.3.5&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;s=2c5ef407d31cf63f60bd7782132ee877&amp;auto=format&amp;fit=crop&amp;w=925&amp;q=80&#39;, stream = True)with open(&#39;scenary2.png&#39;, &#39;wb+&#39;) as f:    for chunk in r.iter_content(1024):        f.write(chunk)</code></pre><h2 id="Scrapy"><a href="#Scrapy" class="headerlink" title="Scrapy"></a>Scrapy</h2><h3 id="Architecture-Overview"><a href="#Architecture-Overview" class="headerlink" title="Architecture Overview"></a>Architecture Overview</h3><img src="/2018/08/14/python-crawler/scrapy_architecture_02.png"><pre><code>1. Engine从Spider那里拿到初始Url2. Engine把Requests丢给Scheduler,Scheduler返回下一个需要爬的requests3. Scheduler生成下一个Requests4. Engine把新的Requests丢给Downloader，让其下载页面5. Downloader下载完（生成Response）后返回给Engine6. Engine把这个Response丢给Spider让他处理7. Spider把Response变成你定义规则的Scraped Items，如果有新的需要爬的，重新传给Engine8. Engine把Scraped Items传给Item Pipelines,在ItemPipelines里面可以保存到数据库，对数据清洗等等。然后Engines再问Schedule是否还有需要Requests的东西9. 从Step1循环，直至没有新的Requests</code></pre><h3 id="User-Login"><a href="#User-Login" class="headerlink" title="User Login"></a>User Login</h3><h4 id="注意点一，start-requests-方法必须返回一个iterable"><a href="#注意点一，start-requests-方法必须返回一个iterable" class="headerlink" title="注意点一，start_requests()方法必须返回一个iterable."></a>注意点一，start_requests()方法必须返回一个iterable.</h4><p>Scrapy calls it only once, so it is safe to implement <code>start_requests()</code> as a generator.</p><h4 id="注意点二，用FormRequest可以通过HTTP-POST方式发送数据"><a href="#注意点二，用FormRequest可以通过HTTP-POST方式发送数据" class="headerlink" title="注意点二，用FormRequest可以通过HTTP POST方式发送数据"></a>注意点二，用FormRequest可以通过HTTP POST方式发送数据</h4><pre><code class="python">return [FormRequest(url=&quot;http://www.example.com/post/action&quot;,                    formdata={&#39;name&#39;: &#39;John Doe&#39;, &#39;age&#39;: &#39;27&#39;},                    callback=self.after_post)]</code></pre><h4 id="注意点三，FormRequest-from-response-可以模拟用户登陆"><a href="#注意点三，FormRequest-from-response-可以模拟用户登陆" class="headerlink" title="注意点三，FormRequest.from_response()可以模拟用户登陆"></a>注意点三，FormRequest.from_response()可以模拟用户登陆</h4><pre><code class="python">import scrapyclass LoginSpider(scrapy.Spider):    name = &#39;example.com&#39;    start_urls = [&#39;http://www.example.com/users/login.php&#39;]    def parse(self, response):        return scrapy.FormRequest.from_response(            response,            formdata={&#39;username&#39;: &#39;john&#39;, &#39;password&#39;: &#39;secret&#39;},            callback=self.after_login        )    def after_login(self, response):        # check login succeed before going on        if &quot;authentication failed&quot; in response.body:            self.logger.error(&quot;Login failed&quot;)            return        # continue scraping with authenticated session...</code></pre><h4 id="注意点四，scrapy-FormRequest的meta作用，是向response传递数据"><a href="#注意点四，scrapy-FormRequest的meta作用，是向response传递数据" class="headerlink" title="注意点四，scrapy.FormRequest的meta作用，是向response传递数据"></a>注意点四，scrapy.FormRequest的meta作用，是向response传递数据</h4><h4 id="注意点五，dont-filter-True意味着如果需要多次提交表单，且url一样，那么就让爬虫继续爬，否则爬虫会有去重机制不会再爬这个页面"><a href="#注意点五，dont-filter-True意味着如果需要多次提交表单，且url一样，那么就让爬虫继续爬，否则爬虫会有去重机制不会再爬这个页面" class="headerlink" title="注意点五，dont_filter=True意味着如果需要多次提交表单，且url一样，那么就让爬虫继续爬，否则爬虫会有去重机制不会再爬这个页面"></a>注意点五，dont_filter=True意味着如果需要多次提交表单，且url一样，那么就让爬虫继续爬，否则爬虫会有去重机制不会再爬这个页面</h4><p>示例：登陆然后爬数据</p><p>例：</p><pre><code class="python">import scrapyfrom PIL import Imagefrom urllib.request import urlretrieveclass MovieCommentSpider(scrapy.Spider):    name = &#39;movie_comment&#39;    allowed_domains = [&#39;accounts.douban.com&#39;, &#39;douban.com&#39;]    headers = {        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.221 Safari/537.36 SE 2.X MetaSr 1.0&quot;    }    def start_requests(self):        return [scrapy.FormRequest(&quot;https://accounts.douban.com/login&quot;                                  , headers=self.headers                                  , meta={&quot;cookiejar&quot;: 1},                                  callback=self.parse_before_login)]    def parse_before_login(self, response):        captcha_id = response.xpath(&#39;//input[@name=&quot;captcha-id&quot;]/@value&#39;).extract_first()        captcha_image_url = response.xpath(&#39;//img[@id=&quot;captcha_image&quot;]/@src&#39;).extract_first()        if captcha_image_url is None:            formdata = {                &quot;source&quot;: &quot;index_nav&quot;,                &quot;form_email&quot;: &quot;************@yahoo.com.cn&quot;,                &quot;form_password&quot;: &quot;***************&quot;,            }        else:            save_image_path = &quot;D:\\captcha.jpeg&quot;            # 将图片验证码下载到本地            urlretrieve(captcha_image_url, save_image_path)            # 打开图片，以便我们识别图中验证码            try:                im = Image.open(&#39;captcha.jpeg&#39;)                im.show()            except:                pass            # 手动输入验证码            captcha_solution = input(&#39;**********Please input capture:*************&#39;)            formdata = {                &quot;source&quot;: &quot;None&quot;,                &quot;redir&quot;: &quot;https://www.douban.com&quot;,                &quot;form_email&quot;: &quot;******************@yahoo.com.cn&quot;,                # 此处请填写密码                &quot;form_password&quot;: &quot;*****************&quot;,                &quot;captcha-solution&quot;: captcha_solution,                &quot;captcha-id&quot;: captcha_id,                &quot;login&quot;: &quot;登录&quot;,            }        # 提交表单        return scrapy.FormRequest.from_response(response                                                , meta={&quot;cookiejar&quot;: response.meta[&quot;cookiejar&quot;]}                                                , headers=self.headers                                                , formdata=formdata                                                , callback=self.parse_after_login)    def parse_after_login(self, response):        &#39;&#39;&#39;        验证登录是否成功        &#39;&#39;&#39;        account = response.xpath(&#39;//a[@class=&quot;bn-more&quot;]/span/text()&#39;).extract_first()        if account is None:            print(&quot;Login Failed&quot;)        else:            print(&quot;Login Success,Current account is {0}&quot;.format(account))</code></pre>]]></content>
      
      
        <tags>
            
            <tag> practice </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python-third-packages</title>
      <link href="/2018/08/09/python-third-packages/"/>
      <url>/2018/08/09/python-third-packages/</url>
      <content type="html"><![CDATA[<h2 id="数值计算numpy"><a href="#数值计算numpy" class="headerlink" title="数值计算numpy"></a>数值计算numpy</h2><p>1，numpy的ndarray是一个多维数组对象，该对象由两部分组成：<br>    1，实际的数据<br>    2，描述这些数据的元数据，比方说数据是如何排列的，结构是什么样<br>    3，很多时候我们只修改的是元数据，而不更改实际数据<br>2，numpy能够直接对数组和矩阵进行操作，不需要写python，所以会比较快<br>3，numpy基本索引和切片：<br><a id="more"></a></p><pre><code class="python">import numpy as np# 数组乘法/减法，对应元素相乘/相减arr = np.array([[1.0,2.0,3.0],[4.,5.,6.]])print(arr * arr)print(arr - arr)# 标量操作作用在数组的每个元素上arr = np.array([[1.0,2.0,3.0],[4.,5.,6.]])print(1/arr)print(arr**0.5) #开根号# 通过索引访问二维数组某一行或某个元素arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])print(arr[2])#打印出第三个元素print(arr[0][2])#打印出第一个元素中的第三个元素print(arr[0, 2]) # 普通Python数组不能用。# 对更高维数组的访问和操作arr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])print (arr[0])  # 结果是个2维数组print (arr[1, 0]) # 结果是个2维数组old_values = arr[0].copy()  # 复制arr[0]的值arr[0] = 42 # 把arr[0]所有的元素都设置为同一个值print (arr)arr[0] = old_values # 把原来的数组写回去print (arr)</code></pre><p>4，numpy boolean索引</p><pre><code class="python">import numpy as npimport numpy.random as np_randomprint (&#39;使用布尔数组作为索引&#39;)name_arr = np.array([&#39;Bob&#39;, &#39;Joe&#39;, &#39;Will&#39;, &#39;Bob&#39;, &#39;Will&#39;, &#39;Joe&#39;, &#39;Joe&#39;])rnd_arr = np_random.randn(7, 4) # 随机7*4数组print (rnd_arr)print (name_arr == &#39;Bob&#39;) # 返回布尔数组，元素等于&#39;Bob&#39;为True，否则False。print (rnd_arr[name_arr == &#39;Bob&#39;])# 利用布尔数组选择行print (rnd_arr[name_arr == &#39;Bob&#39;, :2]) # 增加限制打印列的范围print (rnd_arr[-(name_arr == &#39;Bob&#39;)])# 对布尔数组的内容取反mask_arr = (name_arr == &#39;Bob&#39;) | (name_arr == &#39;Will&#39;) # 逻辑运算混合结果print (rnd_arr[mask_arr])rnd_arr[name_arr != &#39;Joe&#39;] = 7  # 先布尔数组选择行，然后把每行的元素设置为7。print (rnd_arr)</code></pre><p>5，numpy的花式索引</p><pre><code class="python">#比方说我想要索引在第5，第3，第1位的元素a = [1,2,3,4,5]b = a[[5,3,1]] #即可import numpy as npprint (&#39;Fancy Indexing: 使用整数数组作为索引&#39;)arr = np.empty((8, 4))for i in range(8):    arr[i] = iprint (arr)print (arr[[4, 3, 0, 6]]) # 打印arr[4]、arr[3]、arr[0]和arr[6]。print (arr[[-3, -5, -7]]) # 打印arr[3]、arr[5]和arr[-7]行arr = np.arange(32).reshape((8, 4))  # 通过reshape变换成二维数组print (arr[[1, 5, 7, 2], [0, 3, 1, 2]]) # 打印arr[1, 0]、arr[5, 3]，arr[7, 1]和arr[2, 2]print (arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]])  # 1572行的0312列print (arr[np.ix_([1, 5, 7, 2], [0, 3, 1, 2])]) # 可读性更好的写法</code></pre><p>6，numpy的ndarray数组转置和轴对换</p><pre><code class="python">import numpy as npprint(&quot;矩阵的乘积，(axb)*(cxd)=(a&#39;xd&#39;)，要求b=c&quot;)arr1 = [[1,2,3],[4,5,6]]arr2 = [[4,5],[6,7],[8,9]]# print(np.dot(arr1,arr2))print(&quot;高维矩阵轴变换&quot;)arr3 = np.arange(16).reshape((2,2,4))print(arr3)# 决定总共有多少列取决于原来的A[x][y][z]的z，最大层有几个元素取决于原来的x，所以如果轴变换为（2，1，0）那么最终由两列，四个最大层元素。把结构画好了以后再转换就会很快# print(np.ndim(arr3))print(arr3.transpose((2,1,0)))</code></pre><p>7，numpy where条件过滤</p><pre><code class="python">import numpy as npimport numpy.random as np_randomprint(&quot;where&quot;)cond = np.array([True,False,True,True,False])cond_1 = np.array([True,False,True,True,False])cond_2 = np.array([False,True,False,True,False])result = []#传统代码如下for i in range(len(cond)):    if cond_1[i] and cond_2[i]:        result.append(0)    elif cond_1[i]:        result.append(1)    elif cond_2[i]:        result.append(2)    else:        result.append(3)print(result)# np版本result = np.where(cond_1 &amp; cond_2, 0, np.where(cond_1, 1, np.where(cond_2, 2, 3)))print(result)</code></pre><p>8，numpy 求和求平均</p><pre><code class="python">import numpy as npprint(&quot;求和，求平均&quot;)arr = np.random.randn(5,4)print(arr)print(arr.mean())#所有元素求平均print(arr.mean(axis = 1)) #对每一行的元素求平局print(arr.sum())#所有元素求和print(arr.sum(0))#对每一列的元素求和</code></pre><p>9，numpy布尔型数组过滤</p><pre><code class="python">import numpy as npprint(&quot;对正数求和&quot;)arr = np.random.randn(100)print((arr&gt;0).sum())print(&quot;对数组逻辑操作&quot;)bools = np.array([False,False,True,False])print(bools.any())#有一个为True则返回Trueprint(bools.all())#有一个为False则返回False</code></pre><p>10，利用数组进行数据处理和排序</p><pre><code class="python">print (&#39;二维数组排序&#39;)arr = np_random.randn(5, 3)print (arr)arr.sort(1) # 对每一行元素做排序print (arr)print (&#39;找位置在5%的数字&#39;)large_arr = np_random.randn(1000)large_arr.sort()print (large_arr[int(0.05 * len(large_arr))])</code></pre><p>11，利用数组来去重以及其它集合运算<br><img src="/2018/08/09/python-third-packages/numpy_unique.png"></p><blockquote><p>例子：距离矩阵的计算<br>给定m*n阶矩阵X，满足X = [x<sub>1</sub>,x<sub>2</sub>,…,x<sub> n</sub>],这里第i列向量是m维向量。<br>求n * n矩阵，使得D<sub>ij</sub>=||x<sub>i</sub> - x<sub>&gt; j</sub>||<sup>2</sup>  </p></blockquote><p>这个例子的意思是有x<sub>i</sub>,x<sub>j</sub><br>D<sub>ij</sub> = (x<sub>[0][i]</sub> - x<sub>[0][j]</sub>)<sup>2</sup> + (x<sub>[1][i]</sub> - x<sub>[1][j]</sub>)<sup>2</sup> + … + (x<sub>[m][i]</sub> - x<sub>[m][j]</sub>)<sup>2</sup></p><pre><code class="python">import numpy as npimport numpy.linalg as laimport timeX = np.array([range(0,500),range(500,1000)])# print(X)m,n = X.shapet = time.time()D = np.zeros([n,n])for i in range(n):    for j in range(i+1, n):        D[i,j] = la.norm(X[:, i] - X[:, j]) ** 2        D[j,i] = D[i,j]print(time.time() - t) t = time.time()D = np.zeros([n,n])#d[k] = X[k][i] -X[k][j]#d[i,j] = d[0]^2 + d[1]^2for i in range(n):    for j in range(i+1, n):        #把第i列和第j列相减        d = X[:, i] - X[:, j]        #然后做矩阵乘法的运算        D[i,j] = np.dot(d,d)        D[j,i] = D[i,j]print(time.time()-t)t = time.time()G = np.dot(X.T, X)H = np.tile(np.diag(G), (n, 1))D = H + H.T - G * 2print (time.time() - t)</code></pre><h2 id="数据处理分析pandas"><a href="#数据处理分析pandas" class="headerlink" title="数据处理分析pandas"></a>数据处理分析pandas</h2><h3 id="数据结构Series"><a href="#数据结构Series" class="headerlink" title="数据结构Series"></a>数据结构Series</h3><p>1，Series是一种类似于一维数组的对象，它由一组数据（各种NumPy数据类型）以及一组与之相关的数据标签（即索引）组成<br>2，Series的字符串表现形式为：索引在左边，值在右边<br>3，默认是数字索引</p><pre><code class="python">from pandas import Seriesprint(&quot;用数组生成series&quot;)obj = Series([5,7,-1,3])print(obj)print(&quot;指定Series的index&quot;)obj2 = Series([5,7,-1,3], index = [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;])print(obj2)print(&quot;使用字典生成Series&quot;)dData = {&#39;ohio&#39;:3999,&quot;texas&quot;:2000,&quot;oregon&quot;:123123}obj3 = Series(dData)print(obj3)</code></pre><h3 id="数据结构DataFrame"><a href="#数据结构DataFrame" class="headerlink" title="数据结构DataFrame"></a>数据结构DataFrame</h3><p>1，DataFrame是一个表格型数据结构，它含有一组有序的列，每列可以试不同的值的类型（数值、字符串、布尔值等）<br>2，DataFrame既有行索引，也有列索引，可以被看做由Series组成的字典（共用同一个索引）。</p><pre><code class="python">import numpy as npfrom pandas import Series, DataFrameprint(&#39;用字典生成DataFrame，key为列的名字。&#39;)data = {&#39;state&#39;:[&#39;Ohio&#39;, &#39;Ohio&#39;, &#39;Ohio&#39;, &#39;Nevada&#39;, &#39;Nevada&#39;],        &#39;year&#39;:[2000, 2001, 2002, 2001, 2002],        &#39;pop&#39;:[1.5, 1.7, 3.6, 2.4, 2.9]}print(DataFrame(data))print(DataFrame(data, columns = [&#39;year&#39;, &#39;state&#39;, &#39;pop&#39;])) # 指定列顺序print &#39;指定索引，在列中指定不存在的列，默认数据用NaN。&#39;frame2 = DataFrame(data,                    columns = [&#39;year&#39;, &#39;state&#39;, &#39;pop&#39;, &#39;debt&#39;],                    index = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;, &#39;five&#39;])print frame2print frame2[&#39;state&#39;]print frame2.yearprint frame2.ix[&#39;three&#39;]frame2[&#39;debt&#39;] = 16.5 # 修改一整列print frame2frame2.debt = np.arange(5)  # 用numpy数组修改元素print frame2printprint &#39;赋值给新列&#39;frame2[&#39;eastern&#39;] = (frame2.state == &#39;Ohio&#39;)  # 如果state等于Ohio为Trueprint frame2print frame2.columnsprint</code></pre><p>3，数据的清理用drop</p><pre><code class="python">import numpy as npfrom pandas import Series, DataFrameprint &#39;Series根据索引删除元素&#39;obj = Series(np.arange(5.), index = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;])new_obj = obj.drop(&#39;c&#39;)print new_objprint obj.drop([&#39;d&#39;, &#39;c&#39;])printprint &#39;DataFrame删除元素，可指定索引或列。&#39;data = DataFrame(np.arange(16).reshape((4, 4)),                  index = [&#39;Ohio&#39;, &#39;Colorado&#39;, &#39;Utah&#39;, &#39;New York&#39;],                  columns = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;])print dataprint data.drop([&#39;Colorado&#39;, &#39;Ohio&#39;])print data.drop(&#39;two&#39;, axis = 1) #axis=1代表处理的是列print data.drop([&#39;two&#39;, &#39;four&#39;], axis = 1) #原始数据并没有被删除</code></pre><h3 id="Pandas-Data-Selection"><a href="#Pandas-Data-Selection" class="headerlink" title="Pandas Data Selection"></a>Pandas Data Selection</h3><img src="/2018/08/09/python-third-packages/pandas-selections.png"><p>准备数据</p><pre><code class="python">import pandas as pdimport randomdata = pd.read_csv(&#39;https://s3-eu-west-1.amazonaws.com/shanebucket/downloads/uk-500.csv&#39;)data[&#39;id&#39;] = [random.randint(0,1000) for x in range(data.shape[0])]data.head(5)</code></pre><p>1, By row numbers(.iloc)<br>“iloc” in pandas is used to <strong>select rows and columns by number</strong><br><code>data.iloc[&lt;row selection&gt;,&lt;column selection&gt;]</code></p><p>注意是开区间，你选择[1:5]返回的是1,2,3,4</p><pre><code class="python"># Single selections using iloc and DataFrame# Rows:data.iloc[0] # first row of data frame (Aleshia Tomkiewicz) - Note a Series data type output.data.iloc[1] # second row of data frame (Evan Zigomalas)data.iloc[-1] # last row of data frame (Mi Richan)# Columns:data.iloc[:,0] # first column of data frame (first_name)data.iloc[:,1] # second column of data frame (last_name)data.iloc[:,-1] # last column of data frame (id)# Multiple row and column selections using iloc and DataFramedata.iloc[0:5] # first five rows of dataframedata.iloc[:, 0:2] # first two columns of data frame with all rowsdata.iloc[[0,3,6,24], [0,5,6]] # 1st, 4th, 7th, 25th row + 1st 6th 7th columns.data.iloc[0:5, 5:8] # first 5 rows and 5th, 6th, 7th columns of data frame (county -&gt; phone1).</code></pre><p>2, By label or by a conditional statement(.loc)<br>    a) Selecting rows by label/index<br>    b) Selecting rows with a boolean/conditional lookup</p><p>注意用loc就不是开区间，而是闭区间了，Veness行和email列都会被选出来</p><pre><code class="python">data.set_index(&quot;last_name&quot;, inplace=True)data.head()data.loc[&#39;Andrade&#39;:&#39;Veness&#39;, &#39;city&#39;:&#39;email&#39;]#Conditional lookupdata.loc[data[&#39;first_name&#39;] == &#39;Erasmo&#39;,[&#39;company_name&#39;,&#39;email&#39;]]# Select rows where the email column ends with &#39;hotmail.com&#39;, include all columnsdata.loc[data[&#39;email&#39;].str.endswith(&quot;hotmail.com&quot;)]   # Select rows with last_name equal to some values, all columnsdata.loc[data[&#39;first_name&#39;].isin([&#39;France&#39;, &#39;Tyisha&#39;, &#39;Eric&#39;])] </code></pre><p>在这里注意了<br>如果<br><code>data.loc[data[&#39;first_name&#39;] == &#39;Erasmo&#39;,&#39;email&#39;]</code><br>即以<span style="color: red">.loc[<selection>,String]</selection></span>形式，返回的是一个Series</p><p>如果<br><code>data.loc[data[&#39;first_name&#39;] == &#39;Erasmo&#39;,[&#39;email&#39;]</code><br>即以<span style="color: red">.loc[<selection>,List]</selection></span>形式，返回的是一个DataFrame</p><img src="/2018/08/09/python-third-packages/loc1.png"><h2 id="可视化matplotlib-seaborn"><a href="#可视化matplotlib-seaborn" class="headerlink" title="可视化matplotlib/seaborn"></a>可视化matplotlib/seaborn</h2><pre><code class="python">import numpy as np; np.random.seed(0)import seaborn as sns; sns.set()uniform_data = np.random.rand(10, 12)ax = sns.heatmap(uniform_data)</code></pre><img src="/2018/08/09/python-third-packages/heatmap.png"><h2 id="机器学习Sklearn-keras"><a href="#机器学习Sklearn-keras" class="headerlink" title="机器学习Sklearn/keras"></a>机器学习Sklearn/keras</h2><img src="/2018/08/09/python-third-packages/scklearn.png"><p>python监督学习典型的三部曲</p><pre><code class="python">train_x, train_y, test_x, text_y = getData()model = somemodel()#选择一种模型model.fit(train_x, train_y)predictions = model.predict(test_x)score = score_function(test_y, predictions)</code></pre><h2 id="交互pygame"><a href="#交互pygame" class="headerlink" title="交互pygame"></a>交互pygame</h2><h2 id="网络Selenium"><a href="#网络Selenium" class="headerlink" title="网络Selenium"></a>网络Selenium</h2>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python多线程/多进程</title>
      <link href="/2018/08/07/python-concurrent/"/>
      <url>/2018/08/07/python-concurrent/</url>
      <content type="html"><![CDATA[<h2 id="全局解释器锁GIL"><a href="#全局解释器锁GIL" class="headerlink" title="全局解释器锁GIL"></a>全局解释器锁GIL</h2><p>1，GIL是一个全局排他锁，同一时刻只有一个线程在运行，就类似于Python是个单线程的程序<br>2，multiprocessing库很大程度上是为了弥补GIL低效的缺陷，它完整复制了一套thread所提供的接口方便迁移，唯一不同的是它使用了多进程而不是多线程，所以每个进程有自己的独立的GIL，因此不会出现进程间的GIL争抢<br>3，多进程的fork操作，调用一次返回两次，操作系统会自动把当前进程（称为父进程）复制了一份（作为子进程），然后分别在父进程和子进程内返回。子进程永远返回0，而父进程返回子进程的ID。子进程只需要调用<code>getppid()</code>就可以拿到父进程的ID</p><pre><code class="python">import osprint(&#39;Process (%s) start...&#39; % os.getpid())pid = os.fork()if pid == 0:    print(&quot;Child Process {0}, Parent Process {1}&quot;.format(os.getpid(), os.getppid()))else:    print(&quot;Parent Process is me {0}, my child process is {1}&quot;.format(os.getpid(),pid))</code></pre><a id="more"></a><p>multiprocessing</p><pre><code class="python">from multiprocessing import Processimport timedef f(n):    time.sleep(1)    print n*nif __name__ == &quot;__main__&quot;:    for i in range(10):        p = Process(target = f, args = [i,])        p.start()</code></pre><h2 id="进程间通信Queue"><a href="#进程间通信Queue" class="headerlink" title="进程间通信Queue"></a>进程间通信Queue</h2><p>1，Queue是多进程安全的队列，可以实现多进程之间的数据传递<br>2，Queue.qsize() 返回队列的大小<br>    Queue.empty() 如果队列为空，返回True,反之False<br>    Queue.full() 如果队列满了，返回True,反之False<br>    Queue.get([block[, timeout]]) 获取队列，timeout等待时间<br>    Queue.get_nowait() 相当Queue.get(False)<br>    非阻塞 Queue.put(item) 写入队列，timeout等待时间<br>    Queue.put_nowait(item) 相当Queue.put(item, False)</p><pre><code class="python">from multiprocessing import Process, Queueimport timedef write(q):    for i in [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;D&#39;,&#39;E&#39;]:        print(&#39;Put {0} to queue&#39;.format(i))        q.put(i)        time.sleep(0.5)def read(q):    while True:        v = q.get(True)        print(&#39;Get {0} from queue&#39;.format(v))if __name__ == &#39;__main__&#39;:    q = Queue()    pw = Process(target = write, args=(q,))    pr = Process(target = read, args=(q,))    pw.start()    pr.start()    pw.join()    pr.join()    pr.terminate()</code></pre><h2 id="进程池Pool"><a href="#进程池Pool" class="headerlink" title="进程池Pool"></a>进程池Pool</h2><p>1，用于批量创建子进程，可以灵活控制子进程的数量</p><pre><code class="python">from multiprocessing import Poolimport timedef f(x):    print x*x    time.sleep(2)    return x*xif __name__ == &#39;__main__&#39;:    &#39;&#39;&#39;定义启动进程的数量&#39;&#39;&#39;    pool = Pool(processes = 5)    res_list = []    for i in range(10):        &#39;&#39;&#39;以异步并行的方式启动进程，如果要同步等待的方式，可以在每次启动进程之后调用res.get()方法，也可以是用Pool.apply&#39;&#39;&#39;        res = pool.apply_async(f, [i,])        print(&#39;-----------:&#39;,i)        res_list.append(res)    pool.close()    pool.join() #强制等待所有进程运行完毕    for r in res_list:        print(&quot;result: &quot;,(r.get(timeout = 5)))#结果&#39;&#39;&#39;ubuntu@bosch-shiny1:~$ python multiPython.py -----------: 00-----------: 1-----------: 2-----------: 3-----------: 4-----------: 5-----------: 6-----------: 7-----------: 8-----------: 9149162536496481result:  0result:  1result:  4result:  9result:  16result:  25result:  36result:  49result:  64result:  81&#39;&#39;&#39;</code></pre><h2 id="多进程与多线程对比"><a href="#多进程与多线程对比" class="headerlink" title="多进程与多线程对比"></a>多进程与多线程对比</h2><p>1，主要区别就在于线程之间可以共享进程的资源，而进程是独立的<br>2，由于进程之前是互相独立的，所以结果会是</p><pre><code class="python">from multiprocessing import Processimport threadingimport timelock = threading.Lock()def run(info_list,n):    lock.acquire()    info_list.append(n)    lock.release()    print(&quot;{0}\n&quot;.format(info_list))if __name__ == &#39;__main__&#39;:    info = []    for i in range(10):        p = Process(target=run, args=[info,i])        p.start()        p.join()    time.sleep(1)    print(&#39;------------------------threading--------------------&#39;)    for i in range(10):        p = threading.Thread(target=run, args=[info,i])        p.start()        p.join()</code></pre><p>结果为</p><pre><code>[0][1][2][3][4][5][6][7][8][9]------------------------threading--------------------[0][0, 1][0, 1, 2][0, 1, 2, 3][0, 1, 2, 3, 4][0, 1, 2, 3, 4, 5][0, 1, 2, 3, 4, 5, 6][0, 1, 2, 3, 4, 5, 6, 7][0, 1, 2, 3, 4, 5, 6, 7, 8][0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre><p>如果想让multiprocessing也像多进程一样，可以用Queue</p><pre><code class="python">from multiprocessing import Process,Queueimport timeimport threadinglock = threading.Lock()def run(queue,info_list,n):    lock.acquire()    while not queue.empty():        value = queue.get(True)        info_list.append(value)    lock.release()    if len(info_list) &gt; 0:        print(&#39;{0}\n&#39;.format(info_list))def foo(q,n):    q.put(n)if __name__ == &#39;__main__&#39;:    info = []    q = Queue()    for i in range(10):        for j in range(1,i+1):                q.put(j)        p = Process(target=run,args=[q,info,i])        p.start()        p.join()</code></pre><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>1，有并发的思想，三大特性：immutable data不可变数据，first class functions函数像变量一样使用,尾递归优化：每次递归都重用stack<br>2，好处：并行，惰性求值（在使用的时候再求值），确定性<br>3，技术：map&amp;reduce,pipeline,recursing递归,currying归一化,higher order function高阶函数</p><pre><code class="python">def inc(x):    def incx(y):        return x+y    return incxinc2 = inc(2)inc5 = inc(5)print(inc2(5)) #输出7print(inc5(5)) #输出10</code></pre><p>4，lambda快速定义单行的最小函数，即inline的匿名函数</p><pre><code class="python">g = lambda x: x*2print(g(3)) # 6print(lambda x: x*2)(4) # 8</code></pre><p>5，map，filter，reduce<br>    map(function, sequence)：对sequence中的item依次执行function(item),执行结果组成一个List返回</p><pre><code class="python"># 对于这个函数for n in [&quot;qi&quot;, &quot;yue&quot;, &quot;July&quot;]:    print(len(n))#可以写成name_len = map(len, [&quot;qi&quot;, &quot;yue&quot;, &quot;July&quot;])print(name_len)</code></pre><pre><code>filter(function, sequence):对sequence中的item一次执行function(item),将执行结果为True的item组成一个List/String/Tuple(取决于sequence的类型)返回</code></pre><pre><code class="python">number_list = range(-5,5)less_than_zero = list(filter(lambda x: x&lt;0, number_list))print(less_than_zero)</code></pre><pre><code>reduce(function, sequence, starting_value):对sequence中的item顺序迭代调用function,如果有starting_value,还可以作为初始值调用</code></pre><pre><code class="python">def add(x,y):    return x+yprint reduce(add,range(1,5))# 10print reduce(add,range(1,5),10) # 20</code></pre><pre><code>例：计算数组中的平均数</code></pre><pre><code class="python">num = [2, -5, 9, 7, -2, 5, 3, 1, 0, -3, 8]true_list = list(filter(lambda x: x&gt;0, num))total = reduce(lambda x,y:x+y,true_list)average = total/len(true_list)</code></pre><h2 id="Hadoop-amp-Spark"><a href="#Hadoop-amp-Spark" class="headerlink" title="Hadoop &amp; Spark"></a>Hadoop &amp; Spark</h2><p>1，核心设计就是MapReduce和HDFS(Hadoop Distributed File System<br>2，mrjob是在Hadoop Streaming的命令行上面包了一层，有了统一的Python界面，无序直接调用复杂的Hadoop Streaming命令<br>3，Spark是基于map reduce算法实现的分布式计算框架，其中间输出和结果可是直接保存在<strong>内存</strong>中，不再需要读写HDFS<br>4，Spark能更好地用于数据挖掘与机器学习等需要<strong>迭代</strong>的map,reduce的算法<br>5，Spark的核心为弹性分布式数据集RDD(Resilient Distributed Datasets),它是一个集群节点上不可变、已分区的对象，可以序列化，可以控制存储级别（内存、磁盘等）来进行重用<br>6，用PySpark实现WordCount</p><pre><code class="python">import sysfrom operator import addfrom pyspark import SparkContextsc = SparkContext()lines = sc.textFile(&quot;stormofswords.csv&quot;)counts = lines.flatMap(lambda x: x.split(&#39;,&#39;))\            .map(lambda x: (x, 1))            .reduceByKey(add)output = counts.collect() #这个时候才开始计算output = filter(lambda x:not x[0].isnumeric(), sorted(output, key=lambda x:x[1], reverse=True))for (word,count) in output[:10]:    print(&quot;{0}:{1}&quot;.format(word, count))sc.stop()</code></pre>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python-file</title>
      <link href="/2018/08/03/python-file/"/>
      <url>/2018/08/03/python-file/</url>
      <content type="html"><![CDATA[<h2 id="文件读写操作"><a href="#文件读写操作" class="headerlink" title="文件读写操作"></a>文件读写操作</h2><h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><pre><code class="python"># 默认是只读file1 = open(&quot;test.txt&quot;)# w是全部重写，a是append到最后file2 = open(&quot;output.txt&quot;,&quot;w&quot;)while True:    line = file1.readline()    file2.write(&#39;&quot;&#39; + line + &#39;&quot;&#39; + &quot;.&quot;)    if not line:        breakfile1.close()file2.close()</code></pre><p>读文件有3种方法：<br>1，read()将文本文件所有行读到一个字符串中<br>2，readline()是一行行读<br>3，readlines()是将文本文件中所有行读到一个List中，文本文件每一行是list的一个元素。</p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>文件迭代器</p><pre><code class="python">file2 = open(&quot;output.txt&quot;,&quot;w&quot;)for line in open(&quot;test.txt&quot;):    file2.write(&#39;&quot;&#39; + line + &#39;&quot;&#39; + &quot;.&quot;)file2.close()</code></pre><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p>文件上下文管理器</p><pre><code class="python">#用with.open自带关闭文本的功能with open(&#39;somefile.txt&#39;,&#39;r&#39;) as f:    data = f.read()    for line in f:        #处理每一行</code></pre><h2 id="二进制文件读写"><a href="#二进制文件读写" class="headerlink" title="二进制文件读写"></a>二进制文件读写</h2><p>python默认读取的都是文本文件。要是想要读取二进制文件，需要把刚刚的”r”/“w”改成”rb”</p><p>任何非标准的文本文件（Python2-ASCII, Python3-unicode）你就需要用二进制读入这个文件，然后再有<code>.decode(&#39;...&#39;)</code>的方法来解码这个二进制文件</p><pre><code class="python">f = open(&#39;ABC.jpg&#39;,&#39;rb&#39;)u = f.read().decode(&#39;ABC&#39;)</code></pre>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python-oop</title>
      <link href="/2018/08/02/python-oop/"/>
      <url>/2018/08/02/python-oop/</url>
      <content type="html"><![CDATA[<h2 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h2><p>1，类中函数的第一个参数必须是self,它是为了指代它所存在的类<br>2，构造函数用<strong>init</strong>表示</p><pre><code class="python">#创建类class Foo:    name = &#39;Jan&#39;    #类里面的函数,类中第一个参数必须是self，指代本类的东西    def bar(self):        pass    def hello(self, name):        print(&#39;self name {0}&#39;.format(self.name)) #指Jan        print(&#39;I am {0}&#39;.format(name))    def __init__(self): #其职责就是在模型创建初期完成一些动作        self.name = &quot;Jan2&quot;obj=Foo()obj.bar()obj.hello(&#39;july&#39;)obj1 = Foo()obj2 = Foo()</code></pre><h2 id="访问限制"><a href="#访问限制" class="headerlink" title="访问限制"></a>访问限制</h2><p>1，直接在构造函数中用self.xx赋值会导致xx外界也能访问<br>2，<code>self.__name = name</code>,这样写就是告诉python <code>__name</code>不能被外界访问<br>3，如果既要保证安全，又要能被外部更改呢？用getter+setter<br>4，python中，如果变量名类似<code>__x__</code>,以双下划线开头和结尾的，是特殊变量，特殊变量可以直接访问，不是private变量<br>5，如果变量名是以一个下划线开头的<code>_x</code>，这样的实例变量外部是可以访问的，但是按照约定俗称的规定，这类变量<strong>虽然可以访问，但是请视为私有变量，不要随意访问</strong></p><pre><code class="python">class Student:    def __init__(self,name,age):        self.name = name #用self赋值在类中别的方法也能直接访问的到        self.age = age        self.__name = name        self.__age = age    def detail(self):        print(self.name)        print(self.age)        print(self.__name)        print(self.__age)    def get_name(self):        return self.__name    def set_name(self,name):        self.__name = nameLiLei = Student(&#39;LiLei&#39;,12)LiLei.age = 20 #外界可以更改，访问ageLilei.__age = 20 #不能被更改</code></pre><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><pre><code class="python">class PrimaryStudent(Student):    def lol(self):        print(&quot;lalalala&quot;)class CollegeStudent(Student):    #这里改写了父类的构造函数    def __init__(self,name,age,gender):        self.__name = name        self.__age = age        self.__gender = gender    def gender_detail(self):        print(self.__gender)obj1 = PrimaryStudent(&#39;向往&#39;,7)obj1.lol()obj1.detail()#继承爸爸的方法</code></pre><h2 id="python-类属性和实例属性"><a href="#python-类属性和实例属性" class="headerlink" title="python 类属性和实例属性"></a>python 类属性和实例属性</h2><pre><code class="python">class A():    a = 10# scenario1obj1 = A()obj2 = A()print(obj1.a,obj2.a,A.a)# scenario2obj1.a += 2print(obj1.a,obj2.a,A.a)# scenario3A.a += 3print(obj1.a,obj2.a,A.a)</code></pre><p>情形1的结果是：<code>10 10 10</code>；<br>情形2的结果是：<code>12 10 10</code>；<br>情形3的结果是：<code>12 13 13</code>；</p><p><strong>为什么呢？</strong><br>在python中， <code>A</code>属于类对象，<code>obj1</code>属于实例对象，从对象的角度上来说，<code>A</code>与<code>obj1</code>是两个无关的对象，但是，Python通过下面的查找树建立了对象<code>A</code>与实例对象<code>obj1</code>,<code>obj2</code>之间的关系</p><pre><code>        A        |    ---------    |        |    obj1    obj2    </code></pre><p>当调用<code>A.a</code>的时候，直接从<code>A</code>获取属性<code>a</code><br>在scenario1中调用<code>obj1.a</code>,python按照从<code>obj1</code>到<code>A</code>的顺序自下到上查找属性<code>a</code><br>注意的是<strong>在这个时候，<code>obj1</code>是没有属性<code>a</code>的</strong>，所以python到Class <code>A</code>中找，找到并返回</p><p>在scenario2中<code>obj1.a += 2</code>包含了<strong>属性获取以及属性设置</strong>两个操作<br>属性的获取和上面一样，按照查找规则进行，即这个时候找到了类<code>A</code>的属性<code>a</code><br>但是当进行属性的设置时，<strong><code>obj1</code>这个实例对象没有属性<code>a</code>，因此会自身动态添加一个属性<code>a</code></strong><br>自此，类<code>A</code>和实例<code>obj1</code>都有自己的一个属性</p><p>那么，在scenario3中，再次调用<code>obj1.a</code>的时候，按照<strong>就近原则</strong>，找到的时实例对象的<code>a</code>，所以返回12，对于<code>obj2.a</code>由于一开始没有自己的实例对象<code>a</code>,所以返回的时类<code>A</code>的<code>a</code>，也就是13</p><p>可以验证，如果手动删除<code>obj1.a</code>，那么当再次调用<code>obj1.a</code>的时候，返回的会是13</p><pre><code class="python">del obj1.aprint(obj1.a)</code></pre><h2 id="python-装饰器"><a href="#python-装饰器" class="headerlink" title="python 装饰器"></a>python 装饰器</h2><p>1，主要用于AOP<br>2，简单版，等同于<code>use_logging(foo())</code></p><pre><code class="python">def use_logging(func):    def wrapper():        logging.warn(&quot;%s is running&quot; % func.__name__)        return func()    return wrapper@use_loggingdef foo():    print(&quot;i am foo&quot;)foo()</code></pre><p>3，带业务函数参数*args,**kwargs</p><pre><code class="python">def wrapper(*args, **kwargs):        logging.warn(&quot;%s is running&quot; % func.__name__)        return func(*args, **kwargs)    return wrapper</code></pre><p>4，装饰器本身带参数<br>这种写法本质上就是把原本real_decorator这个装饰器再在外面包一层装饰器</p><pre><code class="python">def makeHtmlTag(tag,*args,**kwds):    def real_decorator(fn):        css_class = &quot; class &#39;{0}&#39;&quot;.format(kwds[&quot;css_class&quot;]) if &quot;css_class&quot; in kwds else &quot;&quot;        def wrapped(*args, **kwds):            return &quot;&lt;&quot;+tag+css_class+&quot;&gt;&quot;+fn(*args,**kwds)+&quot;&lt;/&quot;+tag+&quot;&gt;&quot;        return wrapped    return real_decorator@makeHtmlTag(tag=&quot;b&quot;, css_class=&quot;bold_css&quot;)@makeHtmlTag(tag=&quot;i&quot;, css_class=&quot;italic_css&quot;)def hello(*s,**kwds):    return &quot;hello world!{0}{1}&quot;.format(s,kwds)print(hello(&#39;spencer&#39;,&#39;shao&#39;,name=&quot;ss&quot;,surname=&quot;shao&quot;))#结果为：&lt;b class &#39;bold_css&#39;&gt;&lt;i class &#39;italic_css&#39;&gt;hello world!(&#39;spencer&#39;, &#39;shao&#39;){&#39;name&#39;: &#39;ss&#39;, &#39;surname&#39;: &#39;shao&#39;}&lt;/i&gt;&lt;/b&gt;</code></pre><p>5，类装饰器<br>注意，这里调用顺序会先是decorator的init函数，</p><pre><code class="python">class makeHtmlTagClass(object):    def __init__(self, tag, css_class=&quot;&quot;):        print(&quot;inside makeHtmlTagDecorator.__init.__()&quot;)        self._tag = tag        self._css_class = &quot; class &#39;{0}&#39;&quot;.format(css_class) if css_class != &quot;&quot; else &quot;&quot;    def __call__(self, fn):        def wrapped(*args, **kwargs):            print(&quot;inside makeHtmlTagDecorator.__call__()&quot;)            return &quot;&lt;&quot;+self._tag+self._css_class+&quot;&gt;&quot;+fn(*args,**kwargs)+&quot;&lt;/&quot;+self._tag+&quot;&gt;&quot;        return wrapped@makeHtmlTagClass(tag=&quot;b&quot;, css_class=&quot;bold_css&quot;)@makeHtmlTagClass(tag=&quot;i&quot;, css_class=&quot;italic_css&quot;)def hello(name):    return &quot;Hello, {}&quot;.format(name)print(&quot;Finished decorating hello()&quot;)print(hello(&quot;Baby&quot;))#输出结果顺序为：#inside makeHtmlTagDecorator.__init.__()#inside makeHtmlTagDecorator.__init.__()#Finished decorating hello()#inside makeHtmlTagDecorator.__call__()#inside makeHtmlTagDecorator.__call__()#&lt;b class &#39;bold_css&#39;&gt;&lt;i class &#39;italic_css&#39;&gt;Hello, Baby&lt;/i&gt;&lt;/b&gt;</code></pre><p>6，装饰器副作用<br>原本的函数变成了一个wrapper函数，所以会丢失原本函数的一些元信息，比方说<strong>name</strong>, __doc__之类<br>这个时候可以用Python的functools</p><pre><code class="python">from functools import wrapsdef hello(fn):    @wraps(fn)    def wrapper():        print(&quot;Hi,{0}&quot;.format(fn.__name__))        fn()        print(&quot;Bye,{0}&quot;.format(fn.__name__))    return wrapper@hellodef foo():    print(&quot;Foo&quot;)foo()</code></pre><h2 id="slots"><a href="#slots" class="headerlink" title="slots"></a><strong>slots</strong></h2><p>1，可以限制class实例能够添加哪些属性<br>2，__slots__只对当前类的实力起作用，对继承的子类不求作用</p><h2 id="property"><a href="#property" class="headerlink" title="property"></a>property</h2><h2 id="类的特殊方法和定制"><a href="#类的特殊方法和定制" class="headerlink" title="类的特殊方法和定制"></a>类的特殊方法和定制</h2><h3 id="str"><a href="#str" class="headerlink" title="str"></a><strong>str</strong></h3><p>1，返回用户看到的字符串<br>2，convert an object to a string<br>3，与toString()十分类似，也可以override这个方法</p><pre><code class="python">class MyClass:    def __init__(self, name):        self.name = name    def __str__(self):        return &quot;Hello&quot; + self.nameprint(MyClass(&#39;Tome&#39;)) # Hello Tome # 如果没有def __str__，则默认打印的是&lt;__main__.MyClass object at 0x109afb190&gt;</code></pre><h3 id="str-与repr"><a href="#str-与repr" class="headerlink" title="str()与repr()"></a>str()与repr()</h3><p>1，Example of str()</p><pre><code class="python">s = &#39;Hello, Geeks.&#39;print str(s)print str(2.0/11.0)</code></pre><p>output:</p><pre><code>Hello, Geeks.0.181818181818</code></pre><p>2，Example of repr()</p><pre><code class="python">s = &#39;Hello, Geeks.&#39;print repr(s)print repr(2.0/11.0)</code></pre><p>output:</p><pre><code>&#39;Hello, Geeks.&#39;0.18181818181818182</code></pre><p>3，Difference:<br>    <strong> str() is used for creating output for end users/ repr() is mainly used for debugging and development    </strong> repr() shows a representation that has all information about the object/ str() is sued to show a representation that is useful for printing the object<br>    ** Both of them can be overriden for any class and there are minor differences.If both are defined, function defined in <strong>str</strong> is used.</p><h3 id="iter"><a href="#iter" class="headerlink" title="iter"></a><strong>iter</strong></h3><p>1，如果一个类想要被用于<code>for ... in</code>循环，就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象，在<code>def __iter__(self)</code>里实力本身就是迭代对象，所以返回自己<code>self</code>即可，主要是在<code>__next__</code>里面写逻辑，知道遇到<code>StopIteration</code>错误时退出循环</p><pre><code class="python">class Fib100:    def __init__(self):        self._1, self._2 = 0, 1    def __iter__(self):        return self    def __next__(self):        self._1, self._2 = self._2, self._1 + self._2        if self._1 &gt; 100:            raise StopIteration()        return self._1for i in Fib100():    print(i)</code></pre><h3 id="getitem"><a href="#getitem" class="headerlink" title="getitem"></a><strong>getitem</strong></h3><p>1，如果想实现下标访问，就需要实现<code>__getitem__</code></p><pre><code class="python">class Fib(object):    def __getitem__(self, n):        a, b = 1, 1        for x in range(n):            a, b = b, a + b        return af = Fib()f[0]</code></pre><h3 id="call"><a href="#call" class="headerlink" title="call"></a><strong>call</strong></h3><pre><code class="python">class MyClass:    def __call__(self):        print(&quot;U can call cls() directly&quot;)cls = MyClass()cls()print(callable(cls))print(callable(max))</code></pre><h2 id="元类MetaClass"><a href="#元类MetaClass" class="headerlink" title="元类MetaClass"></a>元类MetaClass</h2><p>1，python是动态语言，是在运行时编译的<br>2，用<code>type</code>动态生成一个类,第二个参数是继承自什么，一定要显式写成元组类型</p><pre><code class="python">def init(self, name):    self.name = namedef say_hello(self):    print(&#39;Hello {0}&#39;.format(self.name))Hello = type(&#39;Hello&#39;,(object, ), dict(__init__ = init, hello = say_hello))h = Hello(&#39;Tom&#39;)h.hello()</code></pre><p>3，metaclass就是为了控制类的创建过程，就是告诉用户我这个class有哪些方法，存在attrs的表里面，attrs就是函数和方法的一个表</p><pre><code class="python">def add(self, value):    self.append(value)class ListMetaClass(type):    def __new__(cls, name, bases, attrs):        attrs[&#39;add&#39;] = add        attrs[&#39;name&#39;] = &#39;Jerry&#39;        return type.__new__(cls, name, bases, attrs)class MyList(list, metaclass = ListMetaClass):    passmli = MyList()mli.add(1)mli.add(2)print(mli.name) # Jerryprint(mli) # [1,2]</code></pre>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python-basics</title>
      <link href="/2018/07/31/python-basics/"/>
      <url>/2018/07/31/python-basics/</url>
      <content type="html"><![CDATA[<p>PYTHON 3.6</p><h2 id="字符串换行"><a href="#字符串换行" class="headerlink" title="字符串换行"></a>字符串换行</h2><p>1，字符串中末尾加”\”最终会打印出一行<br>2，字符串换行方法一加\n<br>3，字符串换行方法二用多行写法</p><pre><code class="python">str = &#39;abcd&#39; \        &#39;efgh&#39;# 结果是abcdefghprint(str)#结果是Hello#worldstr = &#39;Hello\nworld!&#39;print(str)#结果是Hello#worldstr = &quot;&quot;&quot;Helloworld!&quot;&quot;&quot;</code></pre><h2 id="单引号与双引号"><a href="#单引号与双引号" class="headerlink" title="单引号与双引号"></a>单引号与双引号</h2><p>1，单引号里可以直接写双引号<br>2，双引号里可以直接写单引号<br>3，单/双引号里面要单/双引号，则需要转义</p><a id="more"></a><pre><code class="python"># abc&quot;123&quot;efgprint(&#39;abc&quot;123&quot;efg&#39;)# abc&#39;123&#39;efgprint(&quot;abc&#39;123&#39;efg&quot;)# abc&#39;123&#39;efgprint(&#39;abc\&#39;123\&#39;efg&#39;)# abc&quot;123&quot;efgprint(&quot;abc\&quot;123\&quot;efg&quot;)</code></pre><h2 id="常见字符串处理"><a href="#常见字符串处理" class="headerlink" title="常见字符串处理"></a>常见字符串处理</h2><p>1，取出空格及特殊符号strip,lstrip,rstrip<br>2，复制字符串：str1 = str2<br>3，连接字符串<br>    str2 += str1<br>    new_str = str2 + str1<br>4，查找字符串：pos = str1.index(str2)<br>5，比较字符串：str1 == str2/str1 &lt; str2<br>6，字符串长度：len(str)<br>7，大小写转换：<br>    u_str = str.upper()<br>    l_str = str.lower()<br>8，首字母大写：str.capitalize();string.capword(str)<br>9，分割与合并字符串：split,splitlines,join<br>10，类型转换：int，float转换<br>11，格式化字符串<br>12，不能修改字符串</p><pre><code class="python">import strings = &#39;abc&#39;#报错s[0] = &#39;d&#39;#去除空格 s = &#39; abcd efg &#39; print(s.strip()) #返回的是新的字符串 print(s.lstrip()) print(s.rstrip())# 字符串的连接s1 = &#39;abc&#39;s2 = &#39;def&#39;print(s1 + &quot;\n&quot; + s2)# 位置比较s_1 = &#39;abcdefg&#39;s_2 = &#39;abdeffxx&#39;print(s_1.index(&#39;bcd&#39;)) # 1print(s_2.index(&#39;bcd&#39;)) # Exception# 空字符串 不能写成 == False，不等于None# 空字符串在内存中还是被分配了对象的# s = &#39;&#39;if not s:    print(&#39;Empty&#39;)# 字符串的分割和连接s = &#39;abc,def,ghi&#39;splitted = s.split(&#39;,&#39;)print(typeof(splitted)) #&lt;class &#39;list&#39;&gt;print(splitted)#[&#39;abc&#39;,&#39;def&#39;,&#39;ghi&#39;]s=&quot;&quot;&quot;abcdefghi&quot;&quot;&quot;s_1 = s.splitted(&#39;\n&#39;)s_2 = s.splitlines()print(s_1)print(s_2)# 字符串的连接s = [&#39;abc&#39;,&#39;def&#39;,&#39;ghi&#39;]print(&#39;&#39;.join(s))print(&#39;-&#39;.join(s)) # abc-def-ghi#常用判断print(&#39;1234abcd&#39;.isalnum())print(&#39;\t12ab&#39;.isalnum())#Falseprint(&#39;abcd&#39;.isalpha())print(&#39;12345&#39;.isdigit())print(&#39;  &#39;.isspace())#数字到字符串print(str(5))print(str(5.))print(str(5.12345))#字符串到数字print(int(&#39;1234&#39;))print(float(&#39;1234.56&#39;))print((int(&#39;ffff&#39;,16)) #16进制的ffff转成10进制</code></pre><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><pre><code class="python"># None的判断x = Noneif not x:    print(&#39;None&#39;)else:    print(&#39;Not None&#39;)if x is None:    print(&#39;None&#39;)# forfor i in range(start,end,step):    print(i)  </code></pre><h2 id="AND-OR"><a href="#AND-OR" class="headerlink" title="AND/OR"></a>AND/OR</h2><p>1，AND/OR<strong>不一定只会返回True/False</strong><br>2，<strong>AND</strong> return the first Falsey value if there are any, else return the last value in the expression<br>3，<strong>OR</strong> return the first Truthy value if there are any, else return the last value in the expression</p><pre><code class="python">[] and [] + [1,2] # returns []#Spotted,[] and [] + [1,2] is actually this: [] and ([] + [1,2]),你必须把后面的+[1,2]与前面的[]看作是一个整体[] + [1,2] # returns [1,2]10 or 7 - 2 # returns 10,同理，10 or (7 - 2)要看成这种形式</code></pre><h2 id="循环for-else"><a href="#循环for-else" class="headerlink" title="循环for/else"></a>循环for/else</h2><p><span style="color: red"><code>for</code> loop也有一个<code>else</code></span><br><code>else</code> 是在loop正常结束后执行的，也就是说这个loop没有<code>break</code></p><p>下面这个是一个基本的</p><pre><code class="python">for item in container:    if search_something(item):        #Found it!        process(item)        break    else:        #Didn&#39;t find anything        not_found_in_container()</code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre><code class="python">#默认参数def func(x,y = 500):    return x+yprint(func(100)) # 600def func(p):    print(&#39;x=&#39;,p[&#39;x&#39;])    print(&#39;y=&#39;,p[&#39;y&#39;])print(func({&#39;x&#39;:100,&#39;y&#39;:200}))#可变参数，*告诉pytnhon后面都放到这个numbers数组#这样写有一个问题，你传进去的可变tuple每个元素是没有名字的，你除非知道他们的索引才能用def func(name,*numbers):    print(numbers[0])    print(numbers[3])    print(type(numbers)) #Tuple# tuple = 只读数组func(&#39;tom&#39;,1,2,3,4,&quot;Hello&quot;)#可变参数方法二, **代表key/values的字典def func(name,**kvs):    print(type(kvs)) #&lt;class &#39;dict&#39;&gt;    print(kvs)#{&#39;uk&#39;:&#39;London&#39;,&#39;china&#39;:&#39;Beijing&#39;}func(&#39;Tom&#39;,china=&quot;Beijing&quot;,uk=&quot;London&quot;)def func(a,b,c,*,china,uk):    print(china,uk)func(1,2,3,china=&#39;BJ&#39;,uk=&#39;LD&#39;)# 函数可以作为参数def sum(x,y,p=None):    s = x+y    if p:        p(s)    return ssum(100,200,print)</code></pre><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><strong>经常会碰到这样的错误：<br>local variable ‘a’ referenced before assignment</strong></p><pre><code class="python">a = 3def func():    print(a)    a = a+1 #这一句会报错func()</code></pre><p><span style="color: red">a=3定义了全局变量a，作用域从定义处到代码结束，在a=3以下的函数中是可以引用全局变量a的，但是如果要修改函数中与全局变量同名的变量，在函数中的该变量就会变成局部变量，在修改之前对该变量的引用就会引发为定义的错误,<strong>所以，哪个函数需要修改全局变量，就需要在这个函数中声明一下，但是有一个函数不需要声明，就是主函数</strong></span></p><pre><code class="c#">a = 3def func():    global a    print(a)    a = a+1 #这一句会报错func()if __name__ == &quot;__main__&quot;:    print (a)  # 2    a = a + 1    Fuc()    print (a)  # 3</code></pre><p>##<strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong>练习<strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></p><p>1，求100以内的素数</p><pre><code class="python">#找素数,1不是素数，最小的质数/素数为2#素数的概念，除了1和它本身外，不能被其他自然数整除def findPrimeNumber(num):    for i in range(1,num+1):        if i &gt; 1:            for j in range(2,i):                if i%j == 0:                    break            else:                 print(i)findPrimeNumber(100)</code></pre><p>2，冒泡排序</p><pre><code class="python">#冒泡排序def bubbleSort(array):    for i in range(len(array)-1,0,-1):        for j in range(i):            if array[j] &gt; array[j+1]:                temp = array[j]                array[j] = array[j+1]                array[j+1] = temp        print(array)bubbleSort([54,26,100,17,77])</code></pre><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>1，list列表，索引从0开始，列表的数据项不需要具有相同的类型<br>2，tuple元组，只读列表<br>3，dist字典<br>4，set集合，是一个无序不重复的数组</p><p>5，not XX 和 is None不是一回事，not XX代表其还是在内存分配空间了的<br>6，切片，切出一个子数组<br>7，生成器，只有用到的时候才去计算，不用的时候不算,用next/for来循环,非常省内存<br>8，迭代器，如果是Iterable,则可以用for来循环，如果是Iterator则说明是生成器</p><pre><code class="python">#list/tuple基本操作li = [1,2,3,&#39;tete&#39;,[1,2,3],{1:&#39;one&#39;,2:&#39;two&#39;}]print(type(li))# class list# 元素访问print(li[0])#倒数第一个元素print(li[-1])# 查找元素位置print(li.index(&#39;tete&#39;)) #3print(li.index([1,2,3])) #4print(li.index(-1)) # error# 添加元素l_a = [1,2]l_a.append(4)l_a.append(5)#如果想要一次性加多个元素进去，就需要用extend,否则如果用append，会把其作为一个list，添加到原list中l_b = [6,7,8]l_a.extend(l_b)# 删除元素del(li[-1]) # del(list[index])# 判断容器是否为空l_a = []if not l_a:    print(&#39;Empty&#39;) # print thisif l_a is None:    print(&#39;None&#39;)# 遍历for i in li:    print(i)for i in range(len(li)):    print(li[i])# 元组t = (1,2,3,&#39;456&#39;)t[0]=&#39;a&#39; # error,不可以修改# 字典d = {&#39;a&#39;:1,&#39;b&#39;:2,1:&#39;one&#39;,2:&#39;two&#39;}print(d[1]) #根据key来做访问# 判断元素是否存在，是判断key是否存在print(&#39;c&#39; in d) # falseprint(1 in d) # true# 添加# 删除del(d[2])# 遍历for key in d:    print(d[key])for key, value in d.items():    print(key,value)keys = d.keys()print(keys)# sets_a = set([1,2,2,3,4,5,6])s_b = set([4,5,6,7,8])print(s_a)# {1,2,3,4,5,6}# 判断元素是否存在print(5 in s_a)# 并集print(s_a | s_b) #{1，2，3，4，5，6，7，8}print(s_a.union(s_b))# 交集print(s_a &amp; s_b)print(s_a.intersection(s_b)) #生成一个新的set {4，5，6}# 差集(a - a&amp;b )pprint(s_a - s_b)print(s_a.difference(s_b)) #{1,2,3}# 对称差(A|B) - (A&amp;B)，把两个集合相同的元素去除print(s_a ^ s_b)print(s_a.symmetric_diff(s_b)) #{1,2,3,7,8}# 添加s_a.add(&#39;x&#39;)s_a.update([4,5,60,70])# 删除，因为set没有索引，要直接删值s_a.remove(70)# 遍历for i in s_a:    print i# 切片[start:end:step] &gt;= start * &lt; endli = list(range(10)) #[0,1,2,3,4,5,6,7,8,9]print(li[2:5]) # [3,4,5]print(li[:4]) # [0,1,2,3]print(li[0:10:3])#[0,3,6,9]print(li[5:-2])#[5,6,7]print(li[9:0:-1])#[9,8,7,6,5,4,3,2,1]print(li[9::-1])#[9,8,7,6,5,4,3,2,1,0]# 列表推导#生成10个偶数li = [i*2 for i in range(10)]#二维数组浅拷贝li_2d = [[0]*3]*3print(li_2d)li_2d[0][0] = 100print(li_2d)#这样写会每个元素的首元素变成100，因为*3这样写是浅拷贝，每个引用的是同一个空间#二维数组深拷贝li_2d = [[0]*3 for i in range(3)]li_2d[0][0] = 100s = {x for x in range(10) if x%2 == 0}print(s) #s=setd = {x:x%2 == 0 for x in range(10)}print(d)#d=dict# 生成器square_generator = (x*x for x in range(50000))print(next(square_generator))for i in range(10):    print(next(square_generator))# 迭代器from collections import Iterablefrom collections import Iteratorprint(isinstance([1,2,3],Iterable)) #trueprint(isinstance([1,2,3],Iterator)) #falseprint(isinstance({},Iterable))#true#</code></pre><p>##<strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong>练习<strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></p><pre><code class="python">#任意给定一个值，在一个数组中找到两个数，相加=给定值，返回这两个数的索引，如果没有，返回-1def find_two_sums(ls, target):    for i in range(len(ls) - 1):        for j in range(i+1, len(ls)):            if ls[i] + ls[j] == target:                return i, j    return -1, -1print(find_two_sums([1, 3, 2, 6, 18, 4, 2], 3))#螺旋矩阵，给定一个m*n要素的矩阵，按照螺旋顺序，返回该矩阵的所有要素#方法一，我自己写的一个笨方法，只用到上面学的内容，应该是符合所有常识人理解matrix2 = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]def myspiralmatrix(matrix):    if len(matrix) &lt; 1:        return []    #宽    m = len(matrix[0])    #长    n = len(matrix)    matrix3 = matrix    ls = []    #以横着读一批+竖着第一批作为一批，最多只有可能走m/n遍就能遍历完    if m &gt;= n:        t = n    else:        t = m    for tt in range(1, t + 1):        # 如果是奇数次遍历，那么就是顺时针读        if tt % 2 != 0:            #横：读出matrix第一个元素的所有值            ls.extend(matrix3[0][:m])            #竖：除了matrix第一个元素之外，遍历剩下n-1个元素，只读出来第m-1个            for k in range(1, n):                ls.append(matrix3[k][m - 1])            #重置数组，将下回要遍历的数组宽，长都-1，重新生成新的数组            m = m - 1            n = n - 1            tmp = matrix3            matrix3 = []            for em in range(1, n + 1):                matrix3.append(tmp[em][:m])        # 如果是偶数次遍历，那么就是逆时针读                else:            # 逆序打印这个时候matrix的最后一行            ls.extend(matrix3[n - 1][m::-1])            # 逆序竖着打印除了最后一行元素之后的所有元素的第一个元素            for i in range(n - 1, 0, -1):                ls.append(matrix3[i - 1][0])            #重置数组，将下回要遍历的数组宽，长都-1，重新生成数组            m = m - 1            n = n - 1            tmp = matrix3            matrix3 = []            for em in range(0, n):                matrix3.append(tmp[em][1:])    return lsprint(mySpiralOrder(matrix2))#方法二，LeetCode上面某个大神的写法：# 这里第一个matrix and是为了保证当所有元素都pop掉后，会返回一个空matrix,不会再做后面的pop和递归操作# matrix.pop()的操作是直接改在matrix上的，所以后面的递归是基于新的matrix上面# 后面的递归spiralOrder([*zip(*matrix)][::-1])生成的是一个剔除原先第一行元素后逆序的matrixdef spiralOrder(matrix):    return matrix and [*matrix.pop(0)] + spiralOrder([*zip(*matrix)][::-1])#用栈实现队列：支持push(element),pop()和top()方法。pop和top都应该返回第一个元素的值# 矩阵转换，给定矩阵A，令矩阵B里每个元素B[i][j]的值等于A[0][0]到A[i][j]子矩阵元素的和# 解： 除了第一行和第一列，其余B矩阵里面所有的元素都可以表示为# B[i][j] = B[i][j-1] + B[i-1][j] - B[i-1][j-1] + A[i][j]def matrixTransform(A):    B = A    for i in range(1,len(A[0])):        B[0][i] += B[0][i-1]    for i in range(1,len(A),1):        B[i][0] += B[i-1][0]    for i in range(1,len(A),1):        for j in range(1, len(A[0]), 1):            B[i][j] += B[i-1][j] + B[i][j-1] - B[i-1][j-1]    return B</code></pre><h2 id="容器补充知识点"><a href="#容器补充知识点" class="headerlink" title="容器补充知识点"></a>容器补充知识点</h2><p>1，<code>*list</code>的含义， <code>*</code> operator unpacks an argument list. It allows you to call a function with the list items as individual arguments.<br>    For instance, if <code>sys.argv</code> is [“./foo”, “bar”, “quux”], <code>main(*sys.argv)</code> = <code>main(&quot;./foo&quot;,&quot;bar&quot;,&quot;quux&quot;)</code><br>2，<code>zip</code> takes <code>n</code> number of iterables and returns list of tuples. <code>ith</code> element of the tuple is created using the <code>ith</code> element from each of the iterables.</p><pre><code class="python">list_a = [1, 2, 3]list_b = [4, 5, 6]zipped = zip(a, b) # Output: Zip Object. &lt;zip at 0x4c10a30&gt;len(zipped) # TypeError: object of type &#39;zip&#39; has no len()zipped[0] # TypeError: &#39;zip&#39; object is not subscriptablelist_c = list(zipped) #Output: [(1, 4), (2, 5), (3, 6)]list_d = list(zipped) # Output []... Output is empty list becuase by the above statement zip got exhausted.</code></pre><pre><code class="python">matrix2 = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]print(*matrix2) # [1, 2, 3, 4] [5, 6, 7, 8] [9, 10, 11, 12] 这里不是一个list，是三个list对象print([*zip(matrix2)]) #[([1, 2, 3, 4],), ([5, 6, 7, 8],), ([9, 10, 11, 12],)]print([*zip(list(matrix2))]) #[([1, 2, 3, 4],), ([5, 6, 7, 8],), ([9, 10, 11, 12],)] 与上面相同，因为list(matrix2)还是只有一个对象print([zip(*matrix2)]) # [&lt;zip object at 0x00935350&gt;]print([*zip(*matrix2)]) #[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]</code></pre>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>net-design-pattern</title>
      <link href="/2018/07/26/net-design-pattern/"/>
      <url>/2018/07/26/net-design-pattern/</url>
      <content type="html"><![CDATA[<h2 id="依赖倒置原则：怎么抽象"><a href="#依赖倒置原则：怎么抽象" class="headerlink" title="依赖倒置原则：怎么抽象"></a>依赖倒置原则：怎么抽象</h2><p>1，上层和下层中间应该通过一个抽象层进行工作，抽象是稳定的，实现是多变的！所以定义抽象要谨慎<br>2，每一层模块应该都要有抽象，有一个类cls,就要有一个ICls<br>3，调用者左边为抽象，右边为具体实现</p><pre><code class="c#">//caller{    AbstractPhone phone = new iPhone();    phone.Call();}{    AbstractPhone phone = new Lumia();    phone.Call();}//中间层，就相当于定义的一个规范public abstract class AbstractPhone{    public int Id {get;set;}    public string Branch {get;set;}    public abstract void Call();}//下层实现层public class iPhone:AbstractPhone{    public override void Call()    {        Console.WriteLine(&quot;This is iPhone calling!&quot;)    }}public class Lumia:AbstractPhone{    public override void Call()    {        Console.WriteLine(&quot;This is Lumia calling!&quot;);    }}</code></pre><a id="more"></a><p>其实中间层也可以写成一个泛型</p><pre><code class="c#">public void Call&lt;T&gt;(T phone) where T : AbstractPhone{    Console.WriteLine(&quot;This is {0} calling&quot;, phone.Name);}</code></pre><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>划分接口的时候，首先不能大而全，也不能太碎，要按照一定的规则进行分组</p><h2 id="设计模式-创建型设计模式，关注对象的创建"><a href="#设计模式-创建型设计模式，关注对象的创建" class="headerlink" title="设计模式-创建型设计模式，关注对象的创建"></a>设计模式-创建型设计模式，关注对象的创建</h2><h3 id="单例模式，就是保证类型只有一个实例，减少初始化的消耗"><a href="#单例模式，就是保证类型只有一个实例，减少初始化的消耗" class="headerlink" title="单例模式，就是保证类型只有一个实例，减少初始化的消耗"></a>单例模式，就是保证类型只有一个实例，减少初始化的消耗</h3><p>局限：<br>1，实例会常驻内存<br>2，实例中的变量，在多线程的情况下会被影响</p><p>使用场景：数据库连接池</p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>1，构造函数私有化，保证不会被外部创建<br>2，对外提供一个公开方法提供这个对象<br>3，实例定义成一个静态变量，保证内存中就只有一个<br>4，注意了，如果class Singleton变成class Singleton<t>,就无法保证实例是单例的，因为解释器会在编译的时候动态生成类型</t></p><pre><code class="c#">public class Singleton{    private Singleton()    {    }    //volatile保证多线程的时候值不会被多次修改    private static volatile Singleton _singleton = null;    private static object Singleton_Lock = new object();    public static Singleton CreateInstance()    {        if(_singleton == null)            _singleton = new Singleton();        return _singleton;    }}</code></pre><p>如果多线程同时调用上面的CreateInstance，就无法保证只构造一次(假设一个构造函数要构造40s)，所以需要加一层Lock</p><p>但是只加一次lock也不行，因为如果第二轮开5个线程让构造Singleton,则会发现第二轮的也在等待锁，而这个时候明明已经Singleton实例化好了的</p><p>所以在lock外面会再加上一层if判断</p><p><strong>经典的双if-lock:</strong></p><pre><code class="c#">public static Singleton CreateInstance(){    if(_singleton is null)//保证对象初始化之后，不会再去等待锁    {        lock(Singleton_Lock)//保证只有一个线程进去        {            Thread.Sleep(1000);            Console.WriteLine(&quot;这里等待了1s的锁&quot;);            if(_singleton == null)//保证只会被实例化一次                _singleton = new Singleton();        }    }    return _singleton;}</code></pre><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>1，通过静态构造函数来返回实例,是由CLR来保证程序第一次使用这个类型前被调用且只调用一次</p><pre><code class="c#">public class SingletonSecond{    private static volatile SingletonSecond _singletonSecond = null;    static SingletonSecond()    {        _singletonSecond = new SingletonSecond();        Console.WriteLine(&quot;SingletonSecond starts&quot;).    }}</code></pre><h4 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h4><p>1，使用静态字段，在第一次使用这个类之前，也是由CLR保证的，初始化且只初始化一次</p><pre><code class="c#">public class SingletonThird{    private SingletonThird()    {    }    private static SingletonThird _singletonThird = new SingletonThird();    public static SingletonThird CreateInstance()    {        return _singletonThird;    }}</code></pre><h3 id="原型模式-解决对象重复创建的问题"><a href="#原型模式-解决对象重复创建的问题" class="headerlink" title="原型模式,解决对象重复创建的问题"></a>原型模式,解决对象重复创建的问题</h3><p>局限：<br>1，常驻内存<br>2，多线程的话，会在内存中创建多个实例，即使这个实例跟第一次创建的实例是一样的</p><p>1，通过MemberwiseClone来clone新对象，避免重复创建对象<br>2，每次Clone的时候都是以第一次SingletonSecond静态构造函数构造的来copy，所以每次返回的是新的对象</p><pre><code class="c#">public static SingletonSecond CreateInstancePrototype(){    SingletonSecond sp = (SingletonSecond)_singletonPrototype.MemberwiseClone();    return sp;}</code></pre><h3 id="三大工厂-建造者模式"><a href="#三大工厂-建造者模式" class="headerlink" title="三大工厂+建造者模式"></a>三大工厂+建造者模式</h3><h4 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h4><p>局限：<br>1，细节没有消失，只是转移，并且矛盾都集中在了一个地方</p><pre><code class="c#">{    //不好，左右两边都是具体实现    Human human = new Human();    player.PlayWar3(human);}{    //好，左边是抽象，右边是细节    IRace human = new Human();    player.PlayWar3(human);}{    //如何把右边也替换掉？简单工厂模式,就是帮忙完成对象的创建    IRace human  = ObjectFactory.CreateRace(RaceType.Human);    player.PlayWar3(human);}public static IRace CreateRace(RaceType raceType){    IRace iRace = null;    switch(raceType)    {        case RaceType.Human:            iRace = new Human();            break;        case RaceType.Undead:            iRace = new Undead();            break;        default:            throw new Exception(&quot;Wrong race!&quot;);    }    return iRace;}//简单工厂的升级，用反射//这样写程序里面完全没有细节，细节都在config文件里面private static string IRaceTypeConfigReflection = ConfigurationManager.AppSettings[&quot;IRaceTypeConfigReflection&quot;];private static string DllName = IRaceTypeConfigReflection.Split(&#39;,&#39;)[1];private static string TypeName = IRaceTypeConfigReflection.Split(&#39;,&#39;)[0];///IOC的雏形public static IRace CreateRaceConfigReflection(){    Assembly assembly = Assembly.Load(DllName);    Type type = assembly.GetType(TypeName);    IRace iRace = Activator.CreateInstance(type) as IRace;    return iRace;}</code></pre><h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><p>1，将职责单一化，一个工厂只负责一种实例的创建<br>2，创建的工厂作为一个中间层，把细节包了一层<br>3，这样写方便扩展,可以增加新的行为</p><pre><code class="c#">{    IFactory factory = new HumanFactory();    //IFactory factory = new HumanFactoryAdvanced();    IRace race = factory.CreateRace();}public class HumanFactory: IFactory{    public virtual IRace CreateRace()    {        return new Human();    }}//这样写方便扩展,可以增加新的行为public class HumanFactoryAdvanced:HumanFactory{    public override IRace CreateRace()    {        Console.WriteLine(&quot;This is an extension.&quot;);        return new Human();    }}</code></pre><h4 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h4><p>1，从外表来说是一个工厂去创建多个对象<br>2，适用于工厂里面的对象都紧密相连</p><pre><code class="c#">public class HumanFactory:FactoryAbstract{    public override IRace CreateRace()    {        return new Human();    }    public override IArmy CreateArmy()    {        return new HumanArmy();    }    public override IHero CreateHero()    {        return new HumanHero();    }}public abstract class FactoryAbstract{    public abstract IRace CreateRace();    public abstract IArmy CreateArmy();    public abstract IHero CreateHero();}//caller{    FactoryAbstract humanFactory = new HumanFactory();    IRace race = humanFactory.CreateRace();    IArmy army = humanFactory.CreateArmy();    IHero hero = humanFactory.CreateHero();}</code></pre><p><strong>经验之谈：在创建一个对象的时候，尽量不要直接去创建这个对象，而是通过一个中间层，这样细节的变化只会波及到工厂，只改工厂的就好，不会波及到上层</strong></p><h2 id="设计模式-结构型设计模式：关注类与类之间的关系"><a href="#设计模式-结构型设计模式：关注类与类之间的关系" class="headerlink" title="设计模式-结构型设计模式：关注类与类之间的关系"></a>设计模式-结构型设计模式：关注类与类之间的关系</h2><p>纵向可以：继承–实现<br>横向可以：聚合，组合，关联，依赖（是指在方法里用了别的类）<br>核心：组合优于继承</p><h3 id="适配器模式Adapter"><a href="#适配器模式Adapter" class="headerlink" title="适配器模式Adapter"></a>适配器模式Adapter</h3><p>是在项目重构升级的时候会用，之前的方法已经都稳固了，但是这个时候想要用第三方的方法，就把第三方的方法与我们的方法适配一下</p><p>比方说我们之前定义了一个IHelper,里面定义了增删改查四个方法，并且已经有了MySqlHelper,OracleHelper</p><p>这个时候我们想要用一个第三方软件提供的RedisUtility,这里面也定义了自己增删改查方法，但是第三方是不可能继承于我们的类IHelper的，这个时候我们就需要写一个适配方法</p><h4 id="方法一：纵向"><a href="#方法一：纵向" class="headerlink" title="方法一：纵向"></a>方法一：纵向</h4><p>问题：侵入性很强<br>因为通过了继承，我多出了很多功能，我其实只需要IHelper的增删改查就好，但是这个时候我还拥有了RedisUtility里面的AddRedis之类的方法。并且如果RedisUtility什么时候也增加了Add方法，那么我们现在的方法就要改</p><pre><code class="c#">public class RedisHelperClass: RedisUtility, IHelper{    public void Add&lt;T&gt;()    {        base.AddRedis&lt;T&gt;();    }    public void Delete&lt;T&gt;()    {        base.DeleteRedis&lt;T&gt;();    }    public void Update&lt;T&gt;()    {        base.UpdateRedis&lt;T&gt;();    }    public void Query&lt;T&gt;()    {        base.QueryRedis&lt;T&gt;();    }}//caller{    IHelper helper = new RedisHelperClass();    helper.Add&lt;Program&gt;();}</code></pre><h4 id="方法二：组合"><a href="#方法二：组合" class="headerlink" title="方法二：组合"></a>方法二：组合</h4><p>另一种写法是组合，在类的内部内置了需要类的属性，字段</p><p>组合的写法就比较灵活，不仅类里面可以有redisHelper，如果将来想要有Cache也可以直接加上去</p><pre><code class="c#">public class RedisHelperObject: IHelper{    private RedisUtility _redisHelper = null;    public RedisHelperObject(RedisUtility redisHelper)//这里可能是一个抽象的接口注入进来    {        this._redisHelper = redisHelper;    }    public RedisHelperObject()    {        this._redisHelper = new RedisUtility();    }    public void Add&lt;T&gt;()    {        this._redisHelper.AddRedis&lt;T&gt;();    }    public void Delete&lt;T&gt;()    {        this._redisHelper.DeleteRedis&lt;T&gt;();    }    //...}</code></pre><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>1，有一个真实的做事情的类<br>2，有一个接口<br>3，有一个代理的类，这个类继承于接口，也有方法的实现，但是到真正的实现是调用真实类来实现<br>4，代理只能传达原有逻辑，不能新增业务逻辑，就是包一层<br>5，真正调用的时候不再调用RealSubject，而是调用ProxySubject<br>6，这种模式可以让用户在真正使用的时候才去创建对象(DoSomething方法)。因为我在用的时候是调用的ProxySubject，这个构建不消耗资源</p><pre><code class="c#">public class ProxySubject: ISubject{    //这个是单例代理    private static ISubject _iSubject = null;    private void Init()    {        _iSubject = new RealSubject();    }    //下面这个是缓存代理    private static bool _booleanResult = false;    private static bool _isInit = false;    private static Dictionary&lt;string,bool&gt; _cache=new Dictionary&lt;string,bool&gt;();    public bool GetSomething()    {        if(!_isInit)//缓存        {            _booleanResult = _iSubject.GetSomething();            _isInit = true;        }        return _booleanResult;    }    //这个是延迟代理，延迟构建RealSubject    public void DoSomething()    {        if(_iSubject == null)        {            this.Init();        }        _iSubject.DoSomething();    }}</code></pre><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>1，声明一个你需要用的变量<br>2，在构造函数中把你需要的变量初始化</p><pre><code class="c#">public class BaseStudentDecorator: AbstractStudent{    //用的是组合的方式，通过构造函数初始化变量    private AbstractStudent _student = null;    public BaseStudentDecorator(AbstractStudent student)    {        this._student = student;    }    public override void Study()    {        this._student.Study();    }}public class StudentPayDecorator: BaseStudentDecorator{    public StudentPayDecorator(AbstractStudent student)    :base(student)    {    }    public override void Study()    {        Console.WriteLine(&quot;Pay&quot;);        base.Study();    }}//caller{    AbstractStudent student = new StudentVip()    {        Id = 381,        Name = &quot;Bird&quot;    };    //BaseStudentDecorator decorator = new BaseStudentDecorator();    //把左边BaseStudentDecorator换成AbstractDecorator    //AbstractStudent decorator = new BaseStudentDecorator();    //decorator.Study();    student = new BaseStudentDecorator(student);    student.Study();//输出的是vip学习    //StudentPayDecorator studentPayDecorator = new StudentPayDecorator(decorator);    //AbstractStudent studentPayDecorator = new StudentPayDecorator(decorator);    //studentPayDecorator.Study();    //也可以写成如下，这个时候的student为BaseStudentDecorator    student = new StudentPayDecorator(student);    student.Study();//输出先是pay，然后BaseStudentDecorator的Study,即输出vip学习    //所以之后如果你想给一个对象加一些行为，都可以像这样写    //AOP的雏形    student = new BaseStudentDecorator(student);    student = new StudentRegDecorator(student);    student = new StudentPayDecorator(student);    //最终打出来的是付费，注册，vip学习    student.Study();}</code></pre><h2 id="设计模式-行为型设计模式：关注对象和行为的分离"><a href="#设计模式-行为型设计模式：关注对象和行为的分离" class="headerlink" title="设计模式-行为型设计模式：关注对象和行为的分离"></a>设计模式-行为型设计模式：关注对象和行为的分离</h2><p>通俗来讲，就是把方法写在哪里更适合<br>哪里变化 就封装哪里，让别人传进来，自己不去完成</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><pre><code class="c#">private List&lt;IObserver&gt; _observerList = new List&lt;IObserver&gt;();public void Add(IObserver observer){    this._observerList.Add(observer);}public void Remove(IObserver observer){    this._observerList.Remove(observer);}public void MiaoObserver(){    foreach(var observer in this._observerList)    {        observer.Action();    }}//上面这就类似于event,event就是委托的一个实例public event Action MiaoHandler;public void MiaoEvent(){    if(MiaoHandler != null)    {        foreach(Action item in this.MiaoHandler.GetInvocationList())        {            item.Invoke();        }        //this.MiaoHandler();    }}</code></pre><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>1，行为型设计模式经常会有这种Context类，用来表示上下文.因为行为经常是各种类乱跑的<br>2，下一个审批人不是由当前类来指定的，而是由调用者来指定的，所以当前类就不需要承担指定下一个类的</p><pre><code class="c#">public class ApplyContext{    public int Id {get;set;}    public string Name {get;set;}    public int Hour {get;set;}    public string Description {get;set;}    public bool AuditResult{get;set;}    public string AuditRemark {get;set;}}public abstract class BaseAuditor{    protected BaseAuditor _nextAuditor {get;private set;}    public void SetNext(BaseAuditor nextAuditor)    {        this._nextAuditor = nextAuditor;    }    protected void AuditNext(ApplyContext context)    {        if(this._nextAuditor == null)        {            context.AuditResult = false;            context.AuditRemark = &quot;Denied!&quot;;        }        else        {            this._nextAuditor.Audit(context);        }    }    public string Name {get;set;}    public abstract void Audit(ApplyContext context);}public class PM : BaseAuditor{    public override void Audit(ApplyContext context)    {        context.AuditRemark += &quot;PM process...&quot;;        if(context.Hour &lt;= 8)        {            context.AuditResult = true;            context.AuditRemark = &quot;Enjoy!&quot;;        }        else        {            base.AuditNext(context);        }    }}public class AuditManager{    private static BaseAuditor AuditProcess = null;    static AuditorManager()    {        //甚至这一部分都可以改成简单工厂，用配置文件构建链表结构        PM pm = new PM()        {            Name = &quot;aa&quot;        };        Charge charge = new Charge()        {            Name = &quot;bb&quot;        };        Manager manager = new Manager()        {            Name = &quot;cc&quot;        };        pm.SetNext(charge);        charge.SetNext(manager);        AuditProcess = pm;    }    public static BaseAuditor GetAuditor()    {        return AuditProcess;    }}//caller{    //这一步还可以进一步封装，用一个类专门来返回process    PM pm = new PM()    {        Name = &quot;aa&quot;    };    Charge charge = new Charge()    {        Name = &quot;bb&quot;    };    Manager manager = new Manager()    {        Name = &quot;cc&quot;    };    pm.SetNext(charge);    charge.SetNext(manager);    pm.Audit(context);    //用专门的类来初始化，将对对象的依赖降到最低    BaseAuditor auditor = AuditorManager.GetAuditor();    auditor.Audit(context);}</code></pre>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>net-thread</title>
      <link href="/2018/07/22/net-thread/"/>
      <url>/2018/07/22/net-thread/</url>
      <content type="html"><![CDATA[<h2 id="Thread-NET-1-0-Basic"><a href="#Thread-NET-1-0-Basic" class="headerlink" title="Thread (.NET 1.0) Basic"></a>Thread (.NET 1.0) Basic</h2><p>1，    前台线程thread.Start();进程退出后还会继续执行，直到执行结束。且前台线程只有这种形式，后面的ThreadPool,Async都是后台线程<br>2，    后台线程thread.IsBackground=true;进程退出后还会继续执行，直到执行结束。</p><pre><code class="c#">private void btnThreads_Click(object sender, EventArgs e){    Console.WriteLine($&quot;*************btnThreads_Click Start {Thread.CurrentThread.ManagedThreadId.ToString(&quot;00&quot;)}&quot;);    ThreadStart threadStart = new ThreadStart(()=&gt;        {            Thread.Sleep(5000);            this.DoSomething(&quot;btnThreads_Click&quot;);        });    Thread thread = new Thread(threadStart);    thread.IsBackground=true;//这样就会改成后台线程，这样进程退出后，线程也会一起推出    thread.Start();//默认是前台线程，进程退出后还会继续执行，直到执行结束。    //thread.Join();//做等待用的，执行thread的这个线程会等待thread线程}</code></pre><a id="more"></a><h3 id="用Thread实现回调且不卡界面"><a href="#用Thread实现回调且不卡界面" class="headerlink" title="用Thread实现回调且不卡界面"></a>用Thread实现回调且不卡界面</h3><p>等同于BeginInvoke的回调</p><pre><code class="c#">private void ThreadWithCallBack(ThreadStart threadStart, Action act){    ThreadStart startNew = new ThreadStart(            ()=&gt;{                threadStart.Invoke();                act.Invoke();            }        );    Thread thread = new Thread(startNew);    thread.Start();}</code></pre><h3 id="Thread实现带返回值的且不卡界面"><a href="#Thread实现带返回值的且不卡界面" class="headerlink" title="Thread实现带返回值的且不卡界面"></a>Thread实现带返回值的且不卡界面</h3><pre><code class="c#">private void ThreadWithReturn&lt;T&gt;(Func&lt;T&gt; funcT){    T t = default(T);    ThreadStart startNew = new ThreadStart(            () = &gt;            {                t = funcT.Invoke();            });    Thread thread = new Thread(startNew);    thread.Start();    //因为只有在计算委托的时候才会线程等待，所以返回的时候要包一个委托    return new Func&lt;T&gt;(()=&gt;    {        thread.Join();        return t;    });}</code></pre><h2 id="ThreadPool-NET-2-0"><a href="#ThreadPool-NET-2-0" class="headerlink" title="ThreadPool(.NET 2.0)"></a>ThreadPool(.NET 2.0)</h2><p>ThreadPool的特点：<br>1，减少了线程创建/销毁的工作<br>2，可以限制线程的数量</p><h3 id="带回调的ThreadPool"><a href="#带回调的ThreadPool" class="headerlink" title="带回调的ThreadPool"></a>带回调的ThreadPool</h3><pre><code class="c#">ThreadPool.QueueUserWorkItem(    o =&gt; {        new Action(            ()=&gt;{                Thread.Sleep(5000);                this.DoSomethingLong(&quot;btnThreads_Click&quot;);            }).Invoke();        //Callback        Console.WriteLine(&quot;This is a callback func.&quot;);    });</code></pre><h3 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h3><p>Notice!没有需求，就不要等待，容易阻塞线程</p><pre><code class="c#">//这个就是用作标志，如果这个标志是false，那么主线程就会一直等待,除非在子线程里面设置mre.Set()ManualResetEvent mre = new ManualResetEvent(false);//false代表关闭ThreadPool.QueueUserWorkItem(    o =&gt; {        Thread.Sleep(5000);        this.DoSomethingLong(&quot;btnThreads_Click&quot;);        Console.WriteLine(o.ToString());        mre.Set();//打开    },&quot;backbone&quot;);Console.WriteLine(&quot;before WaitOne&quot;);mre.WaitOne();//这个是做真正的Wait操作，但是这里等待的是一个信号量，其不管是谁执行的，只有把mre.Set()我就立刻执行，这是与thread.Join()的区别Console.WriteLine(&quot;after WaitOne&quot;);mre.Reset();//关闭</code></pre><h2 id="Task-NET-3-0"><a href="#Task-NET-3-0" class="headerlink" title="Task(.NET 3.0)"></a>Task(.NET 3.0)</h2><p>Task的优势：<br>1，使用的是线程池的线程，全部是后台线程<br>2，API十分强大</p><pre><code class="c#">TaskFactory taskFactory = Task.Factory;{    taskFactory.StartNew(()=&gt;{this.DoSomethingLong(&quot;btnTask_Click001&quot;);});    taskFactory.StartNew(()=&gt;{this.DoSomethingLong(&quot;btnTask_Click002&quot;);});    taskFactory.StartNew(()=&gt;{this.DoSomethingLong(&quot;btnTask_Click003&quot;);});}</code></pre><h3 id="需要多线程加快速度，但是又要求全部-某些完成后才能返回"><a href="#需要多线程加快速度，但是又要求全部-某些完成后才能返回" class="headerlink" title="需要多线程加快速度，但是又要求全部/某些完成后才能返回"></a>需要多线程加快速度，但是又要求全部/某些完成后才能返回</h3><p>这种写法会卡界面</p><pre><code class="c#">TaskFactory taskFactory = Task.Factory;{    List&lt;Task&gt; taskList = new List&lt;Task&gt;();    taskList.Add(taskFactory.StartNew(()=&gt;this.DoSomethingLong(&quot;btnTask_Click001&quot;)));    taskList.Add(taskFactory.StartNew(()=&gt;this.DoSomethingLong(&quot;btnTask_Click002&quot;)));    taskList.Add(taskFactory.StartNew(()=&gt;this.DoSomethingLong(&quot;btnTask_Click003&quot;)));    //这个一定会卡界面，因为是主线程在等待    Task.WaitAll(taskList.ToArray());    //需要某个完成之后返回,只要其中有任何一个完成，就打印下一句，然后其他的子线程再陆续自行完成    Task.WaitAny(taskList.ToArray());    Console.WriteLine(&quot;全部任务都完成才能走到这里&quot;)}</code></pre><h3 id="不卡界面的写法-回调"><a href="#不卡界面的写法-回调" class="headerlink" title="不卡界面的写法/回调"></a>不卡界面的写法/回调</h3><pre><code class="c#">TaskFactory taskFactory = Task.Factory;List&lt;Task&gt; taskList = new List&lt;Task&gt;();taskList.Add(taskFactory.StartNew(()=&gt;this.DoSomethingLong(&quot;btnTask_Click001&quot;)));taskList.Add(taskFactory.StartNew(()=&gt;this.DoSomethingLong(&quot;btnTask_Click002&quot;)));taskList.Add(taskFactory.StartNew(()=&gt;this.DoSomethingLong(&quot;btnTask_Click003&quot;)));taskFactory.ContinueWhenAny(taskList.ToArray(),t=&gt;Console.WriteLine($&quot;This is ContinueWhenAny {Thread.CurrentThread.ManagedThreadId.ToString()}&quot;));taskFactory.ContinueWhenAll(taskList.ToArray(), tList =&gt; Console.WriteLine($&quot;This is ContinueWhenAll callback {Thread.CurrentThread.ManagedThreadId.ToString()}&quot;))Task.WaitAny(taskList.ToArray());Console.WriteLine(&quot;某个任务完成，才会执行&quot;);Task.WaitAll(taskList.ToArray());Console.WriteLine(&quot;全部任务都完成，才会执行&quot;);</code></pre><p>这里注意了，一般ContinueWhenXX都是在Task.WaitXX之后执行的，因为Task.WaitXX是主线程，它只需要听从一个信号量就可以，但是ContinueWhenXX是需要重新起一个线程，所以会比较慢</p><img src="/2018/07/22/net-thread/TaskWhenAny.png"><h3 id="那么如何知道到底是哪个线程任务完成了呢？可以在taskFactory-StartNew的时候定义一个state"><a href="#那么如何知道到底是哪个线程任务完成了呢？可以在taskFactory-StartNew的时候定义一个state" class="headerlink" title="那么如何知道到底是哪个线程任务完成了呢？可以在taskFactory.StartNew的时候定义一个state"></a>那么如何知道到底是哪个线程任务完成了呢？可以在taskFactory.StartNew的时候定义一个state</h3><pre><code class="c#">Task task = taskFactory.StartNew(()=&gt;this.DoSomethingLong(&quot;btnTask_Click001&quot;),&quot;It&#39;s A NAME&quot;);//task.AsyncState里面就会保存“It&#39;s A NAME”</code></pre><h3 id="取返回值"><a href="#取返回值" class="headerlink" title="取返回值"></a>取返回值</h3><pre><code class="c#">Task&lt;int&gt; intTask = taskFactory.StartNew(()=&gt;123);int iResult = intTask.Result;</code></pre><h3 id="如果只想某一个线程里面做回调"><a href="#如果只想某一个线程里面做回调" class="headerlink" title="如果只想某一个线程里面做回调"></a>如果只想某一个线程里面做回调</h3><pre><code class="c#">Task task = taskFactory.StartNew(()=&gt;this.DoSomethingLong(&quot;btnTask_Click001&quot;),&quot;It&#39;s A NAME&quot;)    .ContinueWith(t=&gt;Console.WriteLine(&quot;这里是It&#39;s A Name的回调&quot;));</code></pre><h2 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h2><p>1，相当于Task+WaitAll<br>2，主线程也参与计算，节约了一个线程，所以计算的时候卡界面</p><pre><code class="c#">Parallel.Invoke(()=&gt; this.DoSomethingLong(&quot;btnParallel_Click_001&quot;),    ()=&gt; this.DoSomethingLong(&quot;btnParallel_Click002&quot;),    ()=&gt; this.DoSomethingLong(&quot;btnParallel_Click003&quot;),    ()=&gt; this.DoSomethingLong(&quot;btnParallel_Click004&quot;));</code></pre><img src="/2018/07/22/net-thread/parallel.png"><p>也可以写成这种形式</p><pre><code class="c#">Parallel.For(0,5,t=&gt;{    this.DoSomethingLong($&quot;btnParallel_Click_00{t}&quot;);    });Parallel.ForEach(new int[]{0,1,2,3,4},t=&gt;{        this.DoSomethingLong($&quot;btnParallel_Click_00{t}&quot;);    });//也可以控制最大线程数量,比方说最大能用3个线程ParallelOptions options = new ParallelOptions(){    MaxDegreeOfParallelism = 3;}Parallel.ForEach(new int[]{0,1,2,3,4},options,(t,state)=&gt;{    this.DoSomethingLong($&quot;btnParallel_Click_00{t}&quot;);    state.Stop();//结束全部的    state.Break();//停止当前的    });</code></pre><h3 id="Thread的异常"><a href="#Thread的异常" class="headerlink" title="Thread的异常"></a>Thread的异常</h3><p>1，多线程里面的异常是会被吞掉的，外层是Catch不到线程里面的异常的<br>2，除非让主线程WaitAll才能拿到这个线程<br>3，建议多线程里面的异常自己在Action里面处理好，比方说加try catch</p><pre><code class="c#">TaskFactory taskFactory = new TaskFactory();List&lt;Task&gt; taskList = new List&lt;Task&gt;();try{    for(int i=0; i&lt; 20; i++)    {        string name = string.Format($&quot;btnThreadCore_Click_{i}&quot;);        Action&lt;object&gt; act = t =&gt;{            try            {                Thread.Sleep(2000);                if(t.ToString().Equals(&quot;btnThreadCore_Click_11&quot;))                {                    throw new Exception(string.Format($&quot;{t}执行失败&quot;));                }                Console.WriteLine(&quot;{0}执行成功&quot;,t);            }            //如果这一段的catch拿掉，外层是catch不到线程里面的异常的            //catch(Exception ex)            //{            //    Console.WriteLine(ex.Message);            //}        };        taskList.Add(taskFactory.StartNew(act,name));    }    //要抓到里面的异常需要这么做：    Task.WaitAll(taskList.ToArray());}catch(AggregateException aex){    foreach(var item in aex.InnerExceptions)    {        Console.WriteLine(item.Message);    }}catch(Exception ex){    Console.WriteLine(ex.Message);}</code></pre><h2 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h2><p>1，线程取消不是操作线程，而是操作共享变量（多个线程都能访问到的东西，变量/数据库的数据/标识）<br>2，每个线程在执行的过程中，要经常去查看一下这个信号量，然后自己结束自己<br>3，线程不能被别人终止，只能自己干掉自己<br>4，延迟是少不了的<br>5，<span style="color: red">CancellationTokenSource可以在cancel之后，取消没有启动的任务</span></p><pre><code class="c#">TaskFactory taskFactory = new TaskFactory();List&lt;Task&gt; taskList = new List&lt;Task&gt;();CancellationTokenSource cts = new CancellationTokenSource();try{    for(int i =0; i&lt;40; i++)    {        string name = string.Format(&quot;btnThreadCore_Click{0}&quot;,i);        Action&lt;object&gt; act = t =&gt;        {            try            {                Thread.Sleep(2000);                if(t.ToString().Equals(&quot;btnThreadCore_Click_11&quot;))                {                    throw new Exception($&quot;{t}执行失败&quot;);                }                //检查信号量，初始化的实会是false                if(cts.IsCancellationRequested)                {                    Console.WriteLine(&quot;{0} 放弃执行&quot;,t);                }                else                {                    Console.WriteLine(&quot;{0} 执行成功&quot;,t);                }            }            //在线程内部执行try catch的检查            catch(Exception ex)            {                //只要cts.Cancel发出来了，还没有执行的线程就不会再执行了，这是.    NET框架帮忙做的                cts.Cancel();                Console.WriteLine(ex.Message);            }        };        taskList.Add(taskFactory.StartNew(act, name, cts.Token));    }}catch(AggregateException aex){    foreach(var item in aex.InnerExceptions)    {        Console.WriteLine(item.Message);    }}catch(exception ex){    Console.WriteLine(ex.Message);}Task.WaitAll(taskList.ToArray());</code></pre><h2 id="多线程临时变量"><a href="#多线程临时变量" class="headerlink" title="多线程临时变量"></a>多线程临时变量</h2><p>如果只是这样写，出来的结果会是5个5<br>为什么呢？<br>因为BeginInvoke不占用主线程，在它loop的时候主线程已经执行到下面的代码去了，再启动子线程的时候，i已经遍历到5了</p><pre><code class="c#">for(int i = 1; i&lt; 5; i++){    new Action(() =&gt;    {        Thread.Sleep(100);        Console.WriteLine(i);    }).BeginInvoke(null,null);}</code></pre><img src="/2018/07/22/net-thread/param.png"><p>但是如果你加一个变量<br>每次启动子线程的时候，k都是独立不同的</p><pre><code class="c#">for(int i = 1; i&lt; 5; i++){    int k = i;    new Action(() =&gt;    {        Thread.Sleep(100);        Console.WriteLine(k);    }).BeginInvoke(null,null);}</code></pre><img src="/2018/07/22/net-thread/param2.png"><h2 id="线程安全问题-lock"><a href="#线程安全问题-lock" class="headerlink" title="线程安全问题 lock"></a>线程安全问题 lock</h2><p><strong><span style="color: red">注意！！只要用了多线程，还有for循环，最好就是在for里面定义一个新的变量与i对应，防止线程变量问题</span></strong></p><p>多个线程操作同一个变量，都有可能发生线程不安全问题<br>线程内部不佛念故乡的东西是安全的<br>CancellationToken, ManualResetEvent这类的都是安全的</p><pre><code class="c#">int TotalCount;var IntList = new List&lt;int&gt;();for(int i=0; i&lt;10000;i++){    int newI = i;    //要注意，这里并不是说起10000个线程，因为用taskFactory其实用的还是线程池里面的，不会起这么多线程的    taskList.Add(taskFactory.StartNew(()=&gt;    {        this.TotalCount += 1;//多个线程同时操作，有些操作可能会被覆盖，所以有可能是10000，也可能&lt;10000        IntList.Add(newI);    }));}Task.WaitAll(taskList.ToArray());Console.WriteLine(this.TotalCount);Console.WriteLine(IntList.Count());</code></pre><p>结果却是如图：<br><img src="/2018/07/22/net-thread/safety.png"></p><p>为什么呢？<br>对于这个this.TotalCount,会有多个线程对它同时加1，所以有时候操作被覆盖了;<br>IntList集合也是不安全，引用类型，同时多个线程对它访问，也会有可能被覆盖的;</p><h3 id="怎么样让其正确？"><a href="#怎么样让其正确？" class="headerlink" title="怎么样让其正确？"></a>怎么样让其正确？</h3><p>方法一，lock，用变量来保证，<strong>但是lock的方法块里面是单线程的</strong>,所以一定要保证不需要lock的逻辑放在lock之外</p><p>如果每个实例想要单独的锁定，那么就用一个<strong>private object</strong>，这样只有实例了你这个类的才能用</p><p>1，<strong>不要用lock(this),因为只要有一个人锁定了，别的地方想要用这个变量，就会都被锁定</strong><br>2，<strong>不要用lock(“12345”),这种是享元模式的内存分配，如果有另外一个变量string b = “12345”，那么会锁定这个变量b</strong><br>3，如果需要全局唯一的锁，那么推荐的做法是<code>private static readonly object XX_Lock=new object();</code>,private保证不让别人访问，只能内部访问，static保证全局只有一个，readonly保证不会在lock内部被更改<br>4，如果想要实例唯一，用<code>private object YY_Lock = new object();</code></p><pre><code class="c#">private static readonly object btnThreadCore_Click_Lock = new object();for(int i=0; i&lt;10000;i++){    int newI = i;    //要注意，这里并不是说起10000个线程，因为用taskFactory其实用的还是线程池里面的，不会起这么多线程的    taskList.Add(taskFactory.StartNew(()=&gt;    {        //线程看到这会先检查有没有别的变量在用这个名为btnThreadCore_Click_Lock锁定，如果锁定了就会等待        //这样就保证唯一时刻只有一个线程在访问        lock(btnThreadCore_Click_Lock)        {            this.TotalCount += 1;            IntList.Add(newI);        }    }));}</code></pre><p>方法二，让其没有冲突，从数据上隔离开，比方说这个线程访问前100个，另一个线程访问后面200个</p><h2 id="Await-Async"><a href="#Await-Async" class="headerlink" title="Await/Async"></a>Await/Async</h2><p>1，await和async要成对使用才有效果<br>2，await后面就是Task的回调</p><pre><code class="C#">private static async void NoReturn(){    //主线程执行    Console.WriteLine($&quot;NoReturn before await, ThreadId={Thread.CurrentThread.ManagedThreadId}&quot;);    TaskFactory taskFactory = new TaskFactory();    Task task = taskFactory.StartNew(()=&gt;    {        Console.WriteLine($&quot;NoReturn task before sleep, ThreadId={Thread.CurrentThread.ManagedThreadId}&quot;);        Thread.Sleep(3000);        Console.WriteLine($&quot;NoReturn task after sleep, ThreadId={Thread.CurrentThread.ManagedThreadId}&quot;);    });    //主线程到此就返回了，下面都是子线程来执行    await task;    //相当于await后面的都是回调！！！    //加入await之后，这一段就被封装成一个委托，在task之后形成回调，相当于task.ContinueWith()    //但是这个回调的线程是不确定的，有可能是主线程，也有可能是子线程，也有可能是其他线程！    Console.WriteLine($&quot;NoReturn after await, ThreadId={Thread.CurrentThread.ManagedThreadId}&quot;)}</code></pre><img src="/2018/07/22/net-thread/await1.png"><h3 id="带返回值的await-async"><a href="#带返回值的await-async" class="headerlink" title="带返回值的await/async"></a>带返回值的await/async</h3><p>1，注意，虽然函数是返回Task<long>,但是return的却是一个long类型</long></p><pre><code class="c#">private static async Task&lt;long&gt; SumAsync(){    Console.WriteLine($&quot;SumAsync Start, ManagedThreadId={Thread.CurrentThread.ManagedThreadId}&quot;);    long result=0;    await Task.Run(()=&gt;    {        for(int k=0; k&lt;10;k++)        {            Console.WriteLine($&quot;SumAsync {k} await Task.Run ManagedThreadId={Thr ead.CurrentThread.ManagedThreadId}&quot;);            Thread.Sleep(1000);        }        for(long i=0; i &lt; 999999999; i++)        {            result += i;        }    });    Console.WriteLine($&quot;SumAsync end ManagedThreadId={Thread.CurrentThread.ManagedThreadId}&quot;);    return result;}//Caller{    Tasl&lt;int&gt; t = SumAsync();    Console.WriteLine($&quot;Main Thread Task SumAsync, ManagedThreadId={Thread.CurrentThread.ManagedThreadId}&quot;);    long lResult = t.Result;    t.Wait();//与long lResult = t.Result是相同的，都会线程等待}</code></pre><p>上面的这种写法与下面相同</p><pre><code class="c#">private static Task&lt;int&gt; SumFactory(){    Console.WriteLine($&quot;SumFactory Start, ManagedThreadId={Thread.CurrentThread.ManagedThreadId}&quot;);    TaskFactory taskFactory = new TaskFactory();    Task&lt;int&gt; iResult = taskFactory.StartNew&lt;int&gt;(()=&gt;    {        Thread.Sleep(3000);        Console.WriteLine($&quot;SumFactory ManagedThreadId={Thread.CurrentThread.ManagedThreadId}&quot;);        return 123;    });    Console.WriteLine($&quot;SumFactory end ManagedThreadId={Thread.CurrentThread.ManagedThreadId}&quot;);    return iResult;}</code></pre><p>如果是有多个await，碰到第一个await,主线程返回，然后子线程A会把下面的所有当成回调，所以子线程A碰到第二个await，会返回，第三个await由子线程B来执行，知道返回return。</p><h2 id="子线程来更改主线程的UI"><a href="#子线程来更改主线程的UI" class="headerlink" title="子线程来更改主线程的UI"></a>子线程来更改主线程的UI</h2><p>如果这样写，会报错</p><pre><code class="c#">if(c is lable){    Label lbl = (Lable)c;    if(lbl.Name.Contains(&quot;Blue&quot;))    {        taskFactory.StartNew(()=&gt;{            this.ProcessLableBlue(lbl);});    }}private void ProcessLableBlue(Lable lbl){    int index = new RandomHelper().GetNumber(0,15);    //InvalidOperationException!    lbl.Text = this.BlueNums[index];}</code></pre><h3 id="子线程修改UI的方法"><a href="#子线程修改UI的方法" class="headerlink" title="子线程修改UI的方法"></a>子线程修改UI的方法</h3><pre><code class="c#">private void UpdateLbl(Lable lbl, string text){    //线程安全的考虑      if(lbl.InvokeRequired)    {        //Invoke方法代表把这个Action交给UI线程来执行        this.Invoke(new Action(() =&gt;        {            lbl.Text = text;        }));    }else    {        lbl.Text = text;    }}</code></pre><h3 id="如果有多个子线程同时工作，且要求每个子线程的结果不能相同"><a href="#如果有多个子线程同时工作，且要求每个子线程的结果不能相同" class="headerlink" title="如果有多个子线程同时工作，且要求每个子线程的结果不能相同"></a>如果有多个子线程同时工作，且要求每个子线程的结果不能相同</h3><p>1，注意了，虽然这里在lock里面又递归调用了ProcessLable方法，但是并不会死锁，因为这个锁有一个作用域的概念，你递归的时候还是在同一个作用域里面，所以并不会死锁</p><pre><code class="c#">private static object UpdateLblLock = new object();private void ProcessLable(Lable lbl){    if(lbl.Name.Contains(&quot;Blue&quot;))    {        int index = new RandomHelper().GetNumber(0,15);        string text = this.BlueNums[index];        this.UpdateLbl(lbl,text);    }    else    {        int index = new RandomHelper.GetNumber(0,33);        string text = this.RedNums[index];        lock(UpdateLblLock)        {            List&lt;string&gt; numberUsedList = this.GetUsedNums();            if(numberUsedList.Contains(text))            {                return;             }            this.UpdateLbl(lbl,text);        }    }}</code></pre><h3 id="要求点击Stop之后，MessageBox-Show结果"><a href="#要求点击Stop之后，MessageBox-Show结果" class="headerlink" title="要求点击Stop之后，MessageBox Show结果"></a>要求点击Stop之后，MessageBox Show结果</h3><p>如果写在btnStop_Click中就会死掉，为什么呢？<br>1，当IsGoOn=false的时候，就会等待ProcessLable结束<br>2，ProcessLable是怎么结束的呢？调用Invoke，而这个Invoke是主线程在调用的<br>3，但是这个时候主线程在Task.WaitAll()<br>4，所以死掉</p><pre><code class="c#">private bool IsGoOn = true;//caller{    taskList.Add(taskFactory.StartNew(()=&gt;    {        while(IsGoOn)        {            this.ProcessLable(lbl);        }    }));}//btnStop_Click{    this.IsGoOn = false;    this.btnStart.Enabled = true;    this.btnStop.Enabled = false;    //死掉了，主线程等着任务执行完，但是任务还在找主线程去干活    Task.WaitAll(this.taskList.ToArray());    this.MessageShow();}</code></pre><p>那么该怎么做？<br><strong>通过回调的形式结束！</strong></p><pre><code class="c#">//caller {    foreach(Control c in this.gbo.Controls)    {        if(c is Label)        {            Label lbl = (Lable)c;            taskList.Add(taskFactory.StartNew(()=&gt;            {                while(IsGoOn)                {                this.ProcessLable(lbl);            }            }));        }    }    this.btnStop.Enabled = true;    taskFactory.ContinueWhenAll(taskList.ToArray(), tList=&gt;this.MessageShow());}</code></pre>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>net-async</title>
      <link href="/2018/07/17/net-async/"/>
      <url>/2018/07/17/net-async/</url>
      <content type="html"><![CDATA[<h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><p>异步多线程：多线程是说的CLR线程，异步是说IO线程<br>要用异步多线程必须要用Delegate委托</p><pre><code class="c#">private void btnAsync_Click(object sender, EventArgs e){    //同步调用，必须DoSomethingLong结束后才会走下一步    Action&lt;string&gt; act = new Action&lt;string&gt;(this.DoSomethingLong);    act.Invoke(&quot;this.DoSomethingLong&quot;);    //异步调用，会启动一个线程；现象是直接进入下一行，不会等待    act.BeginInvoke(&quot;this.DoSomethingLong&quot;,null,null);}private void DoSomethingLong(string name){    Console.WriteLine($&quot;********DoSomethingLong Start {Thread.CurrentThread.ManagedThreadId.ToString(&quot;00&quot;)}&quot;);    long lResult = 0;    for(int i=0; i&lt;1000000;i++)    {        lResult += i;    }    Thread.Sleep(2000);    Console.WriteLine($&quot;********DoSomethingLong End {Thread.CurrentThread.ManagedThreadId.ToString(&quot;00&quot;)}&quot;);}</code></pre><a id="more"></a><h2 id="异步多线程如何控制顺序"><a href="#异步多线程如何控制顺序" class="headerlink" title="异步多线程如何控制顺序"></a>异步多线程如何控制顺序</h2><p>回调，这种方法十分稳定，一定会在委托执行完后再执行</p><pre><code class="c#">private void btnAsync_Click(object sender, EventArgs e){    Console.WriteLine($&quot;***********btnAsync_Click Startc {Thread.CurrentThread.ManagedThreadId.ToString(&quot;00&quot;)}&quot;);    Action&lt;string&gt; act = this.DoSomethingLong;    //回调方法，一定会在DoSomethingLong之后调用    AsyncCallback callback=ar =&gt; Console.WriteLine($&quot;这里是BeginInvoke调用完成之后才执行的{Thread.CurrentThread.ManagedThreadId.ToString(&quot;00&quot;)}&quot;);    //para asyncState会被保存在iAsyncResult的asyncState参数中    IAsyncResult iAsyncResult = act.BeginInvoke(&quot;btnAsync_Click&quot;,callback,&quot;asyncState&quot;);}</code></pre><p>等待<br>1, while这里是主线程来做的，所以会卡界面<br>2, EndInvoke可以拿到之前委托的结果 </p><pre><code class="c#">private void btnAsync_Click(object sender, EventArgs e){    Console.WriteLine($&quot;***********btnAsync_Click Startc {Thread.CurrentThread.ManagedThreadId.ToString(&quot;00&quot;)}&quot;);    Action&lt;string&gt; act = this.DoSomethingLong;    //para asyncState会被保存在iAsyncResult的asyncSta te参数中    IAsyncResult iAsyncResult = act.BeginInvoke(&quot;btnAsync_Click&quot;,null,null);    int i=1;    //1 卡界面，主线程会等待    //2 边等待边做事    //3 有误差，会等待200毫秒    while(!iAsyncResult.IsCompleted)    {        if(i &lt; 10)        {            Console.WriteLine(&quot;文件上传{0}%...请等待&quot;,i++ * 10);        }        else        {            Console.WriteLine(&quot;马上结束&quot;);        }        Thread.Sleep(200);        Console.WriteLine(&quot;这里是BeginInvoke调用完成之后才执行的&quot;);    }     //另外一种方式可以让异步变同步,不会有误差的，一直等待任务完成，这种方式不能在等待的过程中做别的事情    iAsyncResult.AsyncWaitHandle.WaitOne();    //最多等待1000毫秒，可以做超时控制    iAsyncResult.AsyncWaitHandle.WaitOne(1000);    {        Func&lt;int,string&gt; func = i =&gt; i.ToString();        iAsyncResult iAsyncResult = func.BeginInvoke(DateTime.Now.Year, ar=&gt;{                //这个就是传入的“Lalala”                Console.WriteLine(ar.AsyncState);            },&quot;Lalala&quot;);        //这个result就是func的返回值        string result = func.EndInvoke(iAsyncResult);    }    //对于每个异步调用，只能有一个EndInvoke    {        Func&lt;int,string&gt; func = i =&gt; i.ToString();        iAsyncResult iAsyncResult = func.BeginInvoke(DateTime.Now.Year, ar=&gt;{                string resultIn = func.EndInvoke(ar);                //这个就是传入的“Lalala”                Console.WriteLine($&quot;This is {ar.AsyncState} 的异步调用结果 {resultIn}&quot;);            },&quot;Lalala&quot;);        //这个result就是func的返回值    }}</code></pre>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>lxd-ubuntu</title>
      <link href="/2018/07/02/lxd-ubuntu/"/>
      <url>/2018/07/02/lxd-ubuntu/</url>
      <content type="html"><![CDATA[<p>ENV: UBUNTU</p><h2 id="Add-a-non-root-user"><a href="#Add-a-non-root-user" class="headerlink" title="Add a non root user"></a>Add a non root user</h2><pre><code class="shell">adduser lxduserusermod -aG sudo lxduser##disable password authenticationsudo nano /etc/ssh/sshd_configPasswordAuthentication nosudo systemctl reload sshd</code></pre><a id="more"></a><h2 id="Configure-LXD"><a href="#Configure-LXD" class="headerlink" title="Configure LXD"></a>Configure LXD</h2><pre><code class="shell">sudo usermod --append --groups lxd lxdusersudo apt-get updatesudo apt-get install zfsutils-linuxsudo lxd initDo you want to configure a new storage pool (yes/no) [default=yes]? yesName of the storage backend to use (dir or zfs) [default=zfs]: zfsCreate a new ZFS pool (yes/no) [default=yes]? yesName of the new ZFS pool [default=lxd]: lxdWould you like to use an existing block device (yes/no) [default=no]?Would you like to use an existing block device (yes/no) [default=no]? noSize in GB of the new loop device (1GB minimum) [default=15]: 15Would you like LXD to be available over the network (yes/no) [default=no]? noDo you want to configure the LXD bridge (yes/no) [default=yes]? yes</code></pre><h2 id="Create-Container"><a href="#Create-Container" class="headerlink" title="Create Container"></a>Create Container</h2><pre><code class="shell">lxc listGenerating a client certificate. This may take a minute...If this is your first time using LXD, you should also run: sudo lxd initTo start your first container, try: lxc launch ubuntu:16.04+------+-------+------+------+------+-----------+| NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS |+------+-------+------+------+------+-----------+lxc launch ubuntu:x webserver##The x in ubuntu:x is a shortcut for the first letter of Xenial, the codename of Ubuntu 16.04. ubuntu: is the identifier for the preconfigured repository of LXD images. You could also use ubuntu:16.04 for the image name.</code></pre><h2 id="Configure-Container"><a href="#Configure-Container" class="headerlink" title="Configure Container"></a>Configure Container</h2><pre><code class="shell">lxc exec webserver -- sudo --login --user ubuntu</code></pre><h2 id="Ubuntu-Nginx-AutoStart"><a href="#Ubuntu-Nginx-AutoStart" class="headerlink" title="Ubuntu Nginx AutoStart"></a>Ubuntu Nginx AutoStart</h2><p>[<a href="https://community.rackspace.com/products/f/public-cloud-forum/6747/ubuntu-and-debian---adding-an-nginx-init-script]" target="_blank" rel="noopener">https://community.rackspace.com/products/f/public-cloud-forum/6747/ubuntu-and-debian---adding-an-nginx-init-script]</a></p><pre><code>sudo nano /etc/init.d/nginx</code></pre><p>Add those, <strong>spotted: ADD YOUR NGINX INSTALLATION PATH INTO $PATH</strong></p><pre><code>#! /bin/sh### BEGIN INIT INFO# Provides:          nginx# Required-Start:    $all# Required-Stop:     $all# Default-Start:     2 3 4 5# Default-Stop:      0 1 6# Short-Description: starts the nginx web server# Description:       starts nginx using start-stop-daemon### END INIT INFOPATH=/usr/local/nginx/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/binDAEMON=/usr/local/nginx/sbinNAME=nginxDESC=nginxtest -x $DAEMON || exit 0# Include nginx defaults if availableif [ -f /etc/default/nginx ] ; then    . /etc/default/nginxfiset -e. /lib/lsb/init-functionscase &quot;$1&quot; in  start)    echo -n &quot;Starting $DESC: &quot;    start-stop-daemon --start --quiet --pidfile /usr/local/nginx/logs/$NAME.pid \        --exec $DAEMON -- $DAEMON_OPTS || true    echo &quot;$NAME.&quot;    ;;  stop)    echo -n &quot;Stopping $DESC: &quot;    start-stop-daemon --stop --quiet --pidfile /usr/local/nginx/logs/$NAME.pid \        --exec $DAEMON || true    echo &quot;$NAME.&quot;    ;;  restart|force-reload)    echo -n &quot;Restarting $DESC: &quot;    start-stop-daemon --stop --quiet --pidfile \        /usr/local/nginx/logs/$NAME.pid --exec $DAEMON || true    sleep 1    start-stop-daemon --start --quiet --pidfile \        /usr/local/nginx/logs/$NAME.pid --exec $DAEMON -- $DAEMON_OPTS || true    echo &quot;$NAME.&quot;    ;;  reload)      echo -n &quot;Reloading $DESC configuration: &quot;      start-stop-daemon --stop --signal HUP --quiet --pidfile /usr/local/nginx/logs/$NAME.pid \          --exec $DAEMON || true      echo &quot;$NAME.&quot;      ;;  status)      status_of_proc -p /usr/local/nginx/logs/$NAME.pid &quot;$DAEMON&quot; nginx &amp;&amp; exit 0 || exit $?      ;;  *)    N=/etc/init.d/$NAME    echo &quot;Usage: $N {start|stop|restart|reload|force-reload|status}&quot; &gt;&amp;2    exit 1    ;;esacexit 0</code></pre><pre><code>sudo chmod +x /etc/init.d/nginxsudo /usr/sbin/update-rc.d -f nginx defaults</code></pre><p>The output will be similar to this:</p><pre><code>Adding system startup for /etc/init.d/nginx ... Adding system startup for /etc/init.d/nginx ...   /etc/rc0.d/K20nginx -&gt; ../init.d/nginx   /etc/rc1.d/K20nginx -&gt; ../init.d/nginx   /etc/rc6.d/K20nginx -&gt; ../init.d/nginx   /etc/rc2.d/S20nginx -&gt; ../init.d/nginx   /etc/rc3.d/S20nginx -&gt; ../init.d/nginx   /etc/rc4.d/S20nginx -&gt; ../init.d/nginx   /etc/rc5.d/S20nginx -&gt; ../init.d/nginx</code></pre><p>Then start/stop/restart</p><pre><code>sudo /etc/init.d/nginx start...sudo /etc/init.d/nginx stop...sudo /etc/init.d/nginx restart</code></pre><h2 id="Reset-timezone"><a href="#Reset-timezone" class="headerlink" title="Reset timezone"></a>Reset timezone</h2><pre><code>sudo dpkg-reconfigure tzdata</code></pre><h2 id="Rename-Container"><a href="#Rename-Container" class="headerlink" title="Rename Container"></a>Rename Container</h2><p>1,    Login to the container</p><pre><code>```sudo -shostname newNameecho newName &gt; /etc/hostnamebashrebootexit```</code></pre><p>2,    Return to the host</p><pre><code>```sudo -slxc stop oldNamelxc move oldName newNamelxc start newNamelxc list```</code></pre><h2 id="Copy-Container"><a href="#Copy-Container" class="headerlink" title="Copy Container"></a>Copy Container</h2><pre><code>lxc copy old1 new1lxc start new1</code></pre><h2 id="Add-Swap-Space"><a href="#Add-Swap-Space" class="headerlink" title="Add Swap Space"></a>Add Swap Space</h2><p>[<a href="https://www.digitalocean.com/community/tutorials/how-to-add-swap-space-on-ubuntu-16-04]" target="_blank" rel="noopener">https://www.digitalocean.com/community/tutorials/how-to-add-swap-space-on-ubuntu-16-04]</a></p><h4 id="Check-system-for-swap-information"><a href="#Check-system-for-swap-information" class="headerlink" title="Check system for swap information"></a>Check system for swap information</h4><pre><code>sudo swapon --show</code></pre><p>If you don’t get back any output, this means your system does not have swap space available currently.</p><p>You can verify that there is no active swap using the free utility:</p><pre><code>free -h</code></pre><pre><code>Output              total        used        free      shared  buff/cache   availableMem:           488M         36M        104M        652K        348M        426MSwap:            0B          0B          0B</code></pre><h4 id="Check-Available-Space-on-the-Hard-Drive-Partition"><a href="#Check-Available-Space-on-the-Hard-Drive-Partition" class="headerlink" title="Check Available Space on the Hard Drive Partition"></a>Check Available Space on the Hard Drive Partition</h4><p>The most common way of allocating space for swap is to use a separate partition devoted to the task. However, altering the partitioning scheme is not always possible. We can just as easily create a swap file that resides on an existing partition.</p><p>Before we do this, we should check the current disk usage by typing:</p><pre><code>df -h</code></pre><pre><code>OutputFilesystem      Size  Used Avail Use% Mounted onudev            238M     0  238M   0% /devtmpfs            49M  624K   49M   2% /run/dev/vda1        20G  1.1G   18G   6% /tmpfs           245M     0  245M   0% /dev/shmtmpfs           5.0M     0  5.0M   0% /run/locktmpfs           245M     0  245M   0% /sys/fs/cgrouptmpfs            49M     0   49M   0% /run/user/1001</code></pre><h4 id="Create-a-Swap-File"><a href="#Create-a-Swap-File" class="headerlink" title="Create a Swap File"></a>Create a Swap File</h4><p>Now that we know our available hard drive space, we can go about creating a swap file within our filesystem. We will create a file of the swap size that we want called swapfile in our root (/) directory.</p><p>The best way of creating a swap file is with the fallocate program. This command creates a file of a preallocated size instantly.</p><p>Since the server in our example has 512MB of RAM, we will create a 1 Gigabyte file in this guide. Adjust this to meet the needs of your own server:</p><pre><code>sudo fallocate -l 1G /swapfile</code></pre><p>We can verify that the correct amount of space was reserved by typing:</p><pre><code>ls -lh /swapfile</code></pre><pre><code>-rw-r--r-- 1 root root 1.0G Apr 25 11:14 /swapfile</code></pre><h4 id="Enabling-the-Swap-File"><a href="#Enabling-the-Swap-File" class="headerlink" title="Enabling the Swap File"></a>Enabling the Swap File</h4><p>Now that we have a file of the correct size available, we need to actually turn this into swap space.</p><p>First, we need to lock down the permissions of the file so that only the users with root privileges can read the contents. This prevents normal users from being able to access the file, which would have significant security implications.</p><p>Make the file only accessible to root by typing:</p><pre><code>sudo chmod 600 /swapfile</code></pre><p>We can now mark the file as swap space by typing:</p><pre><code>sudo mkswap /swapfile</code></pre><pre><code>Setting up swapspace version 1, size = 1024 MiB (1073737728 bytes)no label, UUID=6e965805-2ab9-450f-aed6-577e74089dbf</code></pre><p>After marking the file, we can enable the swap file, allowing our system to start utilizing it:</p><pre><code>sudo swapon /swapfile</code></pre><p>We can verify that the swap is available by typing:</p><pre><code>sudo swapon --show</code></pre><pre><code>OutputNAME      TYPE  SIZE USED PRIO/swapfile file 1024M   0B   -1</code></pre><h4 id="Make-the-swap-file-permanant"><a href="#Make-the-swap-file-permanant" class="headerlink" title="Make the swap file permanant"></a>Make the swap file permanant</h4><p>Our recent changes have enabled the swap file for the current session. However, if we reboot, the server will not retain the swap settings automatically. We can change this by adding the swap file to our <code>/etc/fstab</code>file.</p><pre><code>sudo cp /etc/fstab /etc/fstab.bakecho &#39;/swapfile none swap sw 0 0&#39; | sudo tee -a /etc/fstab</code></pre><h4 id="Adjusting-the-Swappiness-Property"><a href="#Adjusting-the-Swappiness-Property" class="headerlink" title="Adjusting the Swappiness Property"></a>Adjusting the Swappiness Property</h4><p>The swappiness parameter configures how often your system swaps data out of RAM to the swap space. This is a value between 0 and 100 that represents a percentage.</p><p>With values close to zero, the kernel will not swap data to the disk unless absolutely necessary. Remember, interactions with the swap file are “expensive” in that they take a lot longer than interactions with RAM and they can cause a significant reduction in performance. Telling the system not to rely on the swap much will generally make your system faster.</p><p>Values that are closer to 100 will try to put more data into swap in an effort to keep more RAM space free. Depending on your applications’ memory profile or what you are using your server for, this might be better in some cases.</p><pre><code>cat /proc/sys/vm/swappiness</code></pre><pre><code>Output60</code></pre><p>For a Desktop, a swappiness setting of 60 is not a bad value. For a server, you might want to move it closer to 0.</p><p>We can set the swappiness to a different value by using the sysctl command.</p><p>For instance, to set the swappiness to 10, we could type:</p><pre><code>sudo sysctl vm.swappiness=10</code></pre><pre><code>Outputvm.swappiness = 10</code></pre><p>This setting will persist until the next reboot. We can set this value automatically at restart by adding the line to our /etc/sysctl.conf file:</p><pre><code>sudo nano /etc/sysctl.conf</code></pre><p>At the bottom, you can add:</p><pre><code>vm.swappiness=10</code></pre><h4 id="Adjusting-the-Cache-Pressure-Setting"><a href="#Adjusting-the-Cache-Pressure-Setting" class="headerlink" title="Adjusting the Cache Pressure Setting"></a>Adjusting the Cache Pressure Setting</h4><p>Another related value that you might want to modify is the vfs_cache_pressure. This setting configures how much the system will choose to cache inode and dentry information over other data.</p><p>Basically, this is access data about the filesystem. This is generally very costly to look up and very frequently requested, so it’s an excellent thing for your system to cache. You can see the current value by querying the proc filesystem again:</p><pre><code>cat /proc/sys/vm/vfs_cache_pressure</code></pre><pre><code>Output100</code></pre><p>As it is currently configured, our system removes inode information from the cache too quickly. We can set this to a more conservative setting like 50 by typing:</p><pre><code>sudo sysctl vm.vfs_cache_pressure=50</code></pre><p>Again, this is only valid for our current session. We can change that by adding it to our configuration file like we did with our swappiness setting:</p><pre><code>sudo nano /etc/sysctl.confvm.vfs_cache_pressure=50</code></pre><h2 id="Bash-Script-to-launch-lxd"><a href="#Bash-Script-to-launch-lxd" class="headerlink" title="Bash Script to launch lxd"></a>Bash Script to launch lxd</h2><p>REF:[<a href="https://gist.github.com/CalebEverett/aef682acf6988bbc44d9d8196f222355]" target="_blank" rel="noopener">https://gist.github.com/CalebEverett/aef682acf6988bbc44d9d8196f222355]</a></p><pre><code class="bash">#!/bin/bash# variablesCONTAINER=mycontainerIMAGE=ubuntu-daily:xenialPORT=8080PROFILES=defaultFOLDER=appREPO=https://github.com/CalebEverett/hello-lxd.gitRUN_USER=appRUN_USER_UID=1444CONTAINER_ROOT_UID=$(cat /etc/subgid | grep lxd | cut -d : -f 2)function wait_bar () {  for i in {1..10}  do    printf &#39;= %.0s&#39; {1..$i}    sleep $1s  done}# create the container if it doesn&#39;t existif [ ! -e /var/lib/lxd/containers/$CONTAINER ]  then    lxc launch --verbose $IMAGE $CONTAINER    wait_bar 0.5    echo container $CONTAINER started  else    echo container $CONTAINER already createdfi# apply profileslxc profile apply $CONTAINER $PROFILES# delete ubuntu userif [ ! -z $(lxc exec $CONTAINER -- getent passwd | grep ubuntu) ]then  lxc exec $CONTAINER -- userdel -r ubuntufi# create running userif [ -z $(lxc exec $CONTAINER -- getent passwd | grep $RUN_USER) ]then  lxc exec $CONTAINER -- useradd -u $RUN_USER_UID -s /usr/sbin/nologin $RUN_USERfi#install nodeif [ -z $(lxc exec $CONTAINER -- which node) ]then  printf &quot;\n\n*** Installing node ***&quot;  lxc exec $CONTAINER -- /bin/bash -c &#39;curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -&#39;  lxc exec $CONTAINER -- apt-get install -y nodejs  echo Node $(lxc exec $CONTAINER -- node -v) installedelse  echo Node $(lxc exec $CONTAINER -- node -v) already installedfi#install gitif [ -z $(lxc exec $CONTAINER -- which git) ]then  printf &quot;\n\n*** Installing git ***&quot;  lxc exec $CONTAINER -- apt-get install -y git  echo $(lxc exec $CONTAINER -- git --version) installedelse  echo $(lxc exec $CONTAINER -- git --version) already installedfi# redirect 80 to $PORTif [[ -z $(lxc exec $CONTAINER -- cat /etc/ufw/before.rules | grep PREROUTING) ]]then  lxc exec $CONTAINER -- /bin/bash -c &quot;sed -i &#39;/#   ufw-before-forward/ a\#\n\# redirect 80 to $PORT\n\*nat\n\:PREROUTING ACCEPT [0:0]\n\-A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port $PORT\n\COMMIT&#39; /etc/ufw/before.rules&quot;  lxc exec $CONTAINER -- ufw enable  lxc exec $CONTAINER -- ufw allow $PORT/tcpfi#mount $FOLDER directory if developingif [[ $FOLDER &amp;&amp;  $PROFILES == *&quot;default&quot;* ]]then  printf &quot;\n\n*** Mounting shared folder ***\n&quot;  if [ ! -d ./$FOLDER ]; then mkdir ./$FOLDER; fi  if [[ -z $(lxc config device list $CONTAINER | grep $FOLDER) ]]  then    lxc config device add $CONTAINER $FOLDER disk path=/usr/src/$FOLDER source=$(pwd)/$FOLDER    sudo chown -R $((CONTAINER_ROOT_UID + RUN_USER_UID)):$((CONTAINER_ROOT_UID + $RUN_USER_UID)) ./$FOLDER    sudo setfacl -R -m d:u:$USER:xwr,u:$USER:xwr,d:g:$USER:xwr,g:$USER:xwr ./$FOLDER    sudo chown -R $((CONTAINER_ROOT_UID + RUN_USER_UID)):$((CONTAINER_ROOT_UID + $RUN_USER_UID)) ./$FOLDER    echo $(pwd)/$FOLDER mounted at /usr/src/$FOLDER  else    echo Directory $(pwd)/$FOLDER already mounted  fifi#clone repo and install modulesif [ $REPO ]  then   if [[ -z $(lxc exec $CONTAINER -- cat /usr/src/$FOLDER/package.json) ]]    then      lxc exec $CONTAINER -- git clone -q $REPO /usr/src/$FOLDER      lxc exec $CONTAINER --env HOME=/usr/src/$FOLDER -- npm install      lxc exec $CONTAINER -- chown -R $RUN_USER:$RUN_USER /usr/src/$FOLDER/node_modules    fifi# build and run as a service if productionif [[ $PROFILES == *&quot;pro&quot;* ]]then    if [[ $(lxc exec $CONTAINER -- /bin/bash -c &#39;if [ ! -f /etc/systemd/system/$CONTAINER.service ]; then echo 0; fi&#39;) ]]  then    printf &quot;\n\n*** Creating service file ***&quot;    lxc exec $CONTAINER -- /bin/bash -c &quot;cat &lt;&lt;-EOF &gt; /etc/systemd/system/$CONTAINER.service    [Unit]    Description=$CONTAINER    [Service]    WorkingDirectory=/usr/src/$FOLDER    ExecStart=/usr/bin/node /usr/src/$FOLDER/index.js    Restart=always    RestartSec=10    StandardOutput=syslog    StandardError=syslog    SyslogIdentifier=$CONTAINER    User=$RUN_USER    Environment=HOME=/usr/src/$FOLDER    Environment=NODE_ENV=production    Environment=PORT=$PORT    [Install]    WantedBy=multi-user.targetEOF&quot;    lxc exec $CONTAINER -- systemctl enable $CONTAINER.service    sleep 3.0s    lxc exec $CONTAINER -- systemctl start $CONTAINER.service  fifiprintf &quot;\n&quot; &amp;&amp; lxc list $CONTAINER# start app for devif [[ $PROFILES == *&quot;default&quot;* &amp;&amp; -z $(lxc exec $CONTAINER -- ps aux | grep /usr/src/$FOLDER/index.js) ]]then  google-chrome $(lxc exec $CONTAINER -- bash -c &quot;ifconfig | grep -o &#39;[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}&#39; | head -n 1&quot;)  lxc exec $CONTAINER --env HOME=/usr/src/$FOLDER --env PORT=$PORT -- node index.jsfi</code></pre>]]></content>
      
      
        <tags>
            
            <tag> practice </tag>
            
            <tag> LXD </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>net-expression</title>
      <link href="/2018/06/28/net-expression/"/>
      <url>/2018/06/28/net-expression/</url>
      <content type="html"><![CDATA[<p>表达式目录树Expression<br>编译之后不是生成的方法，不是一个委托</p><pre><code class="c#">Func&lt;int,int,int&gt; func = (m,n) =&gt; m*n+2;Expression&lt;Func&lt;int,int,int&gt;&gt; exp = (m,n)=&gt; m*n+2;int iResult1 = func.Invoke(12,23);int iResult2 = exp.Compile().Invoke(12,23);</code></pre>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> net </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>net-linq</title>
      <link href="/2018/06/28/net-linq/"/>
      <url>/2018/06/28/net-linq/</url>
      <content type="html"><![CDATA[<h2 id="linq-to-Object-是翻译成object，在内存里面"><a href="#linq-to-Object-是翻译成object，在内存里面" class="headerlink" title="linq to Object, 是翻译成object，在内存里面"></a>linq to Object, 是翻译成object，在内存里面</h2><pre><code class="c#">//分页的功能var list = studentList.Where(s=&gt;s.Age&lt;30)            .Select(s =&gt; new            {                Id = s.Id,                ClassId = s.ClassId,                IdName = s.Id + s.Name,                ClassName = s.ClassId == 2? &quot;Advanced&quot;:&quot;Other&quot;            })            .OrderBy(s=&gt;s.Id)            .OrderByDescending(s=&gt;s.ClassId)            .Skip(2) //跳过几条            .Take(3); //获取几条//group{    var list = from s in studentList                where s.Age &lt; 30                group s by s.ClassId into sg                select new                {                    key = sg.Key, //sg.Key就是s.ClassId                    maxAge = sg.Max(t=&gt;t.Age)                };                //groupby new {s.ClassId,s.Age}}//inner join{    var list = from s in studentList                join c in classList on s.ClassId equals c.Id                select new                {                    Name = s.Name,                    ClassName = c.ClassName                };}//left join{    var list  = from s in studentList                join c in classList on s.ClassId equals c.Id                into scList                from sc in scList.DefaultIfEmpty()                select new                {                    Name = s.Name,                    ClassName = sc==null?&quot;无班级&quot;:sc.ClassName                }}//left Join{    var list = studentList.Join(classList, s=&gt;s.ClassId, c=&gt;c.Id, (s,c)=&gt;new{            Name = s.Name,            ClassName = c.ClassName        }).DefaultIfEmpty();}</code></pre>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> net </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>net-yield</title>
      <link href="/2018/06/28/net-yield/"/>
      <url>/2018/06/28/net-yield/</url>
      <content type="html"><![CDATA[<p>迭代器<br><span style="color: red">注意！yield是写在while里面的，且返回的是result!不是results!</span></p><p>yield 是一个状态机，只有在真正调用的时候才会进到方法里面调用</p><pre><code class="c#">//一次性把所有数据都计算好public IEnumerable&lt;int&gt; CommonMethod(){    List&lt;int&gt; results = new List&lt;int&gt;();    int counter = 0;    int result = 1;    while(counter++ &lt; 10)    {        Thread.Sleep(1000);        Console.WriteLine($&quot;获取{counter}次数据&quot;);        result = result * 2;        results.Add(result);    }    return results;}//按需获取 public IEnumerable&lt;int&gt; YieldMethod(){    int counter = 0;    int result = 1;    while(counter++ &lt; 10)    {        Thread.Sleep(1000);        Console.WriteLine($&quot;获取{counter}次数据&quot;);        result = result * 2;        yield return results;    }}//callerIEnumerable&lt;int&gt; intListCommon = show.CommonMethod();//返回的是最终的结果IEnumerable&lt;int&gt; intListYield = show.YieldMethod();//这个时候返回的是一个状态机，不是最终的结果//只有在调用item的时候，才会真正走进去，且每次循环后是从while开始的！foreach(var item in intListYield){}</code></pre><h2 id="linq"><a href="#linq" class="headerlink" title="linq"></a>linq</h2><p>.NET里面linq其实也是用的yield方式实现的，只有在真正使用的时候才会去执行逻辑代码</p><p>比方说</p><pre><code class="c#">var itemList = studentList.Where(x=&gt;x.Age &lt; 30);</code></pre><p>但是如果用了ToList()，就会之u姐去执行逻辑代码</p><pre><code class="c#">var itemList2 = studentList.Where(x=&gt;x.Age&gt;30).ToList();</code></pre>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> net </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>zookeeper-basics</title>
      <link href="/2018/06/27/zookeeper-basics/"/>
      <url>/2018/06/27/zookeeper-basics/</url>
      <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>zookeeper是一个分布式协调服务<br>提供的服务涵盖：主从协调、服务器节点动态上下线、统一配置管理、分布式共享锁、统一名称服务…</p><p>zookeeper可靠性很高，本身内部就是个集群，只要集群里面有半数以上的结点存活就可以提供服务</p><p>本质上zookeeper就只有两个功能：<br>1，管理（存储，读取）用户提交的数据；<br>2，并为用户程序提供数据节点监听服务；</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>tar -zxvf zookeeper.XXX.tar.gz<br>nano conf/zoo.cfg<br>add<br>bin/zkServer.sh start</p>]]></content>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> zookeeper </tag>
            
            <tag> pratice </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>auto-deploy-scripts</title>
      <link href="/2018/06/26/auto-deploy-scripts/"/>
      <url>/2018/06/26/auto-deploy-scripts/</url>
      <content type="html"><![CDATA[<h2 id="自己建yum源【centos系统】"><a href="#自己建yum源【centos系统】" class="headerlink" title="自己建yum源【centos系统】"></a>自己建yum源【centos系统】</h2><p>1，启一个httpd web service，不需要装tomcat这类，只需要一个静态的服务器即可<br>2，检查httpd service <code>service httpd status</code><br>3，在<code>/var/www/html</code>下面创建一个目录挂载cdrom<br>4，挂载目录指令为<br>    <code>mount -t iso9660 -o ro /dev/cdrom /mnt/cdrom</code><br>41，如果iso盘中没有<code>repodata</code>,即没有dependecy link文件，需要手动创建<br>    <code>createrepo /mnt/cdromlocal</code><br>42，    创建完<code>repodata</code>后，需要再生成一个iso文件<br>    <code>mkisofs -o /mnt/example.iso /mnt/cdromlocal/</code><br>5，设置重启自动挂载<br>    <code>vi /etc/fstab</code><br>    在文件尾部追加<br>    <code>/dev/cdrom        /mnt/cdrom        iso9660        defaults        0        0</code><br>6，在httpd html文件夹下面新建一个文件夹比方说叫centos，软链接指向这个mnt目录即可，假设mnt目录为/mnt/cdrom<br>    <code>ln -s /mnt/cdrom /var/www/html/centos</code><br>7，更改centos repo.d文件，指向这个yum源<br>    <code>vi /etc/yum.repos.d/xxx.repo</code></p><pre><code>```[base]name=CentOS-Localbaseurl=http://192.168.X.X/centosgpgcheck=1enabled=1   #很重要，1才启用gpgkey=file:///mnt/cdrom/rpm-gpg/RPM-GPG-KEY-CentOS-6```</code></pre><p>8，常用yum命令<br>    <code>yum clean all</code>    清除所有缓冲数据<br>    <code>yum repolist</code>    列出可用的yum源<br>    <code>yum deplist httpd</code>    列出一个包所依赖的包<br>    <code>yum remove httpd</code>    删除一个包</p><h2 id="准备一个boot-sh脚本"><a href="#准备一个boot-sh脚本" class="headerlink" title="准备一个boot.sh脚本"></a>准备一个boot.sh脚本</h2><p><code>ssh-keygen -f</code>    查看pem对应的private key</p><p>ssh登陆所用的key pair存在.ssh/authorized_keys文件中，如果不小心删掉了，可以把private key的内容copy到authorized_keys文件，然后+空格+pem的名称，比如<code>ssh-rsa XXXXXX linuxAAAA</code>,之后再更改文件权限<code>chmod 600 .ssh/authorized_keys</code></p><p><code>ssh-keygen -f publickey.pem &gt;&gt; authorized.keys</code>或者可以用这个命令写进去前半段key的内容</p><p><code>ssh-keygen -R hostname</code>    删除known_hosts</p><p><code>sudo yum install expect</code>    模拟用户输入密码，yes等信息</p><pre><code class="bash">#!/bin/bashSERVERS=&quot;node-3.itcast.cn node-4.itcast.cn&quot;PASSWORD=123456BASE_SERVER=172.16.203.100#auto_ssh_copy_id() {#    expect -c &quot;set timeout -1;#        spawn ssh-copy-id $1;#        expect {#            *(yes/no)* {send -- #yes\r;exp_continue;}#            *assword:* {send -- $2\r;exp_continue;}#            eof        {exit 0;}#        }&quot;;#}##ssh_copy_id_to_all() {#    for SERVER in $SERVERS#    do#        auto_ssh_copy_id $SERVER $PASSWORD#    done#}#auto_ssh_login() {    expect -c &quot;set timeout -1;        spawn ssh -i /home/ec2-user/linuxSS.pem ec2-user@$1;        expect {            *(yes/no)* {send -- yes\r;exp_continue;}            eof        {exit 0;}        }&quot;;}ssh_login_to_all() {        for SERVER in $SERVERS        do                auto_ssh_login $SERVER        done}ssh_login_to_allfor SERVER in $SERVERSdo       scp -i linuxSS.pem install.sh ec2-user@$SERVER:/home/ec2-user       ssh -i linuxSS.pem ec2-user@$SERVER &quot;sudo chmod u+x /home/ec2-user/install.sh;echo lalalal &gt;&gt; /home/ec2-use$done</code></pre><h2 id="Install-sh"><a href="#Install-sh" class="headerlink" title="Install.sh"></a>Install.sh</h2><p>如果用<code>echo</code>来写入到/etc/profile中，换行符不好弄<br><code>&lt;&lt;</code>类似于文件的重定向，就是写个文件进去，<code>EOF</code>就是文件的标志，末尾也要写个EOF进去，就相当于追加一个文件到/etc/profile的末尾</p><pre><code class="bash">#!/bin/bashBASE_SERVER=172.16.203.100yum install -y wgetwget $BASE_SERVER/soft/jdk-XXXX.tar.gztar -zxvf jdk-XXXX.tar.gz -C /usr/localcat &gt;&gt; /etc/profile &lt;&lt; EOFexport JAVA_HOME=/usr/local/jdkXXXexport PATH=\$PATH:\$JAVA_HOME/binEOF</code></pre>]]></content>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> practice </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux-yum-web-package-storage</title>
      <link href="/2018/06/25/linux-yum-web-package-storage/"/>
      <url>/2018/06/25/linux-yum-web-package-storage/</url>
      <content type="html"><![CDATA[]]></content>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> practice </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sublimetext-usage</title>
      <link href="/2018/06/25/sublimetext-usage/"/>
      <url>/2018/06/25/sublimetext-usage/</url>
      <content type="html"><![CDATA[<h2 id="Allow-Alt-Drag-in-windows"><a href="#Allow-Alt-Drag-in-windows" class="headerlink" title="Allow Alt+Drag in windows"></a>Allow Alt+Drag in windows</h2><p>I created a file “C:\Users\XX\AppData\Roaming\Sublime Text 3\Packages\User\Default (Windows).sublime-mousemap”, and put this in it:</p><pre><code>[  {    &quot;button&quot;: &quot;button1&quot;,&quot;modifiers&quot;: [&quot;alt&quot;],    &quot;press_command&quot;: &quot;drag_select&quot;,    &quot;press_args&quot;: {&quot;by&quot;: &quot;columns&quot;}  },]</code></pre><p>restart Sublime</p>]]></content>
      
      
        <tags>
            
            <tag> sublime </tag>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>net-EventIOSerialize</title>
      <link href="/2018/06/25/net-EventIOSerialize/"/>
      <url>/2018/06/25/net-EventIOSerialize/</url>
      <content type="html"><![CDATA[<h2 id="EVENT"><a href="#EVENT" class="headerlink" title="EVENT"></a>EVENT</h2><p>假如现在有一个猫类型，它叫一声会引发一连串反应，诸如</p><pre><code class="c#">public class Cat{    public void Miao()    {        new Neighbor().Awake();        new Dog().Bark();        new Mouse().Run();        new Baby().Cry();    }}</code></pre><p>这样的写法会导致耦合性高，不易扩展，增加，减少或者调整顺序都会变得比较困难，最好是猫叫一声-&gt;触发一系列的动作</p><p><strong>用委托的方法实现</strong></p><a id="more"></a><pre><code class="c#">//这个MiaoEventHandler来指定一堆动作//委托MiaoEventHandler来定义动作，Cat就不管了，Cat就不依赖于里面的动作了public class Cat{    public Action MiaoEventHandler;    public void MiaoAction()    {        if(this.MiaoEventHandler != null)        {            this.MiaoEventHandler.Invoke();        }    }}//callerstatic void Main(string[] args){    {        //Event        Cat cat = new Cat();        cat.Miao();        //委托的时候只能加方法名，而不是调用，所以不是Awake()        //带有参数的方法的调用，就可以用lambda来完成        //这就是多播委托的一种使用，注意，多播委托是不适用于带返回值的委托的，因为到最后只会取最后一个委托的返回值！        cat.MiaoEventHandler += () =&gt; new Neighbor().Awake(123);        cat.MiaoEventHandler += new Dog().Bark;        cat.MiaoEventHandler += new Mouse().Run;        cat.MiaoEventHandler += new Baby().Cry;        cat.MiaoAction();    }}</code></pre><p><strong>用事件的方法实现</strong></p><p>Event就是Action委托前面加event关键字，防止外部直接invoke和赋值，子类都没有办法Invoke</p><p><strong>事件和委托的区别联系：</strong><br><span style="color: red">事件是委托的实例，委托是一个类型，而事件是一个实例，委托类型的实例</span><br>例：Student是一个类型，而Dashan是Student类型的一个实例</p><pre><code class="c#">public event Action MiaoEventHandlerEvent;public void MiaoActionEvent(){    if(this.MiaoEventHandlerEvent != null)    {        this.MiaoEventHandlerEvent.Invoke();    }}</code></pre><p><strong>为什么要有event?</strong><br>就是为了这个MiaoEventHandler不能在外部被调用被赋值</p><p>在上面的那个例子，<code>MiaoEventHandler</code>是可以在中间被invoke和赋值的，比方说</p><pre><code class="c#">cat.MiaoEventHandler += () =&gt; new Neighbor().Awake(123);cat.MiaoEventHandler += new Dog().Bark;//这样是可以的cat.MiaoEventHandler.Invoke();cat.MiaoEventHandler = null;cat.MiaoEventHandler += new Mouse().Run;cat.MiaoEventHandler += new Baby().Cry;</code></pre><p><span style="color: red">但是如果用了Event，就不可以在中间被赋值，只能在Cat类的MiaoActionEvent里面去调用</span></p><h2 id="EVENT的应用"><a href="#EVENT的应用" class="headerlink" title="EVENT的应用"></a>EVENT的应用</h2><p>事件的应用一定会有<br>1，事件的发布者，在这里用来Invoke事件<br>2，事件的订阅用户<br>3，事件的注册</p><pre><code class="c#">//这个是事件的发布者，只有事件的发布者才能Invoke这个事件public class iPhone8{    //EventHandler&lt;PriceChangeEventArgs&gt;是事件的委托类型， PriceChange是事件名称    public event EventHandler&lt;PriceChangeEventArgs&gt; PriceChange;    protected virtual void OnPriceChanged(PriceChangeEventArgs e)    {        if (this.PriceChange != null)        {            this.PriceChange.Invoke(this, e);        }    }    private decimal price;    public decimal Price    {        get {return price;}        set         {            if(price == value)                return;            decimal oldPrice = price;            price = value;            if(this.PriceChange != null)                this.OnPriceChanged(new PriceChangeEventArgs(oldPrice, price));        }    }}//EventHandler是框架帮我们定义的，专门用来作事件用//sender是事件的触发者, e的类型是泛型，也就是TEventArgs类型，一般这个类型在定义的时候必须继承于EventArgspublic delegate void EventHandler&lt;TEventArgs&gt;(object sender, TEventArgs e);//EventArgs其实就是个空壳,但是你可以继承它之后自己自定义一些属性public class EventArgs{    public static readonly EventArgs Empty;    public EventArgs();}//PriceChangeEventArgspublic class PriceChangeEventArgs: EventArgs{    public int Id {get;set;}    public readonly decimal OldPrice;    public readonly decimal NewPrice;    public PriceChangeEventArgs(decimal oldPrice, decimal newPrice)    {        OldPrice = oldPrice;        NewPrice = newPrice;    }}//事件订阅者public class Businessman{    public void Iphone8_PriceChange(object sender, PriceChangeEventArgs e)    {        Console.WriteLine(&quot;年终大促,iphone只卖&quot; + e.NewPrice + &quot;元！&quot;);    }}//事件的注册public class EventRegister{    private iPhone8 _iphone = null;    public void Init()    {        this._iphone = new iPhone8();        Businessman businessman = new Businessman();        this._iphone.PriceChange += businessman.Iphone8_PriceChange;    }    public void SetPrice(decimal price)    {        this._iphone.Price = price;    }}</code></pre><h2 id="IO-Serialize"><a href="#IO-Serialize" class="headerlink" title="IO Serialize"></a>IO Serialize</h2><pre><code class="c#">//检查文件夹是否存在if(!Directory.Exists(LogPath)){    //一次性创建全部的子路径    DirectoryInfo directoryInfo = Directory.CreateDirectory(LogPath);    //原文件夹会没有    Directory.Move(LogPath, LogMovePath);    Directory.Delete(LogMovePath);}//不能用这个检查文件夹是否存在Directory directory = new DirectoryInfo(LogPath);FileInfo fileInfo = new FileInfo(Path.Combine(LogPath,&quot;info.txt&quot;));if(!File.Exists(Path.Combine(LogPath, &quot;info.txt&quot;))){    Directory.CreateDirectory(LogPath);    //打开文件流（创建文件并写入）    using(FileStream fileStream = File.Create(fileName))    {        string name = &quot;111&quot;;        byte[] bytes = Encoding.Default.GetBytes(name);        fileStream.Write(bytes, 0 , bytes.Length);        fileStream.Flush();    }    //打开文件流（创建文件并写入）,这个File.Create会把之前的文件删掉，重新写    using(FileStream fileStream = File.Create(fileName))    {        StreamWriter sw = new StreamWriter(fileStream);        sw.Write(&quot;123&quot;);        sw.Flush();    }    //流写入器（创建/打开文件并写入）    using(StreamWriter sw = File.AppendText(fileName))    {        string msg = &quot;Today is a good day.&quot;;        sw.WriteLine(msg);        sw.Flush();    }    //流写入器(创建/打开文件并写入)    using(StreamWriter sw = File.AppendText(fileName))    {        string name = &quot;12312&quot;;        byte[] bytes = Encoding.Default.GetBytes(name);        sw.BaseStream.Write(bytes,0,bytes.Length);        sw.Flush();    }    //读取,    //一次性读所有的数据，不推荐    foreach(var result in File.ReadAllLines(fileName))    {        Console.WriteLine(result);    }    string sResult = File.ReadAllText(fileName);    Byte[] byteContent = File.ReadALlBytes(fileName);    string sResultByte = System.Text.Encoding.UTF8.GetString(byteContent);    //分批读取，比较好    using(FileStream stream = File.OpenRead(fileName))    {        int length = 5;        int result = 0;        do         {            byte[] bytes = new byte[length];            result = stream.Read(bytes,0,5);            for(int i=0; i&lt; result; i++)            {                Console.WriteLine(bytes[i].TOString());            }        }        while(length == result);    }}//写日志public static void Log(string msg){    StreamWriter sw = null;    try    {        string fileName = &quot;log.txt&quot;;        string totalPath = Path.Combine(LogPath, fileName);        if(!Directory.Exists(LogPath))        {            Directory.Create(LogPath);        }        sw = File.AppendText(totalPath);        sw.WriteLine(string.Format(&quot;{0}:{1}&quot;,DateTime.Now,msg));        sw.WriteLine(&quot;**************************************&quot;)；    }    catch(Exception ex)    {        Console.WriteLine(ex.Message);    }    finally    {        if(sw != null)        {            sw.Flush();            sw.Close();            sw.Dispose();        }    }}</code></pre><h2 id="画验证码"><a href="#画验证码" class="headerlink" title="画验证码"></a>画验证码</h2><pre><code class="c#">public static void Drawing(){    Bitmap bitmapobj = new Bitmap(100, 100);    //在Bitmap上面创建一个新的Graphics对象    Graphics g = Graphics.FromImage(bitmapobj);    //创建绘画对象，如Pen,Brush等等    Pen redPen = new Pen(Color.Red,8);    g.Clear(Color.White);    //绘制图形    g.DrawLine(redPen,50,20,500,20);    //画椭圆    g.DrawEllipse(Pens.Black, new Rectangle(0,0,200,100));    //画弧线    g.DrawArc(Pens.Black,new Rectangle(0,0,100,100),60,180);    //画直线    g.DrawLine(Pens.Black,10,10,100,100);    //画矩形    g.DrawRectangle(Pens.Black,new Rectangle(0,0,100,200));    //画字符串    g.DrawString(&quot;I love coding&quot;,new Font(&quot;Arial&quot;,12),new SolidBrush(Color.Red),new PointF(10,10));    If(!Directory.Exists(ImagePath))    {        Directory.CreateDirectory(ImagePath);    }    bitmapobj.Save(ImagePath+&quot;pic1.jpg&quot;,ImageFormat.Jpeg);    bitmapobj.Dispose();//释放所有对象    g.Dispose();}</code></pre>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>net-delegate</title>
      <link href="/2018/06/22/net-delegate/"/>
      <url>/2018/06/22/net-delegate/</url>
      <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p><code>public delegate string WithReturnWithPara(int x, int y);</code>没有方法体的方法声明+delegate</p><p>委托其实就是MulticastDelegate的一个<strong>子类</strong>，是一个<strong>类</strong>！</p><pre><code class="c#">public delegate void NoReturnNoPara();public delegate void NoReturnWithPara(int x, int y);public delegate int WithReturnNoPara();public delegate void GenericDelegate(T x); //泛型委托public void Show(){    {        //2. 实例化委托，要求传入的签名一致的方法        NoReturnNoPara method = new NoReturnNoPara(this.DoNothing);        //3. 委托实例的调用，参数和委托声明的时候参数一致        method.Invoke();        //4. 与上面的Invoke效果是一样的        method();    }    {        NoReturnWithPara method = new NoReturnWithPara(this.DoNothingWithPara);        method.Invoke(1,2);    }    {        WithReturnNoPara method = new WithReturnNoPara(this.GetNothing);        int iResult = method.Invoke();    }}private void DoNothing(){    Console.WriteLine(&quot;This is DoNothing&quot;);}private void DoNothingWithPara(int x, int y){}private int GetNothing(){    return 1;}</code></pre><p>##.NET自带的一些委托类型</p><p>####Action -&gt; 无返回值的委托</p><pre><code class="c#">Action act = new Action(this.DoNothing);Action&lt;int,string,int,string&gt; act2 = null;</code></pre><p>####Func -&gt; 带返回值的泛型委托，注意，最后一个泛型类型代表返回类型</p><pre><code class="c#">Func&lt;int&gt; fun1 = new Func&lt;int&gt;(this.GetNothing);//返回一个int类型Func&lt;int,string&gt; fun2 = null; //接受一个int类型的参数，返回类型为string</code></pre><p>####多播委托 -&gt;<br>+=表示向一个委托实例里面添加多个方法，形成方法链，invoke的时候按添加顺序执行<br>-=表示向一个委托实例里面移除方法，从方法链尾部开始匹配，遇到第一个完全吻合的，移除且只移除一个；没有匹配的不报错</p><p><strong>如果是用lambda表达式来定义方法，那么永远都无法-=，因为编译器碰到lambda表达式，会自动生成一个委托，都是不同的实例</strong></p><p><strong>多播委托<span style="color: red">不适用于带返回值的委托</span>&gt;带返回值的委托，因为到后面只会拿最后一个委托的返回值</strong></p><pre><code class="c#">Action act = new Action(this.DoNothing);act += this.DoNothing;act += this.DoNothingStatic;act += new OtherClass().DoNothing;//act.BeginInvoke(null, null);//不能调用，因为不知道里面这么多实例应该按照什么顺序去执行foreach(Action item in act.GetInvocationList()){    item.BeginInvoke(null,null);}act -= this.DoNothing;act -= this.DoNothingStatic;act -= new OtherClass().DoNothing; //你会发现这个方法没有被移除，原因是上面的act += new OtherClass()与这个是两个实例，不是同一个，所以没有移除</code></pre><p>##委托的使用</p><pre><code class="c#">private static List&lt;Student&gt; Where(List&lt;Student&gt; studentList, Func&lt;Student, bool&gt; func){    list&lt;Student&gt; resultList = new List&lt;Student&gt;();    foreach(var student in studentList)    {        if(func.invoke(student))        {            resultList.Add(student);        }    }}//callerprivate static bool Equals(Student){    return student.ClassId == 1;} Func&lt;Student,bool&gt; func = new Func&lt;Student,bool&gt;(Equals);var list = Where(studentList, func);</code></pre>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>net-oo</title>
      <link href="/2018/06/22/net-oo/"/>
      <url>/2018/06/22/net-oo/</url>
      <content type="html"><![CDATA[<p>##封装就是写类</p><p>封装的好处:</p><ul><li>保护属性，通过访问修饰符(public, private(只能自己访问，子类都不行),internal(只能这个程序集里面访问),protected(只能自己和子类访问))</li><li>接口不变，可以随便扩展</li><li>代码重用，任何只要用了这个类都可以调用这个方法</li></ul><p>##继承，就是可以用父类的</p><p>##多态：同一个东东运行的时候会展现不同的形态</p><ol><li>继承多态：<pre><code class="c#">//编译器编译的时候认为这三个都是People类型//但在运行的时候people, student, teacher是三种不同的类型People people = new People();People student = new Student();People teacher = new Teacher();</code></pre></li><li>编译时多态:<br> 声明，接口<br> 方法的重载(overload)也是多态<br> <span style="color: red;">普通方法的调用</span><pre><code> 注意：`Parent ins = new Child(); ins.Method();`会调用的是父类方法，因为这是编译时确定的！！！</code></pre></li></ol><ol><li><p>运行时多态<br> 抽象方法与虚方法的区别：</p><pre><code> 虚方法本身是一个普通方法，但是加了一个virtual，子类继承的时候可以覆写也可以不覆写 抽象方法没有方法体，必须在一个抽象类里面定义，子类继承后，必须显性的override掉这个抽象类</code></pre><p> 在override之前加<code>sealed</code>代表不想让它的子类再覆写</p><p> <span style="color: red;"><code>new</code>这种写法尽量不要用！改成虚方法</span></p></li></ol><pre><code class="c#">public abstract class ParentClass{    public int age = 70;    public void CommonMethod()    {        Console.WriteLine(&quot;ParentClass CommonMethod&quot;);    }    //虚方法本身是一个普通方法，但是加了一个virtual    //子类继承的时候可以覆写也可以不覆写    public virtual void VirtualMethod()    {        Console.WriteLine(&quot;ParentClass VirtualMethod&quot;);    }    public virtual void VirtualMethod(string name)    {        Console.WriteLine(&quot;ParentClass VirtualMethod with string name&quot;);    }    //抽象方法没有方法体，必须在一个抽象类里面定义    //子类继承后，必须显性的override掉这个抽象类    public abstract void AbstractMethod();}public class ChildClass: ParentClass{    public int age  = 18;    //这里隐藏父类的CommonMethod,并没有覆盖掉    public new void CommonMethod()    {        Console.WriteLine(&quot;ChildClass CommonMethod&quot;);    }    public override void VirtualMethod()    {        Console.WriteLine(&quot;ChildClass VirtualMethod&quot;);        base.VirtualMethod();    }    public override void AbstractMethod()    {        Console.WriteLine(&quot;ChildClass AbstractMethod&quot;);    }}//callerpublic static void Test(){    ParentClass instance = new ChildClass();    //父类，age=70    Console.WriteLint(instance.age);    //父类,编译的时候决定了普通方法的调用，只根据等号左边来看，ChildClass里面的new一点用都没有    instance.CommonMethod();    //子类，虽然最终调用的是父类，运行的时候决定了虚方法的调用    instance.VirtualMethod();    //子类,运行时决定了抽象方法的调用    instance.AbstractMethod();}</code></pre><p>##接口抽象类</p><p>什么方法适用于虚方法：<br>    大家都有默认实现，只有少部分不同，建议采用虚方法<br>其他用abstract方法：<br>    抽象方法就是约束一下，但是不提供实现，子类必须override，且必须在抽象类里面</p><pre><code>**抽象类是不能实例化的**，只能这么用```c#BasePhone iphone = new iPhone();public abstract class BasePhone{}```</code></pre><p>除了可以用抽象类来约束，也可以用接口来约束,接口方法默认都是public，且不能放字段（可以放属性）</p><pre><code class="c#">public interface IExtend{    void Online();    string Remark{get;set;}    event Action DoNothingHandle;    //索引器    string this[int index]{get;set;}    //string description; 不能    //delegate xxx;不能}</code></pre><p>抽象类和接口区别，想约束东西的时候是用抽象类还是接口？</p><ul><li>抽象类可以包含一些已经实现的东西，然后可以再加上约束的功能，其主要是类，加上一点约束的功能，表明的主要是is a what</li><li>接口更灵活，一个类可以继承多个接口，纯粹的约束功能。只能表明can do what,不局限于是哪个类</li></ul><p>工作中大部分用的都是接口，除非有些代码需要重用会要用抽象类 </p>]]></content>
      
      
        <tags>
            
            <tag> .NET </tag>
            
            <tag> concet </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>net-attribute</title>
      <link href="/2018/06/21/net-attribute/"/>
      <url>/2018/06/21/net-attribute/</url>
      <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Attribute其实是为了生成MetaData的<br>Attribute就是一个继承于Attribute的类</p><pre><code class="c#">public class CustomAttribute: Attribute{    public CustomAttribute(){        Console.WriteLine(&quot;This is constructor of CustomAttribute&quot;);    }    public CustomAttribute(string remark){    }    public string Remark{get;set;}    public string Description{get;set;}    public void Show(){        Console.Writeline($&quot;This is {this.GetType().Name}&quot;);    }}//也可以间接继承于Attributepublic class CustomChildAttribute: CustomAttribute{}</code></pre><a id="more"></a><p>Attribute默认情况下不能重复修饰</p><p>Attribute可以放在类，方法，属性，字段等很多地方，在<code>[AttributeUsage(AttributeTargets.All, AllowMultiple=False)]</code>中设置</p><p><code>[Custom] = [Custom()]</code>,代表默认用无参构造函数<br><code>[Custom(&quot;This is a student&quot;, Remark=&quot;123&quot;, Description=&quot;567&quot;)]</code>  构造函数的时候顺便把属性都赋值</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>特性在你不显式调用的时候，一点用都没有<br>特性是通过反射来使用的</p><pre><code class="c#">///特性编译后是metadata，只有反射才能使用///public class PeopleManager{    public static void Manage(Student student){        Type type = student.GetType();        //type.GetCustomAttributes会实例化这个特性        if(type.IsDefined(typeof(CustomAttribute),true)){            object item = type.GetCustomAttributes(typeof(CustomAttribute),true)[0];            CustomAttribute attribute = item as CustomAttribute;            attribute.Show();        }        foreach(var item in type.GetConstructors()){            if(item.IsDefined(typeof(CustomAttribute),true)){                object ii = item.GetCustomAttributes(typeof(CustomAttribute),true)[0];            }        }        MethodInfo method = type.GetMethod(&quot;Answer&quot;);        if(method.IsDefined(typeof(CustomAttribute),true)){            object item = method.GetCustomAttributes(typeof(CustomAttribute),true)[0];        }        foreach(var item in method.GetParameters()){        }        if(method.ReturnParameter.IsDefined(typeof(CustomAttribute),true)){        }        student.Study();        student.Answer(&quot;SS&quot;);    }}</code></pre><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><pre><code class="c#">public class Student{    [AuthoritytAttribute(Remark=&quot;Answer Questions&quot;)]    [Custom]    [return: Custom]    public string Answer([Custom]string name){        return $&quot;This is {name}&quot;    }}public class AuthoritytAttribute:Attribute{    public string Remark {get;set;}    public bool IsLogin(){        return new Random().Next(100,200) &gt; new Random().Next(100,199);    }}public class PeopleManager{    public static void Manage(Student student){        //Attribute可以增加功能，也可以多一点信息（Remark)        Type type = typeof(Student);        MethodInfo method = method.GetMethod(&quot;Answer&quot;);        if(method.IsDefined(typeof(AuthoritytAttribute),true)){            object item = type.GetCustomAttributes(typeof(AuthoritytAttribute),true)[0];            AuthoritytAttribute attribute = item as AuthoritytAttribute;            Console.WriteLine(attribute.Remark);            // if(DateTime.Now &gt; DateTime.Now.AddDaus(1))//实际上可以使用HttpContext.Current.Cookie/Session来检查用户登陆信息            // {            //     throw new Exception(&quot;Not authorized&quot;); //redirect to login page            // }            //将权限认证放到了attribute中            if(!attribute.IsLogin()){                throw new Exception(&quot;Not authorized&quot;);            }        }        student.Answer(&quot;SS&quot;);    }}//Callerclass Program{    static void Main(string[] args){        Student studnet = new Student();        //这个方法调用是不会call AuthorityAttribute的        student.Answer(&quot;SS&quot;);        //这样写才会支持AuthorityAttribute        PeopleManager.Manage(student);    }}</code></pre><p>实例</p><pre><code class="c#">[AttributeUsage(AttributeTargets.Enum | AttributeTargets.Field)]public class RemarkAttribute: Attribute{    public RemarkAttribute(string remark)    {        this.Remark = remark;    }    public string Remark{get;set;}}[Remark(&quot;用户状态&quot;)]public enum UserState{    [Remark(&quot;正常&quot;)]    Normal = 0,    [Remark(&quot;冻结&quot;)]    Forzen = 1,    [Remark(&quot;删除&quot;)]    Deleted = 2}public class RemarkExtend{    //扩展方法    public static string GetRemark(this Enum enumValue){        Type type = enumValue.GetType();        FieldInfo field = type.GetField(enumValue.ToString());        if(field.IsDefined(typeof(RemarkAttribute),true)){            RemarkAttribute remarkAttribute = (RemarkAttribute)field.GetCustomAttribute(typeof(RemarkAttribute));        return remarkAttribute.Remark;        }else{            return enumValue.ToString();        }    }}//callerpublic void Main(string[] args){    UserState.Deleted.GetRemark();}</code></pre>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux文本处理sed,awk,cut,sort</title>
      <link href="/2018/06/20/linux-file-processing-commands/"/>
      <url>/2018/06/20/linux-file-processing-commands/</url>
      <content type="html"><![CDATA[<h2 id="CUT"><a href="#CUT" class="headerlink" title="CUT"></a>CUT</h2><p>CUT命令可以从一个文本文件或者文本流中提取文本<br><code>echo $PATH | cut -d &#39;:&#39; -f 2,3</code>将PATH变量取出，返回第二，第三个路径<br><code>echo $PATH | cut -d &#39;:&#39; -f 1-3,5</code>取1~3和第五个</p><h2 id="SORT"><a href="#SORT" class="headerlink" title="SORT"></a>SORT</h2><p>对FILE参数制定的文件中的行排序，并将结果写到标准输出</p><pre><code>[root@ip-172-31-7-202 ec2-user]# cat /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/sync[root@ip-172-31-7-202 ec2-user]# cat /etc/passwd | sortadm:x:3:4:adm:/var/adm:/sbin/nologinbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologindbus:x:81:81:System message bus:/:/sbin/nologinec2-user:x:500:500:EC2 Default User:/home/ec2-user:/bin/bash[root@ip-172-31-7-202 ec2-user]# cat /etc/passwd | sort -t &#39;:&#39; -k 3 //以：为分隔符，以第三列字符串模式为排序标准root:x:0:0:root:/root:/bin/bashuucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologinbin:x:1:1:bin:/bin:/sbin/nologin[root@ip-172-31-7-202 ec2-user]# cat /etc/passwd | sort -t &#39;:&#39; -k 3n //以第三列数字模式排序root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin[root@ip-172-31-7-202 ec2-user]# cat /etc/passwd | sort -t &#39;:&#39; -k 3nr //倒序排列nfsnobody:x:65534:65534:Anonymous NFS User:/var/lib/nfs:/sbin/nologinec2-user:x:500:500:EC2 Default User:/home/ec2-user:/bin/bashsaslauth:x:499:76:&quot;Saslauthd user&quot;:/var/empty/saslauth:/sbin/nologinnobody:x:99:99:Nobody:/:/sbin/nologin[root@ip-172-31-7-202 ec2-user]# cat /etc/passwd | sort -t &#39;:&#39; -k 7 -u //去重root:x:0:0:root:/root:/bin/bashsync:x:5:0:sync:/sbin:/bin/synchalt:x:7:0:halt:/sbin:/sbin/haltbin:x:1:1:bin:/bin:/sbin/nologinshutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</code></pre><h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><p>uniq只能去重排序过的文件</p><pre><code>cat testfile | sort | uniq -c //-c显示重复次数1 friend3 hello2 world</code></pre><p>取出处于ESTABLISHED状态的端口号</p><pre><code>netstat -an | grep &#39;:4001\|:4002\|:4003\|:4004&#39; | grep ESTABLISHED | awk {&#39;print $4&#39;} | uniq | cut -d &#39;:&#39; -f 2 </code></pre><h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><h3 id="删除：d命令"><a href="#删除：d命令" class="headerlink" title="删除：d命令"></a>删除：d命令</h3><p><code>sed -i &#39;2d&#39; example</code> 删除example文件的第二行并写会原文件，不建议刚开始就用-i写回文件，调试完了以后再加-i<br><code>sed &#39;2,$d&#39; example</code> 删除example文件的第二行到末尾所有行，正则中$表示末尾，^表示开头<br><code>sed &#39;$d&#39; example</code> 删除example文件的最后一行<br><code>sed &#39;/test/&#39;d example</code> 删除example文件所有包含test的行,//代表模式</p><h3 id="替换：s命令"><a href="#替换：s命令" class="headerlink" title="替换：s命令"></a>替换：s命令</h3><p><code>sed &#39;s/test/mytest/g&#39; example</code> 在整行范围内把test替换成mytest，如果没有g标记，则只有每行第一个匹配的test会被替换成mytest<br><code>sed -n &#39;s/^test/mytest/p&#39; example</code> (-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说如果某一行开头的test被替换成mytest，就打印它。<br><code>sed &#39;s/^192.168.0.1/&amp;localhost/&#39; example</code> &amp;符号表示替换字符串被找到的部分再加上新的。所有以192.168.0.1开头的行都会被替换成它自己加localhost，即192.168.0.1localhost。<br><code>sed -n &#39;s/\(love\)able/\1rs/p&#39; example</code> love被标记为1，所有loveable会被替换成lovers，且替换的行会被打印出来，\1代表第一组    </p><h2 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h2><p><code>last -n 5 | awk &#39;{print $1}&#39;</code> 打印出第一列的登录人名<br>awk工作流程：读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0表示所有域，$1表示第一个域，$n表示第n个域。<br>默认域分隔符是”空白键”或者”[tab]键”,所以$1表示登录用户，$3表示登录用户ip,以此类推</p><p><code>cat /etc/passwd | awk -F &#39;:&#39; &#39;{print $1&quot;\t&quot;$7}&#39;</code>指定分隔符,且账户与shell之间以tab键分割</p><p><code>cat /etc/passwd | awk -F &#39;:&#39; &#39;BEGIN {print &quot;name,shell&quot;} {print $1&quot;,&quot;$7} END {print &quot;endtest,/bin/bash&quot;}&#39;</code><br>awk还可以分Begin 中间 End三个部分</p><p><code>lxc list | awk &#39;NR &gt; 2 { print $6}&#39;</code>去除首行，拿取第6列</p><pre><code>[root@ip-172-31-7-202 ec2-user]# cat /etc/passwd | awk -F &#39;:&#39; &#39;BEGIN {print &quot;name,shell&quot;} {print $1&quot;,&quot;$7} END {print &quot;endtest,/bin/bash&quot;}&#39;name,shellroot,/bin/bashbin,/sbin/nologindaemon,/sbin/nologinadm,/sbin/nologinlp,/sbin/nologinsync,/bin/syncshutdown,/sbin/shutdownhalt,/sbin/haltmail,/sbin/nologinuucp,/sbin/nologinoperator,/sbin/nologingames,/sbin/nologingopher,/sbin/nologinftp,/sbin/nologinnobody,/sbin/nologinrpc,/sbin/nologinntp,/sbin/nologinsaslauth,/sbin/nologinmailnull,/sbin/nologinsmmsp,/sbin/nologinrpcuser,/sbin/nologinnfsnobody,/sbin/nologinsshd,/sbin/nologindbus,/sbin/nologinec2-user,/bin/bashmysql,/bin/bashendtest,/bin/bash</code></pre>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Shell 基本语法</title>
      <link href="/2018/06/20/shell-basic/"/>
      <url>/2018/06/20/shell-basic/</url>
      <content type="html"><![CDATA[<h2 id="test-sh-两个点的含义"><a href="#test-sh-两个点的含义" class="headerlink" title=". ./test.sh 两个点的含义"></a>. ./test.sh 两个点的含义</h2><pre><code>#!/bin/bashaa = &quot;hello&quot;</code></pre><p>如果<code>echo $aa</code>是没有东西的，为什么？</p><p>当只运行一个    <code>./test.sh</code> 的时候,其实是test.sh是在别的进程里面跑的，所以你在当前进程里跑的时候是不会输出东西的<br>所以用<code>. ./test.sh</code>是说在我现在这个进程里面来跑这个脚本</p><h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><pre><code>1，系统变量：$HOME、$PWD、$SHELL(现在用的是哪种解释器)、$USER(当前用户)等2，查看所有变量:`set`3，定义变量：VAR=value，&lt;span style=&quot;color:red;&quot;&gt;等号两侧不能有空格&lt;/span&gt;，变量名称一般为大写 4，双引号与单引号的区别：双引号仅将空格脱意，单引号会将所有特殊字符脱意(单引号里面用变量引用没有用)     ```    X=hello    echo $X -&gt; hello    X=&quot;hello world&quot;    echo $X -&gt; hello world    X=&#39;hello\nworld&#39;    echo $X -&gt; hello\nworld    Y=abc    X=&#39;hello $Y&#39;    echo $X -&gt; hello $Y    X=&quot;hello $Y&quot;    echo $X -&gt; hello abc    ```5，撤销变量：unset X6，export：可以把变量提升为全局环境变量，所有连上去的BASH都能访问，否则只在当前的bash能用7，&lt;span style=&quot;color:red;&quot;&gt;把当前command的结果赋予另一个变量&lt;/span&gt;    1，用A=`ls -la`反引号的形式    2，用A=$(ls -la)，等价于上面的方式    ```    X=&quot;Hello;World;SS&quot;    echo $X | cut -d &quot;;&quot; -f2  //拿到以；为分隔符切分的第二个元素    Y=`echo $X | cut -d &quot;;&quot; -f2`    echo $Y -&gt; World    ```8，Shell中的特殊变量    1，$? 上一个命令执行的状态，类似与方法的返回值，通常情况下返回值为0代表成功，非0代表不正常        ```        true        echo $? -&gt; 0        false        echo $? -&gt; 1        ll        echo $? -&gt; 0        lsss        echo $? -&gt; 127        ```    2，$$ 表示当前进程号    3，$0 表示当前脚本名称    4，$N 表示N位置的输入参数        ```        #!/bin/bash        aa=&quot;hello&quot;        echo &quot;第一个参数=&quot;$1        echo &quot;第二个参数=&quot;$2        ./test.sh hello world        第一个参数=hello        第二个参数=world        ```    5，$# 表示参数的个数，常用于循环    6，$*和$@都表示参数列表        &quot;$*&quot;会将所有的参数作为一个整体，以&quot;$S1$S2...$Sn&quot;的形式输出        &quot;$@&quot;会将各个参数分开，以&quot;$S1&quot;&quot;$S2&quot;...&quot;$Sn&quot;的形式输出        ```        #!/bin/bash        echo $*        echo $@        for N in &quot;$*&quot;        do        echo $N        done        for N in &quot;$@&quot;        do        echo $N        done        ```</code></pre><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>格式：expr m+n 或者 $((m+n)) 注意expr运算符间要有空格<br>例如（2+3）*4</p><pre><code>S=`expr 2+3`\*4 或者 $(((2+3)*4)),最外层的$()代表取其值</code></pre><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><pre><code>for N in 1 2 3do    echo $Ndone或者 for N in {1..3};do echo $N;done或者for ((i=0;i&lt;=5;i++)) //必须要是两层括号do    echo &quot;welcome $i times&quot;done</code></pre><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><pre><code>while expressiondo     commanddone或者int=1while ((int&lt;=3))do    echo $int    let int++done</code></pre><h2 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h2><pre><code>case $1 instart)    echo &quot;starting&quot;    ;;stop)    echo &quot;stoping&quot;    ;;*)    echo &quot;Usage:{start|stop}&quot;esac</code></pre><h2 id="read命令"><a href="#read命令" class="headerlink" title="read命令"></a>read命令</h2><pre><code>read -p &quot;please enter a number: &quot; numbplease enter a number:  1echo $numb1</code></pre><h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><pre><code>if [ $NAME=root ]then    echo &quot;hello ${NAME}&quot;elif [ $NAME=itcast ]    then        echo &quot;hello ${NAME}&quot;else    echo &quot;OUT&quot;fi</code></pre><p>[ condition ]一定要前后有空格，空[  ]则返回1，即false</p><h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p>[ condition ] &amp;&amp; echo OK || echo notok<br>= 字符串比较<br>-lt 小于<br>-le 小于等于<br>-eq 等于<br>-gt 大于<br>-ge 大于等于<br>-ne 不等于<br>-r     有读的权限<br>-w     有写权限<br>-f     文件存在并且是一个常规的文件<br>-s     文件存在且不为空<br>-d     文件存在并且为一个目录<br>-b     文件存在并且是一个块设备<br>-L     文件存在并且是一个链接</p><h2 id="Shell-自定义函数"><a href="#Shell-自定义函数" class="headerlink" title="Shell 自定义函数"></a>Shell 自定义函数</h2><pre><code>[ function ] funname [()]{    action;    [return int;]}例如可以这样定义function start() / function start/ start()函数只能返回int类型如果要传入参数，需要在外面定义!#/bin/bashfunction fSum(){    echo $1,$2;    return $(($1+$2));}fSum 3 2;total=$?;fSum 5 7;total=$?;echo $total, $?;</code></pre><h2 id="脚本调试"><a href="#脚本调试" class="headerlink" title="脚本调试"></a>脚本调试</h2><p><code>sh -vx helloWorld.sh</code> 只会展现所有的执行状态，不会停</p><h2 id="模拟用户输入"><a href="#模拟用户输入" class="headerlink" title="模拟用户输入"></a>模拟用户输入</h2><pre><code class="bash">auto_ssh_copy_id() {    expect -c &quot;set timeout -1;        spawn ssh-copy-id $1;        expect {            *(yes/no)* {send -- yes\r;exp_continue;}            *assword:* {send -- $2\r;exp_continue;}            eof           {exit 0;}        }    &quot;;}ssy_copy_id_to_all() {    for SERVER in $SERVERS    do        auto_ssh_copy_id $SERVER $PASSWORD    done    }</code></pre>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>css-basic</title>
      <link href="/2018/06/16/css-basic/"/>
      <url>/2018/06/16/css-basic/</url>
      <content type="html"><![CDATA[<h1 id="布局-传统display-position-float"><a href="#布局-传统display-position-float" class="headerlink" title="布局(传统display+position+float)"></a>布局(传统display+position+float)</h1><h2 id="Display"><a href="#Display" class="headerlink" title="Display"></a>Display</h2><p>1,    <code>block</code>占一行<br>    默认<code>block</code>的元素有：<br>    <code>div p ul ol li h1 h2 h3 h4 h5 h6</code><br>2,    <code>inline</code>只占其content的尺寸，如果没有content，就不会显示<br>3，    <code>inline-block</code>是inline的布局，就是都挤在一行（对外的表现），对内表现为block,就是可以像block元素一样设置宽高等（盒模型数据）</p><h2 id="Position"><a href="#Position" class="headerlink" title="Position"></a>Position</h2><p>1,    <code>static</code> 就是默认的元素定位<br>2,    <code>relative</code> 相对于<span style="color: red;font-weight: bold;">自己原本的位置</span>,比方说几次方这个东西，就可以用relative来做</p><p>如果你不给Relative设置<code>top left bottom right</code>, 就相当于什么也没发生过，它就是默认的位置</p><p>另外如果你设置了它为relative，就相当于给予了它<code>z-index</code>的能力</p><pre><code class="css">.square {    position: relative;    top : -1px;    left : 1px;}</code></pre><a id="more"></a><p>3,    <code>absolute</code>    完全绝对定位，一样可以设置<code>top left bottom right</code>,但是这些值是以其找到的最近的非static父元素为基准。 如果没有这样的父元素， 它就会以<code>&lt;html&gt;</code>为父元素.</p><p>关于<code>absolute</code>与<code>relative</code>:</p><img src="/2018/06/16/css-basic/absolute-inside-relative.png"><img src="/2018/06/16/css-basic/absolute-inside-relative2.png"><p>4,    <code>fixed</code>    基于window的绝对定位，不随页面滚动发生改变</p><h2 id="Margin缩写"><a href="#Margin缩写" class="headerlink" title="Margin缩写"></a>Margin缩写</h2><p>三种：</p><pre><code>margin:    top right bottom leftmargin:    (top/bottom)    (right/left)margin: top    (right/left)    bottom</code></pre><h2 id="Float-amp-Clear"><a href="#Float-amp-Clear" class="headerlink" title="Float &amp; Clear"></a>Float &amp; Clear</h2><p>float元素只占自己元素的大小，如果只让一边float会发现原本应该另起一行的div会浮动到其左边</p><img src="/2018/06/16/css-basic/float1.png"><p>如果第二个元素也变为float，父元素会消失</p><img src="/2018/06/16/css-basic/float2.png"><p><code>Clear</code> property specifies what elements can float beside the cleared element and on which side.</p><pre><code>* none    - Allows floating elements on both sides(default)* left/right    - No floating elements allowed on the left/right side* inherit    - Inherits the clear value of its parent</code></pre><p>如果一个元素float left，然后你定义clear to the left. Floated元素会集序float, 但是cleared 元素会显示在下方。</p><img src="/2018/06/16/css-basic/float3.png"><p>如果一个floated元素比它的父节点要高,它就会<code>overflow</code>出去，如下：</p><img src="/2018/06/16/css-basic/float4.jpg"><p>这个时候就要用<code>clearfix</code> <span style="color: red">来撑起父元素的高度</span></p><pre><code class="css">.clearfix::after{    content:&quot;&quot;;    clear:both;    display:block;}</code></pre><h2 id="Pseudo-elements-selector-pseudo-element"><a href="#Pseudo-elements-selector-pseudo-element" class="headerlink" title="Pseudo-elements(selector::pseudo-element)"></a>Pseudo-elements(selector::pseudo-element)</h2><p>可以被用作</p><pre><code>*    Style the first letter, or line, of an element*    Insert content before, or after, the **content** of an element</code></pre><p><code>::before/::after</code> can be used to insert some content before/after the content of an element.</p><pre><code class="css">h1::before{    content:url(smiley.gif);}</code></pre><img src="/2018/06/16/css-basic/pseudo1.png"><h2 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h2><img src="/2018/06/16/css-basic/center.png"><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;            Container        &lt;/title&gt;        &lt;style type=&quot;text/css&quot;&gt;            body {            margin: 0px;            font-family: &#39;Open Sans&#39;, sans-serif;        }        .bg {            position: absolute;            height: 100%;            width:100%;        }        .centered {          position: fixed;          width: 100%;         top: 40%;        }        .centered div a div {            display: block;            width: 120px;            text-align: center;            font-size: 12px;        }        .centered a {            text-decoration: none;        }        .in {            display: inline-block;            text-align: center;            margin: 0px 10px 0px;        }        &lt;/style&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div class=&quot;bg&quot;&gt;            &lt;div class=&quot;centered in&quot;&gt;                &lt;div class=&quot;in&quot;&gt;                    &lt;a href=&quot;&quot; target=&quot;_blank&quot;&gt;                        &lt;img src=&quot;https://omni.annalect.com/static/i/ico/lg/digital-inventory.png&quot;&gt;                            &lt;div&gt;                                Campaign Reporting                            &lt;/div&gt;                        &lt;/img&gt;                    &lt;/a&gt;                &lt;/div&gt;                &lt;div class=&quot;in&quot;&gt;                    &lt;a href=&quot;&quot; target=&quot;_blank&quot;&gt;                        &lt;img src=&quot;https://omni.annalect.com/static/i/ico/lg/digital-inventory.png&quot;&gt;                            &lt;div&gt;                                Campaign Reporting                            &lt;/div&gt;                        &lt;/img&gt;                    &lt;/a&gt;                &lt;/div&gt;                &lt;div class=&quot;in&quot;&gt;                    &lt;a href=&quot;&quot; target=&quot;_blank&quot;&gt;                        &lt;img src=&quot;https://omni.annalect.com/static/i/ico/lg/digital-inventory.png&quot;&gt;                            &lt;div&gt;                                Campaign Reporting                            &lt;/div&gt;                        &lt;/img&gt;                    &lt;/a&gt;                &lt;/div&gt;            &lt;/div&gt;        &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="Flex布局"><a href="#Flex布局" class="headerlink" title="Flex布局"></a>Flex布局</h1><p>[Ref:<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html]" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html]</a></p><p>Flex是Flexible Box的缩写，意思为“弹性布局”，为盒模型提供了很大的灵活性<br>任何一个容器都可以指定为Flex布局<br><strong>设为Flex布局以后，子元素的<code>float</code>,<code>clear</code>和<code>vertical-align</code>属性将失效</strong></p><h2 id="flex基本概念"><a href="#flex基本概念" class="headerlink" title="flex基本概念"></a>flex基本概念</h2><p>container: 采用flex布局的元素，称为flex容器<br>flex-item: container里面所有的子元素自动成为容器成员<br>main axis: 水平主轴。主轴的开始位置（与边框的交叉点）称为<code>main start</code>,结束位置为<code>main end</code><br>cross axis: 垂直交叉轴。开始位置为<code>cross start</code>,结束位置为<code>cross end</code></p><img src="/2018/06/16/css-basic/flex-concept.png"><h2 id="container属性"><a href="#container属性" class="headerlink" title="container属性"></a>container属性</h2><h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p>决定主轴的方向，就是项目的排列方向</p><pre><code class="css">.box {  flex-direction: row | row-reverse | column | column-reverse;}</code></pre><pre><code>*   row(默认值)：主轴为水平方向，起点在左端*   row-reverse：主轴为水平方向，起点在右端*   column：主轴为垂直方向，起点在上沿*   column-reverse：主轴为垂直方向，起点在下沿</code></pre><img src="/2018/06/16/css-basic/flex-direction.png"><h3 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p><pre><code class="css">.box{  flex-wrap: nowrap | wrap | wrap-reverse;}</code></pre><pre><code>*   nowrap(默认)：不换行{%asset_img flex-nowrap.png%}*   wrap:换行，第一行在上方{%asset_img flex-wrap.jpg%}*   wrap-reverse:换行，第一行在下方{%asset_img flex-wrap-reverse.jpg%}</code></pre><h3 id="flex-flow属性"><a href="#flex-flow属性" class="headerlink" title="flex-flow属性"></a>flex-flow属性</h3><p>是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p><pre><code class="css">.box {  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;}</code></pre><h3 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h3><p>justify-content属性定义了项目在主轴上的对齐方式。</p><pre><code class="css">.box {  justify-content: flex-start | flex-end | center | space-between | space-around;}</code></pre><img src="/2018/06/16/css-basic/flex-justify-content.png"><pre><code>*   flex-start（默认值）：左对齐*   flex-end：右对齐*   center： 居中*   space-between：两端对齐，项目之间的间隔都相等。*   space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</code></pre><h3 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h3><p>align-items属性定义项目在交叉轴上如何对齐。</p><pre><code class="css">.box {  align-items: flex-start | flex-end | center | baseline | stretch;}</code></pre><img src="/2018/06/16/css-basic/flex-align-items.png"><pre><code>*   flex-start：交叉轴的起点对齐。*   flex-end：交叉轴的终点对齐。*   center：交叉轴的中点对齐。*   baseline: 项目的第一行文字的基线对齐。*   stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</code></pre><h3 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h3><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><pre><code class="css">.box {  align-content: flex-start | flex-end | center | space-between | space-around | stretch;}</code></pre><img src="/2018/06/16/css-basic/flex-align-content.png"><pre><code>*   flex-start：与交叉轴的起点对齐。*   flex-end：与交叉轴的终点对齐。*   center：与交叉轴的中点对齐。*   space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。*   space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。*   stretch（默认值）：轴线占满整个交叉轴。</code></pre><p>##item属性</p><h3 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h3><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><pre><code class="css">.item {  order: &lt;integer&gt;;}</code></pre><img src="/2018/06/16/css-basic/flex-order.png"><h3 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h3><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><pre><code class="css">.item {  flex-grow: &lt;number&gt;; /* default 0 */}</code></pre><img src="/2018/06/16/css-basic/flex-grow.png"><h3 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h3><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。<br>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><pre><code class="css">.item {  flex-shrink: &lt;number&gt;; /* default 1 */}</code></pre><img src="/2018/06/16/css-basic/flex-shrink.jpg"><h3 id="flex-basic属性"><a href="#flex-basic属性" class="headerlink" title="flex-basic属性"></a>flex-basic属性</h3><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p><pre><code class="css">.item {  flex-basis: &lt;length&gt; | auto; /* default auto */}</code></pre><h3 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h3><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p><pre><code class="css">.item {  flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]}</code></pre><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h3 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h3><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><pre><code class="css">.item {  align-self: auto | flex-start | flex-end | center | baseline | stretch;}</code></pre><p>##例子，用flex来垂直居中</p><pre><code class="html">&lt;div class=&quot;parent&quot;&gt;  &lt;div&gt;Hello!&lt;/div&gt;  &lt;div&gt;&lt;p&gt;Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vestibulum tortor quam, feugiat vitae, ultricies eget, tempor sit amet, ante. Donec eu libero sit amet quam egestas semper. Aenean ultricies mi vitae est. Mauris placerat eleifend leo. Quisque sit amet est et sapien ullamcorper pharetra.&lt;/p&gt;&lt;/div&gt;  &lt;div&gt;&lt;img src=&quot;https://davidwalsh.name/wp-content/themes/punky/images/logo.png&quot; style=&quot;display: inline;&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><pre><code class="css">.parent {    height:100vh;//very important!    display: flex;    justify-content:center;    align-items: center;}div&gt;p{    padding:1em;    box-sizing:border-box;    display:flex;    border:solid;    margin:10px;}</code></pre><img src="/2018/06/16/css-basic/flex-example1.png"><h1 id="CSS-Units"><a href="#CSS-Units" class="headerlink" title="CSS Units"></a>CSS Units</h1><h2 id="Absolute-Lengths"><a href="#Absolute-Lengths" class="headerlink" title="Absolute Lengths"></a>Absolute Lengths</h2><table><thead><tr><th>Units</th><th>Description</th></tr></thead><tbody><tr><td>cm</td><td>centimeters</td></tr><tr><td>mm</td><td>milimeters</td></tr><tr><td>in</td><td>inches (1in = 96px = 2.54cm)</td></tr><tr><td>px *</td><td>pixels (1px = 1/96th of 1in)</td></tr><tr><td>pt</td><td>points (1pt = 1/72 of 1in)</td></tr><tr><td>pc</td><td>picas (1pc = 12 pt)</td></tr></tbody></table><h2 id="Relative-Lengths"><a href="#Relative-Lengths" class="headerlink" title="Relative Lengths"></a>Relative Lengths</h2><table><thead><tr><th>Unit</th><th>Description</th></tr></thead><tbody><tr><td>em</td><td>Relative to the font-size of the element (2em means 2 times the size of the current font)</td></tr><tr><td>ex</td><td>Relative to the x-height of the current font (rarely used)</td></tr><tr><td>ch</td><td>Relative to width of the “0” (zero)</td></tr><tr><td>rem</td><td>Relative to font-size of the root element</td></tr><tr><td>vw</td><td>Relative to 1% of the width of the viewport*</td></tr><tr><td>vh</td><td>Relative to 1% of the height of the viewport*</td></tr><tr><td>vmin</td><td>Relative to 1% of viewport’s* smaller dimension</td></tr><tr><td>vmax</td><td>Relative to 1% of viewport’s* larger dimension</td></tr><tr><td>%</td><td>Relative to the parent element</td></tr></tbody></table><h1 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h1><pre><code class="html">&lt;div id=&quot;container&quot;&gt;               &lt;p&gt;First&lt;/p&gt;    &lt;div&gt;        &lt;p&gt;Child Paragraph&lt;/p&gt;    &lt;/div&gt;   &lt;p&gt;Second&lt;/p&gt;   &lt;p&gt;Third&lt;/p&gt;      &lt;/div&gt;</code></pre><h3 id="Space"><a href="#Space" class="headerlink" title="Space"></a>Space</h3><p>Descendant selector.<br>Target <strong>all p tags</strong> within container div.<br>例</p><pre><code class="css">div#container p{    font-weight:bold;}</code></pre><h3 id="‘-gt-’Sign"><a href="#‘-gt-’Sign" class="headerlink" title="‘&gt;’Sign"></a>‘&gt;’Sign</h3><p>Target elements which are <strong>DIRECT</strong> children of a particular element.</p><pre><code class="css">div#container &gt; p {  border: 1px solid black;}</code></pre><p>This will target all P element within container div, but <strong>not children of child div</strong></p><img src="/2018/06/16/css-basic/css_sign.jpg"><h3 id="‘-’-Sign"><a href="#‘-’-Sign" class="headerlink" title="‘+’ Sign"></a>‘+’ Sign</h3><p>This is adjacent sibling combinator. It combines two sequences of simple selectors having the same parent and the second one must come <strong>IMMEDIATELY</strong> after the first. 只会影响到第二个simbling</p><pre><code class="css">div + p {     color: green;  } </code></pre><p>只会选择div后面紧连着的第一个p，且这个div和p是同级的（共享同一个父亲），也就是说包着<code>Child Paragraph</code>的div，和<code>second</code>的p是同级的</p><img src="/2018/06/16/css-basic/css_plus.jpg"><h3 id="‘-’Sign"><a href="#‘-’Sign" class="headerlink" title="‘~’Sign"></a>‘~’Sign</h3><p>Similar to ‘+’ but the difference is that the second selector <strong>does NOT</strong> have to immediately follow the first one. It will select all elements that is preceded by the former selector.</p><pre><code class="css">div ~ p{    background-color:blue;}</code></pre><img src="/2018/06/16/css-basic/css_wave.jpg">]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux-basic</title>
      <link href="/2018/06/14/linux-basic/"/>
      <url>/2018/06/14/linux-basic/</url>
      <content type="html"><![CDATA[<h3 id="VMWARE-NAT-虚拟网络的配置介绍"><a href="#VMWARE-NAT-虚拟网络的配置介绍" class="headerlink" title="VMWARE NAT 虚拟网络的配置介绍"></a>VMWARE NAT 虚拟网络的配置介绍</h3><p>NAT是借助NAT（网络地址转换）通过物理机器的网络访问外网。其实这里的NAT就相当于路由器，它把虚拟机发到虚拟网卡的包进行地址转换后再发到实际的网络上。这个时候虚拟网段就可以和物理网段不一样。</p><p>VMWARE会自己生成一个虚拟的路由器，这个路由器的IP地址一般就是子网的网关地址和DNS地址。<br>DNS地址也可以设置成一些知名的DNS服务器地址，例如google的8.8.8.8</p><p>VMWARE在windows上面也会虚拟出一个VMWARE用的网卡，例如vmnet8,如果想让windows可以与虚拟机子连接，就设置成同一个子网的IP即可</p><img src="/2018/06/14/linux-basic/vmware-network-map.png"><a id="more"></a><h3 id="桥接模式Bridge"><a href="#桥接模式Bridge" class="headerlink" title="桥接模式Bridge"></a>桥接模式Bridge</h3><p>桥接模式一个重要的特点就是虚拟网卡和物理网卡是处于同一个网段的，比方说你物理网卡的网段是10.22.0.0/16，那么你的虚拟网卡也是10.22.0.0/16，由于物理机与虚拟机处于同一个子网，可以被子网内其他机器感知到，且这个时候物理网卡会接受包括自己的数据包和虚拟网卡的数据包。物理网卡收到数据再将数据转发至虚拟网卡内部。</p><p>网桥类似于Hub<br>任何机子连上来都属于同一网段，共用同一个IP段，虚拟机可以跟物理机相互ping通，所以物理机如果使用了这个IP，虚拟机不能再使用这个IP，没有隔离</p><p>所有的网络请求都要经过网桥（包括windows内部的请求），网桥然后连接物理网卡再跟真正的网络相连</p><p>如果路由器的物理IP变了，就要所有IP的都手动改变，所以这种模式不太推荐</p><p>首先需要在虚拟机的Machine Settings里面更改网络配置为桥接模式</p><img src="/2018/06/14/linux-basic/vmware-network-bridge01.png"><img src="/2018/06/14/linux-basic/vmware-network-bridge02.png"><h3 id="常用命令-centos-6-7"><a href="#常用命令-centos-6-7" class="headerlink" title="常用命令[centos 6.7]"></a>常用命令[centos 6.7]</h3><h4 id="网络方面"><a href="#网络方面" class="headerlink" title="网络方面"></a>网络方面</h4><ol><li><code>netstat -nltp</code><br>list all listening programs and their port</li><li><code>setup</code><br>进入图形界面更改配置</li><li><code>vi /etc/sysconfig/network</code><br>修改主机名<pre><code>NETWORKING=yesHOSTNAME=server1.itcast.cn</code></pre></li><li><p><code>vi /etc/sysconfig/network-scripts/ifcfg-eth0</code><br>修改IP地址</p><pre><code>DEVICE = &quot;eth0&quot;TYPE = &quot;Ethernet&quot;ONBOOT = &quot;yes&quot;  #是否网卡开机启用BOOTPROTO = &quot;static&quot;IPADDR = &quot;192.168.11.200&quot;NETMASK = &quot;255.255.255.0&quot;GATEWAY = &quot;192.168.11.2&quot;</code></pre><p><code>service network restart</code></p></li><li><p><code>vi /etc/hosts</code><br>修改ip地址和主机名的映射关系</p></li><li><p>如果设置完以后仍无法上网[<a href="https://blog.csdn.net/love666666shen/article/details/78087862]：" target="_blank" rel="noopener">https://blog.csdn.net/love666666shen/article/details/78087862]：</a><br>1,    VMWare Edit -&gt; Virtual Network Editor</p><img src="/2018/06/14/linux-basic/vmware-net-01.png"><p>2,    Delete VMnet8/Vmnet0, recreate those two network with same settings as you set in the linux. 记得保存之前的子网IP和掩码信息<br>3,    Check Windows Services -&gt; VMware DHCP Service/VMware NAT Service/VMware Workstation Server重新开启运行一下，并重启虚拟机</p><img src="/2018/06/14/linux-basic/vmware-net-02.png"><p>4,    在Windows中进入Vmnet8-&gt; IPV4 Settings -&gt;自动获取IP地址和DNS地址</p><img src="/2018/06/14/linux-basic/vmware-net-03.png"><p>5,    重启虚拟机，如果还是无法连接，在linux系统里面重新建一个Wired Connetion,然后来回切换一下网络</p><img src="/2018/06/14/linux-basic/vmware-net-04.png"></li><li><p>添加iptables, open port</p><pre><code>service iptables statusservice iptables startservice iptables status iptables -nL --line-numbers</code></pre><p><code>iptables -I INPUT -p tcp --dport 8080 -j ACCEPT</code><br>删除第八行rule：<br><code>iptables -D INPUT 8</code></p></li></ol><h4 id="日常操作命令"><a href="#日常操作命令" class="headerlink" title="日常操作命令"></a>日常操作命令</h4><p><code>pwd</code>    查看当前所在目录<br><code>date</code>    查看当前系统时间<br><code>who</code>     查看当前有谁在线，登陆了服务器<br><code>last</code>    查看最近的登陆历史记录<br><code>ls -al</code>    查看隐藏文件以及更详细的信息，以列表形式显示<br><code>mkdir -p aaa/bbb</code>    如果子目录没有，一并创建<br><code>touch filename</code>    创建文件<br><code>vi 编辑</code><br>    <code>A</code>    在该行的最后插入<br>    <code>a</code>    在该行最前面插入<br>    <code>gg</code>    直接跳到文件的首行<br>    <code>G</code>    直接跳到文件的末行<br>    <code>dd</code>    删除行，如果8dd，则一次性删除8行<br>    <code>yy</code>    复制当前行，3yy复制3行<br>    <code>p</code>    粘贴<br>    <code>/YOU</code>    查找文件中出现的YOU并定位到第一个找到的地方</p><p>#####文件权限的操作<br>drwxr-xr-x<br><span style="color: red">（也可以用二进制表示111 101 101，即十进制755）</span></p><p>d:    标识节点类型（d:文件夹    -：文件    l:链接）<br>r:可读<br>w:可写（删除文件并不代表你修改了这个文件，所以即使对这个文件没有写权限，也是可以删除的，删除其实是改变了父目录的内容，只要它上层directory有写权限，你就是可以删除的）<br>x:可执行（可不可以当一个程序来运行）<br>第一组rwx：    表示拥有者对它的权限<br>第二组rwx:    表示所属组对它的权限<br>第三组rwx：    上面用户之外的用户对它的权限</p><p><code>chmod o-rw xx.file</code><br>让其他人没有read write的权限<br>也可以用二进制的方法来写：<br><code>chmod -R 700 xxxDirectory</code><br><code>chown -R angela:angela aaa/</code>更改所有者，必须用root才能改</p><p>修改文件名<br><code>rename .repo .repo.bak *</code>    对当前目录下所有以.repo结尾的文件，改为以.repo.bak结尾的文件</p><h5 id="基本用户管理"><a href="#基本用户管理" class="headerlink" title="基本用户管理"></a>基本用户管理</h5><p><code>useradd angela</code>    添加用户<br><code>passwd angela</code>    设置密码<br><code>vi /etc/sudoers</code> -&gt; 将用户加入到sudoers中</p><pre><code>```root    ALL=(ALL)     ALLnewuser    ALL=(ALL)     ALL```</code></pre><p><code>su angela</code>    切换到angela<br><code>exit</code>    退出angela</p><p><code>getent group admin</code>    查看所有admin group下面的用户<br><code>groups ming.ming</code>    查看mingming属于哪些group</p><p><code>/etc/group</code>文件包含所有组,格式如下：<br>group_name:passwd:GID:user_list<br><code>/etc/shadow</code>和<code>/etc/passwd</code>系统存在的所有用户名</p><h5 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h5><p><code>hostname</code>    查看主机名</p><p><code>hostname hadoop</code>    修改主机名，重启后无效</p><p><code>vi /etc/sysconfig/network</code>    修改主机名，重启后永久生效</p><p><code>ifconfig eth0 192.168.11.22</code>    修改IP，重启后无效</p><p><code>vi /etc/sysconfig/network-scripts/ifcfg-eth0</code>    修改IP，重启后永久生效</p><p><code>uname -a</code> <code>uname -r</code>    查看系统信息/内核版本</p><p><code>date +%Y-%m-%d</code>    日期</p><p><code>mount -t iso9660 -o ro /dev/cdrom /mnt/cdrom</code> 挂载外部存储设备到文件系统中，其中这个存储type为iso，让其readonly，光驱设备名称 /dev/cdrom 挂载到/mnt/cdrom这个目录    </p><p><code>unmount /mnt/cdrom</code> 弹出</p><p><code>du -sh /mnt/cdrom</code>    统计文件夹的大小<br><code>df -h</code>    查看分区</p><p><code>halt</code>    关机</p><p><code>mkisofs -o /home/linuxlookup/example.iso /source/directory/</code>    生成iso文件</p><p><code>createrepo /var/www/html/repo</code>    生成repodata链接文件，否则本地yum无法安装</p><p>开机挂载光盘</p><pre><code>vi /etc/fstab/dev/cdrom              /mnt/cdrom              iso9660 defaults        0 0</code></pre><p><code>ln -s /mnt/cdrom ./centos</code> 生成软链接</p><h5 id="ssh免密登陆"><a href="#ssh免密登陆" class="headerlink" title="ssh免密登陆"></a>ssh免密登陆</h5><p><code>ssh-keygen</code>    生成密钥对</p><p><code>ssh-copy-id 192.168.11.222</code> 就会自动把公钥copy到192.168.11.222这个机子的.ssh/authorized_keys文件夹中 </p><h5 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h5><p><code>tail -10 install.log</code>    查看文件尾部的10行<br><code>tail -f install.log</code>    实时输出文件尾部内容，小f跟踪文件的唯一inode号，就算文件改名后，还是跟踪原来这个inode表示的文件<br><code>tail -F install.log</code>    大F按照文件名跟踪</p><h5 id="后台服务"><a href="#后台服务" class="headerlink" title="后台服务"></a>后台服务</h5><p><code>service --status-all</code>    系统中现在所有的后台服务<br><code>service network stop/start/restart</code><br><code>chkconfig</code>     查看所有服务自启配置<br><code>chkconfig iptables off</code>    关掉指定服务的自动启动</p><h5 id="上传文件到服务器"><a href="#上传文件到服务器" class="headerlink" title="上传文件到服务器"></a>上传文件到服务器</h5><p>在secureCRT中使用sftp工具:<br><code>alt+p</code>调出后用<code>put</code>命令上传<br><code>put xxx要上传的文件</code>     上传到服务器当前目录<br><code>lcd</code>     指定下载到本地的目标路径<br><code>get xxx要下载的文件</code>     下载</p><h5 id="解压打包文件"><a href="#解压打包文件" class="headerlink" title="解压打包文件"></a>解压打包文件</h5><p><code>gzip xxxfile</code>     压缩文件成为.gz格式<br><code>gzip -d</code>     解压gz文件</p><p><code>tar -cvf myfirstpackage.tar directory/</code>     将directory目录打包到myfirstpackage.tar文件中<br>-c create -v show detail -f file</p><p><code>tar -xvf myfirstpackage.tar</code> 解包文件</p><p><strong>一次性完成打包&amp;压缩</strong><br><code>tar -zcvf my.tar.gz directory/</code><br><code>tar -zxvf my.tar.gz -C d2/</code>     解压到指定目录下</p><h5 id="安装文件"><a href="#安装文件" class="headerlink" title="安装文件"></a>安装文件</h5><p>0,    更改Mirror到清华<br>    yum [<a href="https://mirror.tuna.tsinghua.edu.cn/help/centos/]：" target="_blank" rel="noopener">https://mirror.tuna.tsinghua.edu.cn/help/centos/]：</a><br>    首先备份CentOS-Base.repo<br>    <code>sudo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak</code><br>    然后vi /etc/yum.repos.d/CentOS-Base.repo<br>    将下面的写到文件中(CentOS6):</p><pre><code>    ```    # CentOS-Base.repo    #    # The mirror system uses the connecting IP address of the client and the    # update status of each mirror to pick mirrors that are updated to and    # geographically close to the client.  You should use this for CentOS updates    # unless you are manually picking other mirrors.    #    # If the mirrorlist= does not work for you, as a fall back you can try the    # remarked out baseurl= line instead.    #    #    [        base]    name=CentOS-$releasever - Base    baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/os/$basearch/    #mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=os    gpgcheck=1    gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7    #released updates    [updates]    name=CentOS-$releasever - Updates    baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/updates/$basearch/    #mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updates    gpgcheck=1    gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7    #additional packages that may be useful    [extras]    name=CentOS-$releasever - Extras    baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/extras/$basearch/    #mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extras    gpgcheck=1    gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7    #additional packages that extend functionality of existing packages    [centosplus]    name=CentOS-$releasever - Plus    baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/centosplus/$basearch/    #mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplus    gpgcheck=1    enabled=0    gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7    ```</code></pre><p>然后更新软件包缓存 <code>sudo yum makecache</code></p><p>1,    在安装jdk的时候如果出现<code>/lib/ld-linux.so.2: bad ELF interpreter: No such file or directory</code></p><pre><code>    ```    yum -y install glibc.i686    apt-get update    apt-get install ia32-libs    ```</code></pre><p>2,    更改环境变量</p><pre><code>```vi /etc/profile:$ # to the end of the fileo # append another line and goes into insert modeexport PATH = /root/apps/jdkXXXexport PATH=$PATH:$JAVA_HOME/bin:wq!source /etc/profile```</code></pre><p>3,    <code>yum</code>安装<br>    <code>yum list | grep XX</code> 列出所有可用的package和package组<br>    <code>yum clean all</code>    清除所有缓冲数据<br>    <code>yum deplist httpd</code>    列出一个包所有依赖的包<br>    <code>yum remove httpd</code>    删除httpd<br>    <code>yum repolist</code>    看一下现在的repo有哪些</p><p>4-0，yum安装MySQL</p><pre><code>```sudo yum install mysql-serversudo /sbin/chkconfig --levels 235 mysqld onsudo service mysqld startsudo mysql_secure_installation//登陆mysql -u root -pXXX```</code></pre><p>4-1，手动安装MySQL rpm包</p><pre><code>0，查询rpm包    `rpm -qa`1，上传MySQL-server-5.5.48-1.linux2.6.x86_64.rpm、MySQL-client-5.5.48-1.linux2.6.x86_64.rpm到Linux上2，使用rpm命令安装MySQL-server-5.5.48-1.linux2.6.x86_64.rpm，缺少perl依赖    `rpm -ivh MySQL-server-5.5.48-1.linux2.6.x86_64.rpm `3，安装perl依赖，上传6个perl相关的rpm包    `rpm -ivh perl-*`4，再安装MySQL-server，rpm包冲突    `rpm -ivh MySQL-server-5.5.48-1.linux2.6.x86_64.rpm`5，卸载冲突的rpm包    `rpm -e mysql-libs-5.1.73-5.el6_6.x86_64 --nodeps`6，再安装MySQL-client和MySQL-server    ```    rpm -ivh MySQL-client-5.5.48-1.linux2.6.x86_64.rpm    rpm -ivh MySQL-server-5.5.48-1.linux2.6.x86_64.rpm    ```7，启动MySQL服务，然后初始化MySQL    ```    service mysqld start    /usr/bin/mysql_secure_installation    ```8，测试MySQL    ```    mysql -u root -pXXXX    ```</code></pre><p>5，安装tomcat<br>    <code>tar -zxvf apacheXXXXX</code><br>    <code>cd apacheXXX/bin</code><br>    <code>./startup.sh</code></p><p>6，安装httpd服务器<br>    如果只是做简单的静态web服务器，不需要装tomcat,nginx这种，只要使用httpd就可以了</p><pre><code>```sudo yum install httpdcd /var/www/htmltouch hello.html```然后访问的时候直接ip:port/hello.html就可以访问了</code></pre>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>net-reflection</title>
      <link href="/2018/06/07/net-reflection/"/>
      <url>/2018/06/07/net-reflection/</url>
      <content type="html"><![CDATA[<h3 id="代码编译成机器码的过程"><a href="#代码编译成机器码的过程" class="headerlink" title="代码编译成机器码的过程"></a>代码编译成机器码的过程</h3><p><span style="color: red">注意在变成exe/dll之后还会有一层CLR/JIT，才会编译成机器码</span></p><img src="/2018/06/07/net-reflection/20180607145635.png"><p>为什么要有二次编译：<br>兼容性，不同的平台。32位64位/linux,windows在不同环境下编译的方法不同</p><p>想用同一种高级语言通用于所有的平台</p><h4 id="反射调用带参数的构造函数："><a href="#反射调用带参数的构造函数：" class="headerlink" title="反射调用带参数的构造函数："></a>反射调用带参数的构造函数：</h4><pre><code class="c#">Assembly assemly = Assembly.Load(&quot;Test.DB.SqlServer&quot;); //以前需要依靠一个类，现在相当于只依赖于一串字符串Type testType = assemly.GetType(&quot;Test.DB.SqlServer.ReflectionTest&quot;); //注意传的时候需要加上前方的namespaceobject oTest1 = Activator.CreateInstance(testType);//默认调用无参构造函数object oTest2 = Activator.CreateInstance(testType,new object[]{895,&quot;霉霉&quot;});//调用参数第一个是int类型，第二个是string类型的构造函数</code></pre><h4 id="反射调用Generic类型"><a href="#反射调用Generic类型" class="headerlink" title="反射调用Generic类型:"></a>反射调用Generic类型:</h4><pre><code class="c#">//Generic Classnamespace Test.DB.SqlServer{    public class GenericClass&lt;T,W,X&gt;    {        public void Show(T t, W w, X x)        {            Console.WriteLine(&quot;t.type={0},w.type={1},x.type={2}&quot;, t.GetType().Name,w.GetType().Name,x.GetType().Name);        }    }}Assembly assemly = Assembly.Load(&quot;Test.DB.SqlServer&quot;); Type genericType = assemly.GetType(&quot;Test.DB.SqlServer.GenericClass`3&quot;);//因为泛型有占位符，所以要写占位符Type realGenericType = genericType.MakeGeneric(typeof(int),typeof(string),typeof(Program)); //用genericType是无法生成实例的，因为这个时候还没有参数类型，必须要定义好才能用，所以要调用MakeGeneric方法，用realGenericType生成占位符object oGeneric = Activator.CreateInstance(realGenericType);</code></pre><h4 id="反射调用Singleton单例"><a href="#反射调用Singleton单例" class="headerlink" title="反射调用Singleton单例"></a>反射调用Singleton单例</h4><p>单力模式的意思就是保证程序运行的时候只会对这个类实例化一次</p><h5 id="构造函数种类及执行顺序"><a href="#构造函数种类及执行顺序" class="headerlink" title="构造函数种类及执行顺序"></a>构造函数种类及执行顺序</h5><ol><li>默认构造函数，如果没有为类指定任何构造函数，编译器会自动为类创建一个无参构造函数</li><li>静态构造函数，不能访问实例成员，只能用来初始化一些静态字段或者属性，<strong>仅在第一次调用类的任何成员时自动执行，不带反问修饰符，不带任何参数，且每个类只能有一个静态构造函数</strong></li><li>私有构造函数，将构造函数声明为私有，则不能通过new()在外部代码中实例话，可以这样实例：<br><code>`</code>c#<br>public class Demo<br>{<br>private Demo(){}<br>public static Demo NewDemo()<br>{<br> return new Demo();<br>}<br>}</li></ol><pre><code>4. **构造函数的执行顺序**    **子类静态构造 -&gt; 父类静态构造 -&gt; 父类构造 -&gt; 子类构造**单例模式通常使用的情况是&lt;span style=&quot;color: red&quot;&gt;不能在外面调用单例模式的私有构造函数的&lt;/span&gt;但是通过反射的方法是可以&lt;span style=&quot;color:red; font-weight: bold;&quot;&gt;调用单例模式的私有构造函数&lt;/span&gt;!```c#namespace Test.DB.SqlServer{    public sealed class Singleton    {        private static Singleton _Singleton = null;        //构造函数首先要私有化，别人不能调用它，只能它自己调用        private Singleton()        {            Console.WriteLine(&quot;Singleton被构造&quot;);        }        //静态构造函数首先会被调用，这个时候会调用私有构造函数        //由于静态构造函数只会被调用一次，所以这个类也就只会被实例化一次        static Singleton()        {            _Singleton = new Singleton();        }        public stati Singleton GetInstance()        {            return _Singleton;        }    }}Type singletonType = assemly.GetType(&quot;Test.DB.SqlServer.Singleton&quot;);//反射是可以直接去访问单例模式的私有构造函数，下面这个方法会调用单例模式的私有构造函数//并且还可以实例化多个单例object oSingleton1 = Activator.CreateInstance(singletonType, true);object oSingleton2 = Activator.CreateInstance(singletonType, true);</code></pre><h4 id="反射不强制转换也能调用方法，-Reflection-Method-gt-MVC"><a href="#反射不强制转换也能调用方法，-Reflection-Method-gt-MVC" class="headerlink" title="反射不强制转换也能调用方法， Reflection + Method -&gt; MVC"></a>反射不强制转换也能调用方法， Reflection + Method -&gt; MVC</h4><pre><code class="c#">Assembly assemly = Assembly.Load(&quot;Test.DB.SqlServer&quot;);Type testType = assemly.GetType(&quot;Test.DB.SqlServer.ReflectionTest&quot;);object oTest1 = Activator.CreateInstance(testType);MethodInfo method = testType.GetMethod(&quot;Show1&quot;); //以前写的具体方法也都换成了字符串method.Invoke(oTest1,new object[]{1332}); //调用含参数的方法{    method.Invoke(null,null);//调用无参数的静态方法，也可以写成method.Invoke(oTest1,null);    }{    MethodInfo method = testType.GetMethod(&quot;Show3&quot;,new Type[]{}); //重载方法没有参数的}{    MethodInfo method = testType.GetMethod(&quot;Show3&quot;, new Type[]{typeof(int)}); //重载方法有一个int类型的参数}{    MethodInfo method = testType.GetMethod(&quot;Show4&quot;,BindingFlags.Instance | BindingFlags.NonPublic); //调用私有方法}public class GenericMethod{    public void Show&lt;T,W,X&gt;(T t, W w, X x)    {        Console.WriteLine(&quot;XXX&quot;);    }}{    Type genericType = assemly.GetType(&quot;Test.DB.SqlServer.GenericMethod&quot;);    object oGeneric = Activator.CreateInstance(genericType); // 因为GenericMethod只是个普通类型，不是泛型类型    MethodInfo method = genericType.GetMethod(&quot;Show&quot;); //泛型方法不需要使用占位符    MethodInfo methodNew = method.MakeGeneric(typeof(int),typeof(string),typeof(int)); //记得这里要重新生成一个MethodInfo    methodNew.Invoke(oGeneric, new object[]{10,&quot;test&quot;,10});}</code></pre><h4 id="反射调用属性和字段-Reflection-Property-gt-O-RM"><a href="#反射调用属性和字段-Reflection-Property-gt-O-RM" class="headerlink" title="反射调用属性和字段 Reflection + Property -&gt; O/RM"></a>反射调用属性和字段 Reflection + Property -&gt; O/RM</h4><pre><code class="c#"> Type type = typeof(People); object oPeople = Activator.CreateInstance(type); foreach(var item in type.GetProperties()){ // 反射可以动态给对象属性赋值/获取值     Console.WriteLine(item.Name);     Console.WriteLine(item.GetValue(oPeople));     if(item.Name.Equals(&quot;Id&quot;))         item.SetValue(oPeople,1234);     else if(item.Name.Equals(&quot;Name&quot;))         item.SetValue(oPeople,&quot;ttt&quot;);     Console.WriteLine(item.GetValue(oPeople)) }</code></pre>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>.net-generic</title>
      <link href="/2018/06/05/net-generic/"/>
      <url>/2018/06/05/net-generic/</url>
      <content type="html"><![CDATA[<h2 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h2><p>现在有类</p><pre><code class="c#">public interface ISports    {        void Pingpang();    }    public interface IWork    {        void Work();    }    public class People    {        public int Id { get; set; }        public string Name { get; set; }        public void Hi()        { }    }    public class Chinese : People, ISports, IWork    {        public void Tradition()        {            Console.WriteLine(&quot;仁义礼智信，温良恭俭让&quot;);        }        public void SayHi()        {            Console.WriteLine(&quot;吃了么？&quot;);        }        public void Pingpang()        {            Console.WriteLine(&quot;打乒乓球...&quot;);        }        public void Work()        {            throw new NotImplementedException();        }    }    public class Hubei : Chinese    {        public Hubei(int id)        {        }        public string Changjiang { get; set; }        public void Majiang()        {            Console.WriteLine(&quot;打麻将啦。。&quot;);        }    }    public class Japanese : ISports    {        public int Id { get; set; }        public string Name { get; set; }        public void Pingpang()        {            Console.WriteLine(&quot;打乒乓球...&quot;);        }        public void Hi()        { }    }</code></pre><p>如果你现在有一个Generic Method:</p><pre><code class="c#">public class GenericMethod&lt;T&gt;{    public static void Show&lt;T&gt;(T instance){        People pInstance = (People) instance;        Console.WriteLine(pInstance.Id); //不会报错，但是这样做一点意义就没有了        Console.WriteLine(instance.Id); //会报错，没有Id        Console.WriteLint(instance.Name); //会报错，没有Name    }}</code></pre><h3 id="约束类型"><a href="#约束类型" class="headerlink" title="约束类型"></a>约束类型</h3><p>如果现在有一个<span style="color: red">基类约束</span></p><ol><li>基类约束，可以使用基类里面的属性和方法</li><li>基类约束，要求类型参数必须是基类或者其子类，所以如果你调用GenericMethod.Show(japanese)就会报错，因为它不属于People类</li><li>基类约束，如果where后面跟多个类型，这些类型属于and关系，必须同时满足才行</li></ol><p><strong>You can only put one class name and several interfaces to one ‘where’ constraint!</strong></p><pre><code class="c#">where T1: Supplier, IConstractor, IComparable, new()</code></pre><table><thead><tr><th>约束</th><th>说明</th></tr></thead><tbody><tr><td>T:struct</td><td>类型参数必须是值类型。可以指定处Nullable以外的任何值类型</td></tr><tr><td>T:class</td><td>类型参数必须是引用类型，包括任何类、接口、委托或数组类型</td></tr><tr><td>T:new()</td><td>类型参数必须具有无参数的公共构造函数。当与其他约束一起使用时，new()约束必须最后指定。</td></tr><tr><td>T:&lt;基类名&gt;</td><td>类型参数必须是指定的基类或派生自指定的基类</td></tr><tr><td>T:&lt;接口名称&gt;</td><td>类型参数必须是指定的接口或实现指定的接口。可以指定多个接口约束。约束接口也可以是泛型的。</td></tr><tr><td>T:U</td><td>为T提供的类型参数必须是为U提供的参数或派生自为U提供的参数。这称为裸类型参数。</td></tr></tbody></table><pre><code class="c#">public staic void Show&lt;T&gt;(T instance)where T: People{    Console.WriteLine(instance.Id); //不会报错，因为告诉了T是属于什么类型    Console.WriteLine(instance.Name);}</code></pre><p><span style="color: red">类型约束</span></p><pre><code class="c#">public static T DoNothing&lt;T&gt;(T tParameter)//where T: ISpotrs //接口类型约束//where T: class // 引用类型约束//where T: struct // 值类型约束where T: new() //无参数构造函数约束{    //return default(T);//会根据T的类型，产生一个默认值，可以应用于值类型约束的返回    //return null; //引用类型约束    T t = new T();    return t; //无参数构造函数返回}</code></pre><p>显示声明出来类型和用约束的区别</p><ol><li>用约束来写更加灵活，比方说其可以运用ISports或者new()的写法</li><li>如果显式声明出来，就只能用People里面的方法</li></ol><pre><code class="c#">public static void Show&lt;T&gt;(T instance)    where T: People, ISports, new() // and关系{    Console.WriteLine(instance.Id);    Console.WriteLine(instance.Name);    instance.Hi();    instance.Pingpang();    T t  = new T();}</code></pre><pre><code class="c#">public static void ShowPeople(People instance){    Console.WriteLine(instance.Id);    Console.WriteLine(instance.Name);    instance.Hi();    instance.Pingpang();//报错}</code></pre><p>无参数构造函数约束<br><span style="color: red">Hubei就不能使用，因为Hubei这个类里面没有定义无参构造函数</span></p><pre><code class="c#">Hubei hb = new Hubei(1);GenericMethod.Show(hb);//报错</code></pre><h3 id="Covariant协变与Contravariant逆变"><a href="#Covariant协变与Contravariant逆变" class="headerlink" title="Covariant协变与Contravariant逆变"></a>Covariant协变与Contravariant逆变</h3><p>out -&gt; Covariant<br>in  -&gt; Contravariant</p><p><span style="color: red">只能放在接口或者委托的泛型参数前面</span>，类和方法是不能用的，这个跟之前定义函数的in, out是两个概念</p><p>协变与逆变只对引用类型有效，因为值类型没有什么父子关系</p><pre><code class="c#">public class Bird{    public int Id {get;set;}}public class Sparrow: Bird{    public string Name{get;set;}}</code></pre><p>背景</p><pre><code class="c#">Bird bird1 = new Bird();Bird bird2 = new Sparrow(); //左边是父类，右边是子类Sparrow sparrow1 = new Sparrow();//Sparrow sparrow2 = new Bird();//错，不是所有的鸟都是麻雀List&lt;Bird&gt; birdList1 = new List&lt;Bird&gt;();List&lt;Bird&gt; birdList2 = new List&lt;Sparrow&gt;(); //错！！！！！！！！！一群麻雀是一群鸟这个竟然是错的，因为List&lt;T&gt;是一个泛型概念，List&lt;Sparrow&gt;与List&lt;Bird&gt;并没有父子关系//只能像下面这样写，把每一个Sparrow转换成Bird才可以，有点不和谐了对不对List&lt;Bird&gt; birdList3 = new List&lt;Sparrow&gt;().Select(c=&gt;(Bird)c).ToList();</code></pre><p>协变</p><p><strong>告诉编译器实例化的类型就是out T中T的子类</strong></p><p>先看下IEnumerable的定义，这里面用了协变</p><pre><code class="c#">public interface IEnumerable&lt;out T&gt;: IEnumerable{    ...}</code></pre><pre><code class="c#">IEnumerable&lt;Bird&gt; birdList1 = new List&lt;Bird&gt;();IEnumerable&lt;Bird&gt; birdList2 = new List&lt;Sparrow&gt;(); //这个就没问题，协变的意思就是说告诉编译器，如果我实例化的类型是我out的子类，就没问题</code></pre><p><strong>协变只能是返回结果</strong></p><pre><code class="c#">public interface ICustomerListOut&lt;out T&gt;{    T Get();    //void Show(T t);//报错，如果用了协变，只能作为返回结果，不能作为参数类型}public class CustomerListOut&lt;T&gt;: ICustomerListOut&lt;T&gt;{    public T Get()    {        return default(T);    }}</code></pre><p>逆变 Constravariant</p><p><strong>只能修饰传入参数</strong></p><pre><code class="c#">public interface ICustomerListIn&lt;in T&gt;{    //T Get(); //报错，只能坐参数，不能作返回值    void Show(T t);}public class CustomerListIn&lt;T&gt;: ICustomerListIn&lt;T&gt;{    public void Show(T t){    }}</code></pre><p>定义了逆变以后，我可以实现<span style="color: red">左边子类，右边父类的情况</span></p><pre><code class="c#">ICustomerListIn&lt;Sparrow&gt; customerList1 = new CustomerListIn&lt;Sparrow&gt;();ICustomerListIn&lt;Sparrow&gt; customerList2 = new CustomerListIn&lt;Bird&gt;(); //右边可以是父类！！！！！//因为定义的时候已经定义了customerList2一定是Sparrow类型，在show的时候已经要求了必须传入Sparrow类型customerList2.Show(new Sparrow());//Show这里要求必须传入的是Sparrow类型</code></pre><h3 id="泛型类中的静态字段"><a href="#泛型类中的静态字段" class="headerlink" title="泛型类中的静态字段"></a>泛型类中的静态字段</h3><p>泛型：jit编译的时候指定具体类型，同一个泛型类，不同的参数类型，其实会变成不同的类型</p><p>静态字段/静态构造函数：一个类型只会初始化一次，就在第一次调用的时候初始化，之后就常驻内存</p><p>那么！！！！<br><span style="color: red">泛型+静态会怎么样？</span></p><p>泛型类的静态字段，<strong>是独立的</strong><br>它会根据不同类型，产生不同的类，只有在不同类型第一次声明的时候会初始化，但是相同类型第二次用的时候就不会初始化！</p><pre><code class="c#">    Console.WriteLine(GenericCache&lt;int&gt;.GetCache());    Thread.Sleep(10);    Console.WriteLine(GenericCache&lt;long&gt;.GetCache());//第一次进long的时候，仍然会初始化    Thread.Sleep(10);    Console.WriteLine(GenericCache&lt;int&gt;.GetCache());//这个时候就不会在初始化了，因为int类型的已经初始化过了</code></pre><p>这里就牵扯到了泛型静态缓存<br><strong>泛型缓存的效率非常高</strong>，是直接在内存中缓存，CPU直接拿值<br>但是这个缓存没有办法清除，比字典寻址方法要快很多</p>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> .NET </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Openresty Auto Start Script</title>
      <link href="/2018/06/01/openresy-auto-start-script/"/>
      <url>/2018/06/01/openresy-auto-start-script/</url>
      <content type="html"><![CDATA[<pre><code class="bash">#!/bin/sh## chkconfig: 2345 55 25# Description: Nginx init.d script, put in /etc/init.d, chmod +x /etc/init.d/nginx#              For Debian, run: update-rc.d -f nginx defaults#              For CentOS, run: chkconfig --add nginx#### BEGIN INIT INFO# Provides:          nginx# Required-Start:    $all# Required-Stop:     $all# Default-Start:     2 3 4 5# Default-Stop:      0 1 6# Short-Description: nginx init.d script# Description:       OpenResty (aka. ngx_openresty) is a full-fledged web application server by bundling the standard Nginx core, lots of 3rd-party Nginx modules, as well as most of their external dependencies.### END INIT INFO#PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/binDESC=&quot;Nginx Daemon&quot;NAME=nginxPREFIX=/usr/local/openresty/nginxDAEMON=$PREFIX/sbin/$NAMECONF=$PREFIX/conf/$NAME.confPID=$PREFIX/logs/$NAME.pidSCRIPT=/etc/init.d/$NAMEif [ ! -x &quot;$DAEMON&quot; ] || [ ! -f &quot;$CONF&quot; ]; then    echo -e &quot;\033[33m $DAEMON has no permission to run. \033[0m&quot;    echo -e &quot;\033[33m Or $CONF doesn&#39;t exist. \033[0m&quot;    sleep 1    exit 1fido_start() {    if [ -f $PID ]; then        echo -e &quot;\033[33m $PID already exists. \033[0m&quot;        echo -e &quot;\033[33m $DESC is already running or crashed. \033[0m&quot;        echo -e &quot;\033[32m $DESC Reopening $CONF ... \033[0m&quot;        $DAEMON -s reopen -c $CONF        sleep 1        echo -e &quot;\033[36m $DESC reopened. \033[0m&quot;    else        echo -e &quot;\033[32m $DESC Starting $CONF ... \033[0m&quot;        $DAEMON -c $CONF        sleep 1        echo -e &quot;\033[36m $DESC started. \033[0m&quot;    fi}do_stop() {    if [ ! -f $PID ]; then        echo -e &quot;\033[33m $PID doesn&#39;t exist. \033[0m&quot;        echo -e &quot;\033[33m $DESC isn&#39;t running. \033[0m&quot;    else        echo -e &quot;\033[32m $DESC Stopping $CONF ... \033[0m&quot;        $DAEMON -s stop -c $CONF        sleep 1        echo -e &quot;\033[36m $DESC stopped. \033[0m&quot;    fi}do_reload() {    if [ ! -f $PID ]; then        echo -e &quot;\033[33m $PID doesn&#39;t exist. \033[0m&quot;        echo -e &quot;\033[33m $DESC isn&#39;t running. \033[0m&quot;        echo -e &quot;\033[32m $DESC Starting $CONF ... \033[0m&quot;        $DAEMON -c $CONF        sleep 1        echo -e &quot;\033[36m $DESC started. \033[0m&quot;    else        echo -e &quot;\033[32m $DESC Reloading $CONF ... \033[0m&quot;        $DAEMON -s reload -c $CONF        sleep 1        echo -e &quot;\033[36m $DESC reloaded. \033[0m&quot;    fi}do_quit() {    if [ ! -f $PID ]; then        echo -e &quot;\033[33m $PID doesn&#39;t exist. \033[0m&quot;        echo -e &quot;\033[33m $DESC isn&#39;t running. \033[0m&quot;    else        echo -e &quot;\033[32m $DESC Quitting $CONF ... \033[0m&quot;        $DAEMON -s quit -c $CONF        sleep 1        echo -e &quot;\033[36m $DESC quitted. \033[0m&quot;    fi}do_test() {    echo -e &quot;\033[32m $DESC Testing $CONF ... \033[0m&quot;    $DAEMON -t -c $CONF}do_info() {    $DAEMON -V}case &quot;$1&quot; in start) do_start ;; stop) do_stop ;; reload) do_reload ;; restart) do_stop do_start ;; quit) do_quit ;; test) do_test ;; info) do_info ;; *) echo &quot;Usage: $SCRIPT {start|stop|reload|restart|quit|test|info}&quot; exit 2 ;;esacexit 0</code></pre>]]></content>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> practice </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>法律法规</title>
      <link href="/2018/06/01/information-law/"/>
      <url>/2018/06/01/information-law/</url>
      <content type="html"><![CDATA[<p>主要考的分类为</p><ul><li>招投标法</li><li>政府采购法</li><li>合同法</li><li>著作权法</li><li>专利法</li></ul><h2 id="招标投标法"><a href="#招标投标法" class="headerlink" title="招标投标法"></a>招标投标法</h2><ul><li>必须招标：国家型，外国资金型，社会公共利益型</li></ul><p>招投标法和政府采购法关于时间的总结：</p><ul><li><strong>发标二零改一五，售标前后至少五，报府备案要十五</strong></li><li><strong>售标前后至少五，签约退保也得五</strong></li><li><strong>三个30得牢记，定标、签约、“保证期”</strong></li></ul><img src="/2018/06/01/information-law/zhaotoubiao.png"><h2 id="政府采购法"><a href="#政府采购法" class="headerlink" title="政府采购法"></a>政府采购法</h2><ul><li>分为集中采购和分散采购<ul><li>集中采购的范围由省级以上人民政府公布的集中采购目录确定</li><li>中央预算的政府采购项目，集中采购目录由国务院确定公布</li><li>地方预算的政府采购项目，目录由省、自治区、直辖市人民政府或者其授权的机构确定公布</li></ul></li><li>不必采购本国的货物：<ul><li>无法在境内获取或无法以合理商业条件获取</li><li>在中国境外使用而进行采购的</li><li>其他法律、行政法规另有规定的</li></ul></li><li>集中采购机构必须是<strong>非营利性</strong>    事业法人</li><li>政府采购采用以下方式：<ul><li>公开招标</li><li>邀请招标<ul><li>具有特殊性，只能从有限范围供应商采购的</li><li>采用公开招标方式的费用占政府采购项目总价值的比例过大的</li></ul></li><li>竞争性谈判<ul><li>招标后没有供应商投标或者没有合格标的或者重新招标未能成立的</li><li>技术复杂或者性质特殊，不能确定详细规格或者具体要求的</li><li>采用招标所需时间不能满足用户紧急需要的</li><li>不能事先计算出价格总额的</li></ul></li><li>单一来源采购<ul><li>只能从唯一供应商采购的</li><li>发生了不可预见的紧急情况不能从其他供应商处采购</li><li>必须保证原有采购项目一致性或者服务配套的要求，需要继续从原供应商处添购且添购的资金总额不超过原合同采购金额10%</li></ul></li><li>询价<ul><li>采购的货物规格、标准统一、现货货源充足且价格变化幅度小的政府采购项目</li></ul></li><li>国务院政府采购监督管理部门认定的其他采购方式</li></ul></li></ul><h2 id="合同法"><a href="#合同法" class="headerlink" title="合同法"></a>合同法</h2><ul><li>要约与要约邀请的区别：<br>内容很明确的为要约：商业广告如果符合要约规定的，可以视为要约<br>内容不明确要补充的为要约邀请：如价目表、拍卖公告、招标公告、招股说明书、商业广告</li><li>要约的定义：<br>是一方当事人以缔结合同为目的，向对方当事人提出合同条件，希望对方当事人接受的意思表示</li><li>有下列情形之一的要约不得撤销<ul><li>要约人确定了承诺期限或者以其他形式明示要约不可撤销</li><li>受要约人有理由认为要约不可撤销的，并已经为履行合同作了准备工作</li></ul></li><li>承诺的定义：<br>受要约人同意要约的意思表示</li><li>要约没有确定承诺期限的，承诺应当依照下列的规定到达：<ul><li>要约以对话方式作出的，应当<strong>即时作出</strong>承诺，但当事人另有约定的除外</li><li>要约以非对话方式作出的，承诺应当在<strong>合理期限内到达</strong></li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 信息系统管理师 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>hexo-HttpRequestException</title>
      <link href="/2018/06/01/hexo-HttpRequestException/"/>
      <url>/2018/06/01/hexo-HttpRequestException/</url>
      <content type="html"><![CDATA[<p>Hexo Error: HttpRequestException</p><pre><code>warning: LF will be replaced by CRLF in tags/concept/index.html.The file will have its original line endings in your working directory.Fatal: HttpRequestException encountered.bash: /dev/tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for &#39;https://github.com&#39;: Invalid argumentFATAL Something&#39;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: Fatal: HttpRequestException encountered.bash: /dev/tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for &#39;https://github.com&#39;: Invalid argument    at ChildProcess.&lt;anonymous&gt; (D:\learning\node_modules\hexo-util\lib\spawn.js:37:17)    at emitTwo (events.js:126:13)    at ChildProcess.emit (events.js:214:7)    at ChildProcess.cp.emit (D:\learning\node_modules\cross-spawn\lib\enoent.js:40:29)    at maybeClose (internal/child_process.js:925:16)    at Process.ChildProcess._handle.onexit (internal/child_process.js:209:5)</code></pre><p>使用：</p><pre><code>git config --global credential.helper wincredhexo clean</code></pre>]]></content>
      
      
        <tags>
            
            <tag> practice </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python-thread-run-start</title>
      <link href="/2018/05/30/python-thread-run-start/"/>
      <url>/2018/05/30/python-thread-run-start/</url>
      <content type="html"><![CDATA[<h2 id="start"><a href="#start" class="headerlink" title="start()"></a>start()</h2><blockquote><p>   Start the thread’s activity.<br>    It must be called at most once per thread object. It arranges for the object’s <strong>run()</strong> method to be invoked in a separate thread of control.<br>    This method will raise a RuntimeError if called more than once on the same thread object.</p></blockquote><pre><code>它安排对象在另一个单独的线程中调用run()方法，而不是当前所出的线程</code></pre><h2 id="run"><a href="#run" class="headerlink" title="run()"></a>run()</h2><blockquote><p>   Method representing the thread’s activity.<br>    You may override this method in a subclass. The standard run() method invokes the callable object passed to the object’s constructor as the target argument.</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>process-thread</title>
      <link href="/2018/05/30/process-thread/"/>
      <url>/2018/05/30/process-thread/</url>
      <content type="html"><![CDATA[<h3 id="Process进程"><a href="#Process进程" class="headerlink" title="Process进程"></a>Process进程</h3><p>进程是一个具有一定独立功能的程序，在一个数据集上的一次动态执行过程<br>是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体</p><p>好比工厂车间，代表CPU所能处理的单个任务<br>任一时刻CPU总是运行一个进程，其他进程处于非运行状态</p><h3 id="Thread线程"><a href="#Thread线程" class="headerlink" title="Thread线程"></a>Thread线程</h3><p>早期任务调度采用的是时间片轮转的抢占式调用方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。<br>后来由于对CPU的要求越来越高，进程之间的切换开销较大，于是发明了线程。<br>线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元。</p><p>线程好比车间的工人，即一个车间可以允许由多个工人协同完成一个任务</p><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><p>进程就是包含上下文切换成程序执行时间总和 = CPU加载上下文 + CPU执行 + CPU保存上下文</p><p>但是进程的颗粒度太大，一个进程可能有好多分支和程序段，比方说进程A分为a,b,c等多个块组合而成，那么CPU的具体执行行为可能就变为：</p><p>A得到CPU -&gt; CPU加载上下文，开始执行程序A的a小段， 然后执行程序A的b小段， 然后再执行程序A的c小段，最后CPU保存A的上下文</p><p>这里<span style="color: red">a, b, c共享了A的上下文，CPU在执行的时候没有进行上下文切换。这里的a,b,c就是线程，也就是线程共享了进程的上下文环境，被分为更为小的CPU时间段</span></p><h3 id="高并发与多线程"><a href="#高并发与多线程" class="headerlink" title="高并发与多线程"></a>高并发与多线程</h3><p>高并发只是一个语义相关的概念，就是让服务器能够接受多用户请求<br>多线程只是为了达到高并发目的（首先要有多线程接收处理多任务，才有高并发发生）。在某个细节点上，为实现某并发功能而采用的一种具体的实现方法，这种功能也可以由多进程实现。</p><p>高并发其实是一种目的，多线程只是某种手段。</p>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>conda-packages-install</title>
      <link href="/2018/05/29/conda-packages-install/"/>
      <url>/2018/05/29/conda-packages-install/</url>
      <content type="html"><![CDATA[<h2 id="如何查看一个包所在的地址"><a href="#如何查看一个包所在的地址" class="headerlink" title="如何查看一个包所在的地址"></a>如何查看一个包所在的地址</h2><ul><li></li></ul><pre><code>import numpyprint numpy.__file__</code></pre><ul><li></li></ul><pre><code>import osimport numpypath = os.path.dirname(numpy.__file__)</code></pre>]]></content>
      
      
        <tags>
            
            <tag> practice </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>论文</title>
      <link href="/2018/05/28/information-test/"/>
      <url>/2018/05/28/information-test/</url>
      <content type="html"><![CDATA[<h2 id="论文写作"><a href="#论文写作" class="headerlink" title="论文写作"></a>论文写作</h2><ul><li>四大领域：<br>进度        成本        质量        范围</li><li>辅助<br>人力        沟通        风险        采购        干系人</li><li>论文不及格的几种类型：<ol><li>虚构情节，<span style="color: red"><strong>千万不要写什么教育方面的系统</strong></span></li><li>没有项目开发的实际经验，正片都是浅层次纯理论的论文</li><li>所讨论的内容与方法过于陈旧，也千万别用<strong>云计算等</strong>改卷老师都不知道的技术（？？？？）</li><li>一定不能写你既是项目经理、又是技术人员</li><li>乙方角度，一定不能写在签订合同前的事情</li><li>如果题目里面没有提到“大项目”，纵使项目再大，也不要写“大项目”；如果题目里面提到了“大项目”，纵使项目再小，也要写成“大项目”，写大项目就要突出大项目的特点、需要写间接管理</li></ol></li></ul><ul><li><p>论文素材<br>建议投资在一百万以上<br>统一设定成乙方的项目<br>项目可以通过政府采购网站上查找招标书，比方说XX市政府采购网/或搜索信息系统方案书，投标书/或再加上十二金中一金为关键词，比方说金盾 方案书/选定项目之后，再搜索详细功能介绍，比方说相关项目怒的博士/硕士论文</p><p>项目必须是已经完工的项目，且最好是最近几年的</p></li><li><p>论文格式<br>分摘要和正文<br>摘要要求字数300字左右，330字一下<br>正文要求2000字以上<br><span style="color: red">不要在论文中书画图形</span><br>正文又可分为</p><ol><li>背景， 建议2段左右完成， 字数控制在500字左右，写完后写150字左右的过渡段</li><li>正文实践部分，一般3~6个论点，一个论点1~2段，整体字数在1400左右</li><li>收尾，一般1~2段，画龙点睛，写总结经验和教训，表决心，字数在300字左右为佳</li></ol></li><li><p>大项目的论文写作</p><ol><li>要在摘要和背景里面体现项目大，<strong>需要写明投资和工期</strong>，比方说投资纯软件300万+，软件+硬件1200万+，工期1年左右</li><li>摘要里面最后总结对大项目你管理的心得体会</li><li>体现简介管理，分级分工管理，比如我带领了/我指导了XXX做了什么工作</li><li>如果题目没有要求写大项目，建议不要写大项目</li></ol></li><li><p>摘要的写法<br>一定要规范，（时间、项目、投资金额、周期、项目目标、本文导论的内容（哪个管理的描述、管理的几个过程的介绍、管理中的问题、解决措施）、项目是否完工、是否达到目标）</p><p>举例：</p><pre><code>2016年3月，我作为项目经理参与了XX市XX项目，整个项目总投资7--余万元，建设工期为1年。某市力图通过XX项目的建设，实现XX的目的。该项目于2017年3月，通过了业主方的验收，赢得了用户的好评。本文以XX项目为例，结合作者实践，探讨了在项目XX管理中遇到的问题及解决方法。包括XX、XX、XX。（或者讨论了信息系统项目过程中的XX管理，主要从如下几个方面进行论述：XX-结合自己的论点去写，可以是过程，可以是解决方法，但是需要和论点对应）最后，针对存在的不足之处，提出了今后的改进思路</code></pre></li><li><p>正文背景写法<br>背景基本上就是摘要的扩充</p><ol><li>甲方立项的目的，即项目将要解决什么问题</li><li>公开招标，乙方赢得该项目，项目投资额、项目工期</li><li>项目详细的功能介绍</li><li>项目技术选择</li><li>项目组织形式以及项目团队构成<br>以上500字左右</li><li>XX管理的重要性</li><li>过渡到论述的论点<br>以上150字左右</li></ol><p>例：</p><pre><code>2017年2月， 我参与了XX市区域卫生信息集成平台建设项目，担任项目经理职位。该项目由该市卫生局贯彻“十二五”期间关于深化医药卫生体制改革规划而催生，共投资人民币980万元，工期15个月。通过该项目的建设，实现了该市人人享有基本医疗卫生服务，提高全民健康水平的总体目标。该项目将该市卫生局下属7家二级以上医院，以及23家乡镇卫生院各类医疗信息进行整合，建立区域内患者医疗信息集中存储、分布调阅、资源整合、互联互通、资源共享，减少患者跨院就诊重复检查，从而以推进公共卫生、医疗、医保、药品、财务监管信息化建设为着力点，加快信息标准化和公共卫生服务信息平台建设。该集成平台涵盖了区域市民健康系统、区域医院信息系统（简称HIS）、区域电子病历系统（EMR）、基层医疗卫生信息系统、绩效考核系统、药品监督系统等6大子系统。由于系统应用于各乡镇各医疗机构，考虑使用者的地域性，所以该集成平台使用基于.net平台的B/S三层架构，所有服务器集中存放在卫生局的中心机房，各医疗机构通过专网连接。该集成平台应用系统采用C#+MVC+ExtJS架构开发，服务器使用IBM Power 720小型机，应用服务器操作系统为Windows Server 2008,数据库采用Oracle 11g,数据库服务器操作系统为AIX 5L。同时使用vs2013自带的团队管理器TFS作为项目配置管理工具。【515字，一般到这里就结束了】该项目建设具有如下特征：1. 项目周期长，历时长达15个月之久。2. 项目规模大，目标构成复杂。3. 项目干系人构成复杂，包括市卫生局、社保中心、医院卫生院以及各子系统的项目成员等。 4. 综合性强。然而面对如此复杂的应用，我面临更多“间接管理”的挑战，日常职责更集中于管理职责。由于本系统涉及业务考核，因此在本项目中，质量管理尤为重要。在本项目中，我作为项目经理，除了对其他管理领域进行恪尽职守的管理外，主要从质量规划、质量保证和质量控制等方面进行质量管理。下面结合本人实际经验，简要介绍该项目的质量管理过程和方法，望各位批评指正。【这一段一般市大项目的写法，一般项目不用谢】</code></pre></li><li><p>正文中的万能模板<br>需求管理</p><pre><code>从事多年项目管理的我深知，需求是龙头，是做项目管理的基础，没有需求，项目就无从谈起；因此在项目开始实施后，我带领我的项目团队深入甲方现场，通过用户访谈方式获得了用户需求，为后期项目管理奠定了基础；【建议在实践的开头部分写】</code></pre><p>变更管理</p><pre><code>在项目实施过程中，变更不可避免的可能会由于用户的需求发生了变化、政策导向的改变或者由于一些新金属的出现等等。在本项目中我严格遵照变更控制流程进行管理，比如变更申请-评估-决策-实施-验证-沟通存档，我通过严格管理变更，没有导致项目的延期【建议在时间的偏后写】</code></pre></li><li><p>收尾的万能模板</p><pre><code>由于在实际项目中我们对XX管理的高度重视，采取了···（方法和措施），取得了良好的收效，我们的项目按期完成，项目组也赢得了公司的好评，项目基本上取得了成功。但通过总结认为，该项目··管理中····（哪些方面）仍存在一些不足，主要是由于····（原因）造成了····（不良后果），所以在后续的学习和工作中，我将不断充电学习，同时进行业务交流，提升自己的业务和管理水平，力争为我国信息化建设做出自己的努力</code></pre></li></ul>]]></content>
      
      
        <tags>
            
            <tag> 信息系统管理师 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构简概</title>
      <link href="/2018/05/28/data-structure/"/>
      <url>/2018/05/28/data-structure/</url>
      <content type="html"><![CDATA[<p>学习萧大神笔记：</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><ul><li><p>O(1)<br>常数复杂度，例如取数组第1000000个元素<br><strong>字典和集合的存取都是O(1)</strong><br><strong>数组的存取是O(1)</strong></p><p>O(1)与O(n)的区别：<br>O(1)的时间是确定的，O(n)是随着时间增大而增大<br>O(1)是随着数据规模的增长而增长</p></li><li><p>O(lgN)<br>对数复杂度<br>例如一个<strong>有序数组</strong>，二分法查找</p></li><li><p>O(n)<br>线性复杂度<br>例如有一个数组，以遍历方式在其中查找元素</p></li><li><p>O(nlgN)<br>例如求两个数组的交集，其中A是有序数组，B不是有序数组<br>A数组每一个元素都要在B数组中进行查找<br>因为每次查找用二分法的复杂度是lgN，那么n个数据就是nLgN</p></li><li><p>O(n^2)<br>平方复杂度<br>求两个无序数组的交集</p></li></ul><h2 id="常用数据结构"><a href="#常用数据结构" class="headerlink" title="常用数据结构"></a>常用数据结构</h2><ul><li><p>数组<br>连续的一块内存<br>存取元素的时间是O(1),因为是连续的内存，只要计算出内存地址就可以迅速拿到数据，这里的存取是指替换掉原来的元素<br>插入、删除是O(n)，因为插入之后的元素都要往后挪</p></li><li><p>链表<br>手拉手的盒子，一个盒子只能访问左右手的盒子<br>以下标方式读取元素的时间是O(n)，因为要一个个搜过去<br>插入、删除是O(1)，只要更改链表的指向就可<br>栈和队列是链表的改良<br>队列 先进先出<br>栈    先进后出</p></li><li><p>字典(哈希表 对象 关联数组 Map 都是字典)<br>想要像数组一样可以拿取数据都是O(1),但是数组都是用数字来取数据，想要也能用字符串来取数据<br>把字符串转为数字作为下标存储在数组中<br>字符串转化为数字的算法是O(1)<br>所有字典的存取操作也都是O(1)<br>除非对数据有顺序要求，否则字典永远都是最佳选择<br>字符串转化为数字的算法：</p><ol><li>确定数据规模，这样可以确定容器数组的大小 =  Size</li><li>把字符当作N进制数字得到结果：<br> ‘gua’ = g <em> 1+u </em> 10+1 * 100 = n<br> n % Size作为字符串在数组中的下标<br> 通常Size会选一个素数，素数也叫做质数，指在大于1的整数中只能被1和它本身整除的数，比如2、3、5、7、11、43、109</li><li>如果下标冲突（即碰撞）的时候，有标准解决碰撞的方法，比方说用HashTable<br> 它的原理是我在数组中存的不是数据，而是一个链表<br> 当Hash值相同的时候，就放在这个链表里面</li></ol></li><li><p>搜索树<br>用于作搜索用，比方说二叉搜索树，左边的节点总是小于中间的节点，右边的节点总是大于中间的节点<br>这样搜索最小的 ，只要搜索最左边那一条线就可以了<br>时间复杂度跟二叉搜索一样，都取决于你这棵树的高度O(lgN)</p><p>平衡树的意思就是当树的高度差超过1的时候，会重新定义根节点，把原来的树进行旋转</p></li><li><p>图</p></li><li><p>Python List<br>存取是O(1)<br>插入删除也是O(1)</p><p>当它最初申请的数组空间用完了以后，它会申请一个更大的数组空间，然后把原来的数组空间copy到新申请的大数组空间中</p><p>所以有时候看会有时间断层</p><p>Python list有两个部件：<br>   数组        存储数据在链表中的地址<br>   链表        实际存储数据</p></li></ul><pre><code class="python"># HashTable Data Structureclass HashTable(object):    def __init__(self):        self.table_size = 11        self.table = [0]*self.table_size    # 这个魔法方法来实现in/not in语法    def __contains__(self, item):        return self.has_key(item)    def has_key(self, key):        index = self._index(key)        v = self.table[index]        if isinstance(v, list):            for kv in v:                if kv[0] == key:                    return True        return False    def _index(self, key):        return self._hash(key) % self.table_size    def _hash(self, s):        n = 0        f = 1        for i in s:            n += ord(i) * f            f *= 10        return n    def add(self, key, value):        index = self._index(key)        self._insert_at_index(index, key, value)    def _insert_at_index(self, index, key, value):        v = self.table[index]        data = [key, value]        if isinstance(v, int):            self.table[index] = [data]        else:            self.table[index].append(data)    def get(self, key, default_value = None):        index = self._index(key)        v = self.table[index]        if isinstance(v, list):            for kv in v:                if kv[0] == key:                    return kv[1]        return default_valuedef test():    import uuid    names = [        &#39;ss&#39;,        &#39;drill&#39;,        &#39;name&#39;,        &#39;python&#39;,        &#39;web&#39;,        &#39;Banana&#39;,        &#39;Apple&#39;,        &#39;Computer&#39;,        &#39;Android&#39;,        &#39;Mobile&#39;    ]    ht = HashTable()    for key in names:        value = uuid.uuid4()        ht.add(key, value)        print(&#39;add 元素&#39;, key, value)    for key in names:        v = ht.get(key)        print(&#39;get 元素&#39;, key, v)if __name__ == &#39;__main__&#39;:    test()</code></pre><p>如果这个素数设置的够小，你就能看到有些item存的是一个list<br><img src="/2018/05/28/data-structure/20180528160417.png"></p>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Session Cookie</title>
      <link href="/2018/05/22/session-cookie/"/>
      <url>/2018/05/22/session-cookie/</url>
      <content type="html"><![CDATA[<p>Session 和 Cookie的出现都是为了保存状态， 因为浏览器是无状态的</p><h2 id="Cookie-是保存在客户端的，如果服务器的response里面有set-cookie-则客户端的服务器就会存这个值"><a href="#Cookie-是保存在客户端的，如果服务器的response里面有set-cookie-则客户端的服务器就会存这个值" class="headerlink" title="Cookie 是保存在客户端的，如果服务器的response里面有set_cookie,则客户端的服务器就会存这个值"></a>Cookie 是保存在客户端的，如果服务器的response里面有set_cookie,则客户端的服务器就会存这个值</h2><h2 id="Cookie里面不能直接存敏感的值，所以有了Session-服务器维护Session和Cookie的Mapping关系，但是"><a href="#Cookie里面不能直接存敏感的值，所以有了Session-服务器维护Session和Cookie的Mapping关系，但是" class="headerlink" title="Cookie里面不能直接存敏感的值，所以有了Session, 服务器维护Session和Cookie的Mapping关系，但是"></a>Cookie里面不能直接存敏感的值，所以有了Session, 服务器维护Session和Cookie的Mapping关系，但是</h2><p><span style="color:red">Session也是可以存在客户端的</span></p><p>比方说</p><pre><code class="python">@main.route(&quot;/login&quot;, methods=[&#39;POST&#39;])def login():    form = request.form    u = User.validate_login(form)    if u is None:        return redirect(url_for(&#39;.index&#39;))    else:        # session 中写入 user_id        session[&#39;user_id&#39;] = u.id        return redirect(url_for(&#39;.profile&#39;))</code></pre><img src="/2018/05/22/session-cookie/20180522162224.png"><p>不过比较好的方法是放在服务器中防止客户端丢失数据，比方说存储在服务的mongodb</p>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu 服务器中文编码</title>
      <link href="/2018/05/22/linux-server-chinese-encoding/"/>
      <url>/2018/05/22/linux-server-chinese-encoding/</url>
      <content type="html"><![CDATA[<pre><code>nano /etc/environmentLC_CTYPE=&quot;en_US.UTF-8&quot;LC_ALL=&quot;en_US.UTF-8&quot;</code></pre>]]></content>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> practice </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Ubuntu EC2 install Oh My Zsh</title>
      <link href="/2018/05/22/linux-install-zsh/"/>
      <url>/2018/05/22/linux-install-zsh/</url>
      <content type="html"><![CDATA[<ul><li><code>sudo apt-get install zsh</code></li><li>wget <a href="https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh</a> -O - | sh</li><li>sudo chsh -s /bin/zsh</li><li>Check whether your bash is correct: <code>$ cat /etc/passwd</code></li><li>You should have root and ubuntu set as:<pre><code>root:x:0:0:root:/root:/bin/zshubuntu:x:1000:1000:Ubuntu,,,:/home/ubuntu:/bin/zsh</code></pre></li><li>If not, manually change for ubuntu user:<pre><code>sudo -schsh -s /bin/zsh ubuntu</code></pre></li><li>If you change the theme, be sure to install the theme first</li></ul>]]></content>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> practice </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Pypi apt-get 更换镜像</title>
      <link href="/2018/05/22/pypi-apt-change-mirror/"/>
      <url>/2018/05/22/pypi-apt-change-mirror/</url>
      <content type="html"><![CDATA[<h3 id="Pypi"><a href="#Pypi" class="headerlink" title="Pypi"></a>Pypi</h3><ul><li><p>临时使用</p><pre><code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package</code></pre></li><li><p>设默认</p></li></ul><p>没有的话就创建一个以下文件，把 <code>index-url</code>改成tuna,例如</p><pre><code>*    Linux: `~/.config/pip/pip.conf`*    Windows 10: `%APPDATA%\pip\pip.ini`*    Mac OS: `$HOME/Library/Application Support/pip/pip.conf`</code></pre><pre><code>[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple</code></pre><p>如果pip和pip3并存，只需要修改<code>~/.pip/pip.conf</code></p><h3 id="Apt-get"><a href="#Apt-get" class="headerlink" title="Apt-get"></a>Apt-get</h3><p>Ubuntu的软件源配置文件为<code>/etc/apt/sources.list</code></p><ul><li>给系统的list备份</li><li>整个修改sources.list的文件为下文档：</li></ul><pre><code># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse</code></pre><ul><li>修改完毕记得 <code>sudo apt-get update</code></li></ul>]]></content>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> practice </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Flask wsgi 套路文件</title>
      <link href="/2018/05/22/flask-wsgi-default/"/>
      <url>/2018/05/22/flask-wsgi-default/</url>
      <content type="html"><![CDATA[<p>套路文件</p><pre><code class="python">#!/usr/bin/env python3import sysfrom os.path import abspathfrom os.path import dirname# set current directory as working directorysys.path.insert(0, abspath(dirname(__file__)))# import app.py (flask 启动文件)import app# MUST HAVE an applicationapplication = app.app</code></pre><p>对于gunicorn+搭配supervisord部署<br><code>cat /etc/supervisor/conf.d/todo.conf</code><br>在此文件中更改</p><pre><code>[program:todo]command = /usr/local/bin/gunicorn wsgi --bind 0.0.0.0:80 --pid /tmp/todo.piddirectory = /todoautostart = true</code></pre><p>然后</p><pre><code>sudo supervisorctl restart todo</code></pre><p>或者</p><pre><code>sudo service supervisor restart</code></pre><p>默认的日志错误文件在</p><pre><code>cat /var/log/supervisor/todo-stderr---supervisor-WX7Fbz.log</code></pre>]]></content>
      
      
        <tags>
            
            <tag> practice </tag>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python 单下划线，双下划线变量</title>
      <link href="/2018/05/22/python-underline/"/>
      <url>/2018/05/22/python-underline/</url>
      <content type="html"><![CDATA[<h3 id="单下划线开头"><a href="#单下划线开头" class="headerlink" title="单下划线开头"></a>单下划线开头</h3><ul><li>常用于模块中</li><li>单下划线开头<code>_xx</code>变量和函数被默认认为内部函数，treated as <code>private</code> by a programmer. 即如果用<code>from module import *</code>时，这部分的变量和函数不会被导入，但是可以通过<strong>module._xx</strong>来访问</li></ul><h3 id="单下划线结尾"><a href="#单下划线结尾" class="headerlink" title="单下划线结尾"></a>单下划线结尾</h3><ul><li>通常与Python关键词区分开来，比方说一个Python关键词为cls，我也需要定义一个cls，可以写成cls_</li></ul><h3 id="双下划线开头"><a href="#双下划线开头" class="headerlink" title="双下划线开头"></a>双下划线开头</h3><ul><li>This is not a convention. It has a specific meaning to the interpreter.</li><li>Python Name Mangling</li><li><strong>spam(2 leading underline and <strong>at most one trailing underline</strong>) will be replaced with `_classname</strong>spam<code>, where</code>classname` is the current class name.</li><li>If you create a subclass of <code>A</code>, say <code>B</code> then you can’t easily override <code>A&#39;s</code> __method_name</li></ul><pre><code class="Python">&gt;&gt;&gt; class A(object):        def _internal_use(self):            pass        def __method_name(self):            pass&gt;&gt;&gt; dir(A())[&#39;_A__method_name&#39;,...,&#39;_internal_use&#39;]</code></pre><h3 id="双划线开头，双划线结尾"><a href="#双划线开头，双划线结尾" class="headerlink" title="双划线开头，双划线结尾"></a>双划线开头，双划线结尾</h3><ul><li>Python自己的<code>魔术</code>对象, used by Python itself. 比方说<strong>init</strong>, <strong>del</strong>, <strong>add</strong>, <strong>getitem</strong> 以及全局的<strong>file</strong>, <strong>name</strong>等。 不要试图重写他们</li></ul>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>同步、异步、回调、阻塞、非阻塞、线程、进程、协程</title>
      <link href="/2018/05/14/concurrent-async-concept/"/>
      <url>/2018/05/14/concurrent-async-concept/</url>
      <content type="html"><![CDATA[<p>作者：Manjusaka<br>链接：<a href="https://www.zhihu.com/question/266222348/answer/304632928" target="_blank" rel="noopener">https://www.zhihu.com/question/266222348/answer/304632928</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>##同步阻塞：</p><p>举一点不严谨的例子吧你现在要买一本《人体艺术导论》，但是奶茶东缺货。<br>最开始你一直刷新页面，等着书到货了，这是<strong>同步阻塞</strong>。</p><p>##同步非阻塞<br>你觉得这样太浪费时间了。你就去去汤不热看点照片压压惊，然后时不时的去刷一下图书状态是否有货，这是同步非阻塞。</p><p>##异步阻塞<br>好了，你最后成功买到《人体艺术导论》这本书。<br>某一天，你想去再去买一本《知乎撕逼指南》，抱歉你运气很差，还是没货了那么现在你觉得不断的刷是否有货太傻了<br>你现在奶茶东上设置了一下，当有货的时候给你响起 FBI Warning 的闹钟。<br>好了，你现在一直等着闹钟的想起，这叫异步阻塞。</p><p>##异步非阻塞<br>你还是觉得，我怎么能这么傻于是你去干点奇遇事情，等闹钟响起的时候，你就下单。这叫异步非阻塞OK，明白了 前面四个概念么？</p><p>都是在奶茶东买书，<br>基本版的奶茶东，同步，我们只能手动去不断查询书是否有货<br>设置闹钟后的奶茶东，异步，奶茶东可以在有货的时候主动通知我们<br><strong>阻塞</strong>，在书籍有货之前，我们都没法干其余的事情<br><strong>非阻塞</strong>，在书籍有货之前，我们可以干其余的事情</p><p>##回调<br>好了，现在你觉得自己下单太傻了，你在奶茶东上做了更进一步的设置。当这本书有货的时候，帮我下单。这就是回调</p><p>好了，进程，线程，协程<br>你现在要买十本书，每本书都可能没货，现在你觉得这个工作太繁琐了<br>你开了十家公司，每个公司分别帮你购买一本书，公司-&gt;进程<br>你开了一家公司，公司里找了十个人，每个人帮你购买一本书，人-&gt;线程<br>你开了一家公司，找了一个人，用十个手机，每个手机帮你购买一本书，手机-&gt;协程</p><p>##并发并行<br>并发和并行是相对的一个概念<br>并发：交替做不同事的能力<br>并行：同时做不同事的能力</p><p>举个例子，回到买书的问题，有个妹子，找你想让你帮忙买四本书，<br>你找了两个人，一个人买两本书，对于买书的人而言，购买两本书的操作交互进行，这是并发。<br>对你而言，你将四本书分别交给两个人同时购买，这是并行。<br>对于妹子而言，你一个人交替购买四本书，这是并发。</p><p>事件循环是什么？前面不是说了么你购买书，想收到有货通知，想有货自动下单，但是你自己不知道怎么搞定，你把这个事情交给奶茶东。奶茶东-&gt;事件循环</p>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Install R Shiny Server in Ubuntu</title>
      <link href="/2018/05/09/ubuntu-install-shiny-server/"/>
      <url>/2018/05/09/ubuntu-install-shiny-server/</url>
      <content type="html"><![CDATA[<ul><li>Install Python<pre><code>sudo apt-get updatesudo apt-get -y upgrade#type python3 check if python3 is installedsudo apt-get install -y python3-pipsudo apt-get install -y build-essential libssl-dev libffi-dev python3-devsudo apt-get install -y liblzma-dev  libblas-dev gfortrannano ~/.bashrc#type on the top of the filealias python=python3source ~/.bashrc</code></pre></li></ul><ul><li>Install Java<br><code>`</code><br>sudo apt-get install -y default-jre<br>sudo apt-get install -y default-jdk<br>sudo add-apt-repository ppa:webupd8team/java<br>sudo apt-get update<br>sudo apt-get install oracle-java8-installer</li></ul><p>or<br>wget <a href="http://download.oracle.com/otn-pub/java/jdk/8u171-b11/512cd62ec5174c3487ac17c61aaa89e8/jdk-8u171-linux-x64.tar.gz?AuthParam=1530518840_9e538c86b030b30acb4afc0f47a60454" target="_blank" rel="noopener">http://download.oracle.com/otn-pub/java/jdk/8u171-b11/512cd62ec5174c3487ac17c61aaa89e8/jdk-8u171-linux-x64.tar.gz?AuthParam=1530518840_9e538c86b030b30acb4afc0f47a60454</a></p><p>mkdir /apps/<br>tar -zxvf jdk-8u171-linux-x64.tar.gz -C /apps/<br>vi /etc/profile<br>export JAVA_HOME=/apps/jdk1.8.0_171<br>export PATH=$PATH:$JAVA_HOME/bin<br>source /etc/profile</p><pre><code>* Setting JAVA_HOME</code></pre><p>sudo update-alternatives –config java<br>sudo nano /etc/environment<br>JAVA_HOME=”/usr/lib/jvm/java-8-oracle”<br>source /etc/environment<br>echo $JAVA_HOME</p><pre><code>* Install R from source and X11</code></pre><p>sudo apt-get install -y libcurl4-openssl-dev</p><p>#install x11<br>sudo apt-get install -y xvfb xauth xfonts-base</p><p>#Xvfb :0 -ac -screen 0 1960x2000x24 &amp;</p><p>#then set Sys.setenv(“DISPLAY”=”:0”) on top of ui.R</p><p>#install cairo<br>sudo apt-get -y build-dep cairo<br>sudo apt-get install -y libcairo2-dev</p><pre><code>#### If you choose to use cairo, put `options(bitmapType=&#39;cairo&#39;)` on top of the server.R or put it in the Rprofile so that all sessions will read this configuration. [https://stackoverflow.com/questions/17243648/cant-display-png]</code></pre><p>sudo apt-get install libbz2-dev<br>wget <a href="https://mirrors.tuna.tsinghua.edu.cn/CRAN/src/base/R-3/R-3.5.0.tar.gz" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/CRAN/src/base/R-3/R-3.5.0.tar.gz</a><br>tar xzvf R-3.5.0.tar.gz<br>cd R-3.5.0<br>sudo -s<br>./configure –with-readline=no –with-libtiff –with-libjpeg –with-libpng –with-x –with-cairo<br>make<br>make check<br>make install</p><pre><code>Check capabilities:```RRcapabilities()</code></pre><ul><li>Rprofile<br>At startup, R will source the <strong>RProfile.site</strong> file.<br>Then look for a .Rprofile file to source in the current working directory.<br>Not found, it will look for on in ~/.Rprofile.</li></ul><p>[<a href="https://www.r-bloggers.com/fun-with-rprofile-and-customizing-r-startup/]" target="_blank" rel="noopener">https://www.r-bloggers.com/fun-with-rprofile-and-customizing-r-startup/]</a></p><pre><code>In the absence of any command-line flags being used, when R starts up, it will “source” (run) the site-wide R startup configuration file/script if it exists. In a fresh install of R, this will rarely exist, but if it does, it will usually be in ‘/Library/Frameworks/R.framework/Resources/etc/’ on OS X, ‘C:Program FilesRR-***etc’ on Windows, or ‘/etc/R/’ on Debian. Next, it will check for a .Rprofile hidden file in the current working directory (the directory where R is started on the command-line) to source. Failing that, it will check your home directory for the .Rprofile hidden file.</code></pre><p>There are two special functions you can put:</p><pre><code>* **.First()** will run at the start of the R session* **.Last()** will run at the end of the session</code></pre><p>You can check if you have a site-wide R configuration script by running<br><span style="color: red">Create RProfile.site under R.home/etc/</span></p><pre><code class="R">R.home(component = &quot;home&quot;)</code></pre><p>in the R console and then checking for the presence of Rprofile.site in that directory. The presence of the user-defined R configuration can be checked for in the directory of whichever path</p><pre><code class="R">path.expand(&quot;~&quot;)</code></pre><p>Sample Rprofile.site file</p><pre><code># Things you might want to change# options(papersize=&quot;a4&quot;) # options(editor=&quot;notepad&quot;) # options(pager=&quot;internal&quot;)# R interactive prompt # options(prompt=&quot;&gt; &quot;)# options(continue=&quot;+ &quot;) # to prefer Compiled HTML help options(chmhelp=TRUE) # to prefer HTML help # options(htmlhelp=TRUE) # General options options(tab.width = 2) options(width = 130)options(graphics.record=TRUE) options(bitmapType=&#39;cairo&#39;)#.First &lt;- function(){# #library(Hmisc)# #library(R2HTML)# cat(&quot;\nWelcome at&quot;, date(), &quot;\n&quot;) #}#.Last &lt;- function(){ # cat(&quot;\nGoodbye at &quot;, date(), &quot;\n&quot;)#}</code></pre><ul><li>In order to use shinyjs, install V8<pre><code>cd /usr/local/lib/Rsudo mkdir site-librarysudo chmod o+w site-librarysudo apt-get install -y libv8-3.14-devRchooseCRANmirror(81)install.packges(&quot;V8&quot;)</code></pre></li></ul><ul><li>Install R Packages for Shiny<br><code>`</code><br>sudo apt-get install -y libxml2-dev</li></ul><p>sudo su - -c “R -e \”install.packages(c(‘shiny’,’shinydashboard’,’shinyjs’,’quanteda’, ‘dygraphs’, ‘rhandsontable’,’keras’,’DEoptim’,’RSQLite’,’reshape2’,’mlbench’,’future’,’promises’,’shinyWidgets’,’devtools’,’Hmisc’,’XML’,’DT’,’V8’,’shinyBS’), repos=’<a href="https://mirrors.tuna.tsinghua.edu.cn/CRAN/&#39;)\&quot;&quot;" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/CRAN/&#39;)\&quot;&quot;</a></p><p>install.packages(c(‘shiny’,’shinydashboard’,’shinyjs’,’quanteda’, ‘dygraphs’, ‘rhandsontable’,’keras’,’DEoptim’,’RSQLite’,’reshape2’,’mlbench’,’future’,’promises’,’shinyWidgets’,’devtools’,’Hmisc’,’XML’,’DT’,’V8’,’shinyBS’),repos=’<a href="https://mirrors.tuna.tsinghua.edu.cn/CRAN/&#39;" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/CRAN/&#39;</a>)</p><p>sudo apt-get install unzip</p><p>R<br>library(devtools)<br>options(unzip=”internal”)<br>devtools::install_github(‘madlogos/recharts’)</p><p>install.packages(‘rredis’)</p><p>sudo su - -c “R -e \”devtools::install_github(‘lchiffon/REmap’)\””</p><pre><code>* Install keras(h5py),tensorflow</code></pre><p>sudo apt-get install -y python-virtualenv<br>sudo pip3 install tensorflow -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a><br>sudo pip3 install keras -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a></p><pre><code>* Install Shiny Server, check this page[https://www.rstudio.com/products/shiny/download-server/] for the newest package</code></pre><p>sudo apt-get install gdebi-core<br>wget <a href="https://download3.rstudio.org/ubuntu-14.04/x86_64/shiny-server-1.5.7.907-amd64.deb" target="_blank" rel="noopener">https://download3.rstudio.org/ubuntu-14.04/x86_64/shiny-server-1.5.7.907-amd64.deb</a><br>sudo gdebi shiny-server-1.5.7.907-amd64.deb</p><pre><code>* Shiny Server Management</code></pre><p>start shiny-server / sudo systemctl start shiny-server.service<br>stop shiny-server  / sudo systemctl stop shiny-server.service<br>restart shiny-server / sudo systemctl restart shiny-server.service<br>status shiny-server  / sudo systemctl status shiny-server.service<br>sudo reload shiny-server /sudo systemctl reload shiny-server.service</p><pre><code>* Shiny config file    *    conf: `/etc/shiny-server/shiny-server.conf`    *    site: `/srv/shiny-server/`    *    log:  `/var/log/shiny-server.log` or `/var/log/shiny-server/*.log`## Deploy App [https://www.linode.com/docs/development/r/how-to-deploy-rshiny-server-on-ubuntu-and-debian/#deploy-your-app]By default, Shiny Server uses /srv/shiny-server/ as its site directory. Any Shiny apps in this directory will be served automatically.Copy the example app directory into /srv/shiny-server/:</code></pre><p>sudo cp -r Example/ /srv/shiny-server/</p><pre><code>In a web browser, navigate to the app’s address. Replace example.com with your Linode’s public IP address or FQDN:</code></pre><p>example.com:3838/Example</p><pre><code>Create a symbolic link to the actual file system&lt;span style=&quot;color:red&quot;&gt;sudo ln -s /opt/shiny-server/actually_file_location /srv/shiny-server/symbolic_file&lt;/span&gt;## Configure Shiny ServerShiny Server’s configuration file is stored at `/etc/shiny-server/shiny-server.conf`:</code></pre><h1 id="Instruct-Shiny-Server-to-run-applications-as-the-user-“shiny”"><a href="#Instruct-Shiny-Server-to-run-applications-as-the-user-“shiny”" class="headerlink" title="Instruct Shiny Server to run applications as the user “shiny”"></a>Instruct Shiny Server to run applications as the user “shiny”</h1><p>run_as shiny;</p><h1 id="Define-a-server-that-listens-on-port-3838"><a href="#Define-a-server-that-listens-on-port-3838" class="headerlink" title="Define a server that listens on port 3838"></a>Define a server that listens on port 3838</h1><p>server {<br>  listen 3838;</p><h1 id="Define-a-location-at-the-base-URL"><a href="#Define-a-location-at-the-base-URL" class="headerlink" title="Define a location at the base URL"></a>Define a location at the base URL</h1><p>  location / {</p><pre><code># Host the directory of Shiny Apps stored in this directorysite_dir /srv/shiny-server;# Log all Shiny output to files in this directorylog_dir /var/log/shiny-server;# When a user visits the base URL rather than a particular application,# an index of the applications available in this directory will be shown.directory_index on;</code></pre><p>  }<br>}<br><code>`</code></p>]]></content>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Shiny </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>R Concepts</title>
      <link href="/2018/04/18/r-concepts/"/>
      <url>/2018/04/18/r-concepts/</url>
      <content type="html"><![CDATA[<h2 id="apply函数"><a href="#apply函数" class="headerlink" title="apply函数"></a>apply函数</h2><p>通过apply函数，可以实现对数据的循环、分组、过滤、类型控制等操作。</p><p>apply函数可以替代<code>for</code>循环函数。它可以对矩阵、数据框、数组（二维，多维）按行或列进行循环计算，对子元素进行迭代，并把子元素以参数传递的形式给自定义的FUN函数中，并返回计算结果。</p><p><code>apply(X, MARGIN, FUN, ...)</code></p><ul><li>X: 数组、矩阵、数据框</li><li>MARGIN: 按行计算=1， 按列计算=2</li><li>FUN: 自定义调用函数</li><li>…: 更多参数</li></ul><p>例： 对一个矩阵的每一行求和</p><pre><code class="R">&gt; x&lt;-matrix(1:12, ncol=3)&gt; x     [,1] [,2] [,3][1,]    1    5    9[2,]    2    6   10[3,]    3    7   11[4,]    4    8   12&gt; apply(x, 1, sum)[1] 15 18 21 24</code></pre><p>例： 按行循环，让数据框的x1列+1,并计算x1,x2列的均值</p><pre><code class="R">&gt; x &lt;- cbind(x1=3, x2=c(4:1,2:5)); x     x1 x2[1,]  3  4[2,]  3  3[3,]  3  2[4,]  3  1[5,]  3  2[6,]  3  3[7,]  3  4[8,]  3  5# 自定义函数myFUN, 第一个参数x为数据，第二、第三个参数为自定义参数&gt; myFun &lt;- function(x,c1,c2){    c(sum(x[c1],1), mean(x[c2]))}&gt; apply(x,1,myFUN,c1=&#39;x1&#39;,c2=(&#39;x1&#39;,&#39;x2&#39;))    [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8][1,]  4.0    4  4.0    4  4.0    4  4.0    4[2,]  3.5    3  2.5    2  2.5    3  3.5    4</code></pre><h2 id="accessors"><a href="#accessors" class="headerlink" title="[,[[,$ accessors"></a>[,[[,$ accessors</h2><p>[Ref:<a href="https://www.r-bloggers.com/r-accessors-explained/]" target="_blank" rel="noopener">https://www.r-bloggers.com/r-accessors-explained/]</a></p><ul><li><p>Subset with [<br>  取Object子集用[]. 取出来的子集与原object类型相同</p></li><li><p>Extract one item with [[<br>  The double square brackets are used to extract one element from potentially many.<br>  For vectors yield vectors with a single value;<br>  data frames give a column vector;<br>  for list, one element</p><pre><code class="R">  letters[[3]]  iris[[&quot;Petal.Length&quot;]]</code></pre><p>  Remember:</p><ul><li>You can return only one item.</li><li>The result is not (necessarily) the same type of the object as the container</li><li>The dimension will be the dimension of the one item which is not</li></ul></li><li><p>Interact with $<br>  $ is a special case of [[]] in which you access a single item by actual name.</p><p>  The following are equal</p><pre><code class="R">  iris$Petal.Length  iris[[&quot;Petal.Length&quot;]]</code></pre><p>  Remember:</p><ul><li>You cannot use integer indices</li><li>The mane will not be interpolated.</li><li>Returns only one item.</li><li>If the name contains special characters, the name must be enclosed in <strong>“”</strong></li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> R </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>rshiny-concept</title>
      <link href="/2018/04/18/rshiny-concept/"/>
      <url>/2018/04/18/rshiny-concept/</url>
      <content type="html"><![CDATA[<h2 id="Shiny-Scope"><a href="#Shiny-Scope" class="headerlink" title="Shiny Scope"></a>Shiny Scope</h2><h3 id="Per-session-objects"><a href="#Per-session-objects" class="headerlink" title="Per-session objects"></a>Per-session objects</h3><pre><code class="R"># server.RshinyServer(func = function(input, output){        startTime &lt;- Sys.time()    })</code></pre><p><code>func</code> is called each time a web brower is pointed to the Shiny application = is called once for each session.</p><p>所有在func里面的东西是每个session单独实例化的。这包括<code>input</code>和<code>output</code>。<br>每个session有自己的<code>input</code>和<code>output</code>,只在func中可见。 每个session也会有自己的startTime。</p><h3 id="Objects-所有session可见"><a href="#Objects-所有session可见" class="headerlink" title="Objects 所有session可见"></a>Objects 所有session可见</h3><p>适用于需要使用大数据，或者不需要<code>input</code>和<code>output</code>的工具函数的情况。<br>只需要把objects定义在shinyServer之外+inside server.R文件即可。</p><pre><code class="R"># objects visible across all sessionsbigDataSet &lt;- read.csv(&#39;bigdata.csv&#39;)# objects visible across all sessionsutilityFunc &lt;- function(x){}shinyServer(function(input,output){})</code></pre><p>如果要修改共享objects，<strong>需要使用&lt;&lt;-运算符，&lt;-只针对本地变量</strong></p><h3 id="Global-Objects"><a href="#Global-Objects" class="headerlink" title="Global Objects"></a>Global Objects</h3><p>Objects defined in <code>global.R</code>. 与<code>所有Session可见Objects</code>相似，但是不同的是，它同时对于<code>ui.R</code>可见。 这是因为他们被加载到了R session的全局环境中。所有的Shiny app的R代码都是运行在这个全局环境或者其子环境中。</p><p>实际应用中，这个并不常见。<strong><code>ui.R</code>中的代码只会被执行一次，就是当Shiny app启动时。然后它会生成html 文件，缓存然后传给与其相连的浏览器</strong>。 这种所发当设置一些共享配置的时候可能比较有用。</p>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> R </tag>
            
            <tag> shiny </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Flask 一些概念</title>
      <link href="/2018/04/17/flask-concepts/"/>
      <url>/2018/04/17/flask-concepts/</url>
      <content type="html"><![CDATA[<h2 id="URL重定向行文"><a href="#URL重定向行文" class="headerlink" title="URL重定向行文"></a>URL重定向行文</h2><pre><code class="python">@app.route(&#39;/projects/&#39;)def projects():    return &#39;The project page&#39;@app.route(&#39;/about&#39;)def about():    return &#39;The about page&#39;</code></pre><p>注意<a href="mailto:`@app.route" target="_blank" rel="noopener">`@app.route</a>(‘/projects/‘)<code>最末尾的</code>/`，看起来如同一个文件夹。<br><strong>访问一个没有斜杠结尾的URL时，Flask会自动进行重定向，帮你在尾部加上一个斜杠</strong></p><p>但是<a href="mailto:`@app.route" target="_blank" rel="noopener">`@app.route</a>(‘/about’)<code>尾部没有斜杠，如果你在浏览器里面输入了</code>localhost:2000/about/`， 会出现<span style="color: red">404错误</span>    </p><h2 id="url-for（）用于生成制定函数的url"><a href="#url-for（）用于生成制定函数的url" class="headerlink" title="url_for（）用于生成制定函数的url"></a>url_for（）用于生成制定函数的url</h2><p>url_for()会为你处理特殊字符的转义以及Unicode数据</p><pre><code class="python">&gt;&gt;&gt; from flask import Flask, url_for&gt;&gt;&gt; app = Flask(__name__)&gt;&gt;&gt; @app.route(&#39;/&#39;)... def index(): pass...&gt;&gt;&gt; @app.route(&#39;/login&#39;)... def login(): pass...&gt;&gt;&gt; @app.route(&#39;/user/&lt;username&gt;&#39;)... def profile(username): pass...&gt;&gt;&gt; with app.test_request_context():...  print url_for(&#39;index&#39;)...  print url_for(&#39;login&#39;)...  print url_for(&#39;login&#39;, next=&#39;/&#39;)...  print url_for(&#39;profile&#39;, username=&#39;John Doe&#39;)...//login/login?next=//user/John%20Doe</code></pre><h2 id="flask-blueprint"><a href="#flask-blueprint" class="headerlink" title="flask blueprint"></a>flask blueprint</h2><p>flask blueprint用于模块化代码， 如果没有蓝图，那么一个blog系统（分前端和后端）</p><pre><code class="python">from flask import Flask, render_template, reque</code></pre>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 小概念</title>
      <link href="/2018/04/17/linux-concepts/"/>
      <url>/2018/04/17/linux-concepts/</url>
      <content type="html"><![CDATA[<h2 id="amp-后台执行"><a href="#amp-后台执行" class="headerlink" title="&amp; 后台执行"></a>&amp; 后台执行</h2><p>如果在界面输入 <code>./test.sh &amp;</code>会</p><ul><li>在终端显示进程号2333</li><li>test.sh的结果会输出到终端</li><li>输入 <code>Ctrl+C</code>, 会发出<code>SIGINT</code>信号，<strong>程序会继续运行</strong></li><li>但是关掉session之后， 程序会收到<code>SIGHUP</code>信号，<strong>程序关闭</strong></li></ul><h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p>如果在界面输入<code>nohup ./test.sh</code></p><ul><li>前台没有出现进程号</li><li>有一个“忽略输入，输出到nohup.out”的提示</li><li>test.sh里面的结果也没有输出到前台上</li><li>输入<code>Ctrl+C</code>,<strong>进程关闭</strong></li><li>关掉session之后，<strong>进程仍然存在</strong></li></ul><p><span style="color: red">所以一般都是nohup与&amp;共同使用，这样可以让程序同时免疫SIGINT和SIGHUP信号</span></p><h2 id="开新的子进程shell执行"><a href="#开新的子进程shell执行" class="headerlink" title="() 开新的子进程shell执行"></a>() 开新的子进程shell执行</h2><p>单独踢到后台&amp;，如果当前命令界面关掉，这个命令界面执行的所有命令都会被关掉<br>开新的子进程就不会</p><p><code>(python3 server.py &gt;&gt; output.txt &amp; )</code></p><h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><p><code>touch x.txt</code><br>如果x.txt存在就更新修改时间<br>如果x.txt不存在就创建文件</p><h2 id="history-grep"><a href="#history-grep" class="headerlink" title="history/grep"></a>history/grep</h2><p><code>history</code> 查看历史命令<br><code>grep</code> 查找</p><p><code>history | grep touch</code> 把历史记录里所有的touch拿出来</p>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS Install Python3, pip3 and Coexist Python2</title>
      <link href="/2018/04/16/centos-install-python3/"/>
      <url>/2018/04/16/centos-install-python3/</url>
      <content type="html"><![CDATA[<h2 id="Install-Python3"><a href="#Install-Python3" class="headerlink" title="Install Python3"></a>Install Python3</h2><pre><code class="linux">$ sudo yum groupinstall &quot;Development Tools&quot;$ sudo yum -y install zlib*$ sudo mkdir /usr/local/python3 # 创建安装目录# 下载 Python 源文件$ wget --no-check-certificate https://www.python.org/ftp/python/3.6.0/Python-3.6.0.tgz# 注意：wget获取https的时候要加上：--no-check-certificate$ tar -xzvf Python-3.6.0.tgz # 解压缩包$ cd Python-3.6.0 # 进入解压目录$ sudo ./configure --prefix=/usr/local/python3 # 指定创建的目录$ sudo make$ sudo make install</code></pre><h2 id="Python2-Python3-共存"><a href="#Python2-Python3-共存" class="headerlink" title="Python2 Python3 共存"></a>Python2 Python3 共存</h2><p>创建python3软链接<br>这样可以用<code>python</code>命令使用Python2， <code>python3</code>来使用Python3</p><pre><code class="linux">$ sudo ln -s /usr/local/python3/bin/python3 /usr/bin/python3</code></pre><h2 id="默认使用Python3"><a href="#默认使用Python3" class="headerlink" title="默认使用Python3"></a>默认使用Python3</h2><p>先将现有的python备份， 用<code>which python</code>来看：</p><pre><code class="linux">$ which python/usr/bin/python$ cd /usr/bin$ sudo mv python python.bak</code></pre><p>然后创建软链接</p><pre><code class="linux">$ sudo ln -s /usr/local/python3/bin/python3 /usr/bin/python</code></pre><p>这样默认的python版本就替换成Python3了</p><p>另外由于yum使用Python2,替换后python3可能无法正常工作，所以修改yum配置文件</p><pre><code class="linux">sudo vi /usr/bin/yum</code></pre><p>将第一行从 <code>#!/usr/bin/python</code>改为<code>#!/usr/bin/python2.7</code></p><h2 id="Install-Pip3"><a href="#Install-Pip3" class="headerlink" title="Install Pip3"></a>Install Pip3</h2><pre><code class="linux"># 下载源代码$ wget --no-check-certificate https://github.com/pypa/pip/archive/9.0.1.tar.gz$ tar -zvxf 9.0.1.tar.gz    # 解压文件$ cd pip-9.0.1# 使用 Python 3 安装$ python3 setup.py install</code></pre><p>创建软链接</p><pre><code class="linux">$ sudo ln -s /usr/local/python3/bin/pip /usr/bin/pip3</code></pre><p>升级pip</p><pre><code class="linux">$ pip install --upgrade pip</code></pre>]]></content>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> practice </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python pip3 fatal error in launcher</title>
      <link href="/2018/04/16/python-pip3-install-error/"/>
      <url>/2018/04/16/python-pip3-install-error/</url>
      <content type="html"><![CDATA[<p>While installing pymongo:</p><pre><code class="python">Fatal error in launcher: Unable to create process using &#39;&quot;&#39;</code></pre><p>Solution:</p><pre><code class="python">python -m pip install --upgrade pip</code></pre>]]></content>
      
      
        <tags>
            
            <tag> issue </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python class</title>
      <link href="/2018/04/13/python-class/"/>
      <url>/2018/04/13/python-class/</url>
      <content type="html"><![CDATA[<h2 id="class继承"><a href="#class继承" class="headerlink" title="class继承"></a>class继承</h2><pre><code class="python">class Animal(Object)：    def cry(self):        print(&quot;Animal shouts&quot;)class Dog(Animal):    def cry(self):        print(&quot;Wang wang&quot;)&gt;&gt;&gt; dog = Dog()&gt;&gt;&gt; dog.cry() //覆盖了父类Animal的cry()方法Wang wang</code></pre><h2 id="class访问限制"><a href="#class访问限制" class="headerlink" title="class访问限制"></a>class访问限制</h2><p>私有变量，可以把属性的名称前加上<strong>两个</strong>下划线<code>__</code></p><pre><code class="python">class Student(object):    def __init__(self, name, score):        self.__name = name        self.__score = score    def get_name(self):        return self.__name</code></pre><p>但是以<code>__</code>开头<code>__</code>结尾的，是<span style="color: red; font-weight: bold;">特殊变量</span>, 特殊变量可以直接访问，不是private变量</p><p>如果变量名前面只有<strong>一个</strong>下划线<code>_</code>，这样的实例变量外部可以访问，但是by convention, 虽然可以方位，但请把我视为私有变量，不要随意访问</p><p><strong>注意！！！</strong></p><pre><code class="python">&gt;&gt;&gt; bart = Student(&#39;Bart Simpson&#39;, 59)&gt;&gt;&gt; bart.get_name()&#39;Bart Simpson&#39;&gt;&gt;&gt; bart.__name = &#39;New Name&#39; # 这里设置__name变量, 是相当于新加了一个__name变量，而真正的变量已经被Python解释器变为_Student__name&gt;&gt;&gt; bart.__name&#39;New Name&#39;&gt;&gt;&gt; bart.get_name() # get_name()内部返回self.__name&#39;Bart Simpson&#39;</code></pre><h2 id="获得一个对象的所有属性和方法"><a href="#获得一个对象的所有属性和方法" class="headerlink" title="获得一个对象的所有属性和方法"></a>获得一个对象的所有属性和方法</h2><pre><code class="python">&gt;&gt;&gt; dir(&#39;ABC&#39;)[&#39;__add__&#39;, &#39;__class__&#39;,..., &#39;__subclasshook__&#39;, &#39;capitalize&#39;, &#39;casefold&#39;,..., &#39;zfill&#39;]&gt;&gt;&gt; len(&#39;ABC&#39;) #内部相当于调用了该对象的__len__()方法3&gt;&gt;&gt; &#39;ABC&#39;.__len__()3</code></pre><h2 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h2><p>实例绑定属性通过<code>self</code>变量：</p><pre><code class="python">class Student(object):    def __init__(self, name):        self.name = names = Student(&#39;Bob&#39;)s.score = 90</code></pre><p>类属性直接在类下面定义,这个属性可以被所有类的实例访问到</p><pre><code class="python">class Student(object):    name = &#39;Student&#39;&gt;&gt;&gt; s = Student() # 创建实例s&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性Student&gt;&gt;&gt; print(Student.name) # 打印类的name属性Student&gt;&gt;&gt; s.name = &#39;Michael&#39; # 给实例绑定name属性&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性Michael&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问Student&gt;&gt;&gt; del s.name # 如果删除实例的name属性&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了Student</code></pre><h2 id="staticmethod和-classmethod"><a href="#staticmethod和-classmethod" class="headerlink" title="@staticmethod和@classmethod"></a>@staticmethod和@classmethod</h2><p>一般是用类方法需要先实例化一个对象再调用方法<br>但是使用了@staticmethod以及@classmethod，可以直接<code>类名.方法名()</code>调用</p><p>它们的区别：</p><ul><li>@classmethod处理仅跟这个类相关的方法，跟instance无关。当@classmethod被调用的时候，是把这个class作为第一个参数传进去，而不是这个类的实例。也就是说你可以直接在这个@classmethod里面用类属性，而非从一个类实例里面使用</li></ul><ul><li>@staticmethod，当调用这个方法的时候，我们<strong>甚至不用把类传进去</strong>，也就是说我们可以把这个方法放到类里面，但是这个方法其实根本不需要这个类或者实例，比方说设置一些环境参数，更改别的类的属性之类的。</li></ul><pre><code class="python">class Kls(object):    def __init__(self, data):        self.data = data    def printd(self):        print(self.data)    @staticmethod        def smethod(*arg):            print(&#39;Static:&#39;, arg)    @classmethod        def cmethod(*arg):            print(&#39;Class:&#39;, arg)&gt;&gt;&gt; ik = Kls(23)&gt;&gt;&gt; ik.printd()23&gt;&gt;&gt; ik.smethod()Static: ()&gt;&gt;&gt; ik.cmethod()Class: (&lt;class &#39;__main__.Kls&#39;&gt;,)&gt;&gt;&gt; Kls.printd()TypeError: unbound method printd() must be called with Kls instance as first argument (got nothing instead)&gt;&gt;&gt; Kls.smethod()Static: ()&gt;&gt;&gt; Kls.cmethod()Class: (&lt;class &#39;__main__.Kls&#39;&gt;,)</code></pre>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python open() 文件操作</title>
      <link href="/2018/04/13/python-open/"/>
      <url>/2018/04/13/python-open/</url>
      <content type="html"><![CDATA[<p>open()打开一个文件并返回一个<code>file</code>对象</p><pre><code class="python">open(&#39;log.txt&#39;, &#39;a&#39;, encoding=&#39;utf-8&#39;)</code></pre><pre><code class="python">open(name, mode, buffering=1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</code></pre><ul><li>name: 要访问的文件名称</li><li><p>mode:    决定打开文件的模式：</p><p>  模式    |    描述<br>  —    |    —<br>  r    |    默认方式， 只读， 文件指针在文件开头<br>  w    |    写入，如果文件存在覆盖，不存在创建<br>  a     |    打开文件追加，如果文件存在文件指针放在文件结尾，不存在创建<br>  x    |    exclusive creation, fail if file already exists<br>  b     |    二进制格式<br>  t    |    文本格式(默认)    </p><ul><li>|    打开文件读写</li></ul></li></ul><ul><li>buffering： buffering=0,不会寄存; buffering=1,寄存; buffering&gt;1, 表示寄存区的缓冲大写; buffering&lt;0,寄存区缓冲大小为系统默认</li></ul>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>python slice iterator generator</title>
      <link href="/2018/04/12/python-slice-iterator-generator/"/>
      <url>/2018/04/12/python-slice-iterator-generator/</url>
      <content type="html"><![CDATA[<h2 id="Slice切片"><a href="#Slice切片" class="headerlink" title="Slice切片"></a>Slice切片</h2><p>取list/tuple/字符串中的部分元素即切片</p><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><pre><code class="python">&gt;&gt;&gt; L = [&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;, &#39;Bob&#39;, &#39;Jack&#39;]&gt;&gt;&gt; L[0:3] //从索引0的位置开始取，直到索引3，但是不包含索引3，也可以写成L[:3][&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;]&gt;&gt;&gt; L[1:3][&#39;Sarah&#39;, &#39;Tracy&#39;]&gt;&gt;&gt; L[-2:] //取倒数两个[&#39;Bob&#39;, &#39;Jack&#39;]&gt;&gt;&gt; L[-2:-1][&#39;Bob&#39;]</code></pre><h4 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h4><pre><code class="python">&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3](0, 1, 2)</code></pre><h4 id="string"><a href="#string" class="headerlink" title="string"></a>string</h4><pre><code class="python">&gt;&gt;&gt; &#39;ABCDEFG&#39;[:3]&#39;ABC&#39;&gt;&gt;&gt; &#39;ABCDEFG&#39;[::2]&#39;ACEG&#39;</code></pre><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><p>python中<code>for</code>循环可以作用在所有可以迭代的对象上面，与有没有下标无关</p><pre><code class="python">&gt;&gt;&gt; d = {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}&gt;&gt;&gt; for key in d:...     print(key)...acb&gt;&gt;&gt; for value in d.values() //默认情况下dict迭代是的key, 可以用value来迭代&gt;&gt;&gt; for k, v in d.items()</code></pre><p>如何判断是否是可迭代的对象：</p><pre><code class="python">&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance(&#39;abc&#39;, Iterable) # str是否可迭代True</code></pre><p>如果在<code>for</code>循环里面同时引用两个变量：</p><pre><code class="python">&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:...     print(x, y)...1 12 43 9</code></pre><h2 id="List-Comprehensions-列表生成式"><a href="#List-Comprehensions-列表生成式" class="headerlink" title="List Comprehensions 列表生成式"></a>List Comprehensions 列表生成式</h2><pre><code class="python">&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100]</code></pre><p>也可以使用两层循环</p><pre><code class="python">&gt;&gt;&gt; [m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;][&#39;AX&#39;, &#39;AY&#39;, &#39;AZ&#39;, &#39;BX&#39;, &#39;BY&#39;, &#39;BZ&#39;, &#39;CX&#39;, &#39;CY&#39;, &#39;CZ&#39;]</code></pre><h2 id="Generator-生成器"><a href="#Generator-生成器" class="headerlink" title="Generator 生成器"></a>Generator 生成器</h2><p>不是一次性生成所有的list,而是一边循环一边计算，从而节省大量的空间</p><ul><li>生成器就是把列表生成式从[]to()</li></ul><pre><code class="python">&gt;&gt;&gt; L = [x * x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;&gt;&gt;&gt; next(g) //不常用0&gt;&gt;&gt; g = (x * x for x in range(10)) &gt;&gt;&gt; for n in g: //一般是用这样的形式来拿取生成器里面的值...     print(n)... 0149162536496481</code></pre><ul><li>也可以是用<code>yield</code>来生成</li></ul><pre><code class="python">def fib(max):    n, a, b = 0, 0, 1    while n &lt; max:        yield b //如果是print b则不是生成器了        a, b = b, a + b        n = n + 1    return &#39;done&#39;</code></pre><pre><code class="python">&gt;&gt;&gt; for n in fib(6):...     print(n)...112358</code></pre><h2 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h2><p><code>for</code> 除了可以作用于集合类型如： <code>list    tuple    dict    set    str</code><br>还可作用于<code>generator</code></p><p>这些可以直接作用于<code>for</code>循环的对象称为可迭代对象 <code>Iterable</code></p><pre><code class="python">&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance([], Iterable)True</code></pre>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python对象真值</title>
      <link href="/2018/04/12/python-true-value/"/>
      <url>/2018/04/12/python-true-value/</url>
      <content type="html"><![CDATA[<table><thead><tr><th>对象</th><th>值</th></tr></thead><tbody><tr><td>“spam”</td><td>True</td></tr><tr><td>“”</td><td>False</td></tr><tr><td>[]</td><td>False</td></tr><tr><td>{}</td><td>False</td></tr><tr><td>1</td><td>true</td></tr><tr><td>0.0</td><td>False</td></tr><tr><td>None</td><td>False</td></tr></tbody></table>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL select top n</title>
      <link href="/2018/04/11/sql-select-top-n/"/>
      <url>/2018/04/11/sql-select-top-n/</url>
      <content type="html"><![CDATA[<p>If &gt; SQL 2005,</p><pre><code class="sql">select ExcelMediaPlanId,ChannelCN,rankfrom(    select ExcelMediaplanId, ChannelCN,Rank()     over (Partition BY ExcelMediaplanId order by UnitRatecard desc) as rank    from ExcelAdPosition) rs where rank &lt;=3</code></pre><p>or </p><pre><code class="sql">WITH TOPTEN AS (    SELECT *, ROW_NUMBER()     over (        PARTITION BY [group_by_field]         order by [prioritise_field]    ) AS RowNo     FROM [table_name])SELECT * FROM TOPTEN WHERE RowNo &lt;= 10</code></pre><p>or </p><pre><code class="sql">select *from Things twhere t.ThingID in (    select top 10 ThingID    from Things tt    where tt.Section = t.Section and tt.ThingDate = @Date    order by tt.DateEntered desc    )    and t.ThingDate = @Dateorder by Section, DateEntered desc</code></pre><p>In MS Access:</p><pre><code class="sql">SELECT StudentID, TestID, TestScore  FROM MyTable t WHERE TestID IN(  SELECT TOP 3 TestID     FROM MyTable   WHERE StudentID = t.StudentID    ORDER BY TestScore DESC, TestID) ORDER BY StudentID, TestScore DESC, TestID;</code></pre><table><thead><tr><th>StudentID</th><th>TestID</th><th>Score</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>95</td></tr><tr><td>1</td><td>2</td><td>90</td></tr><tr><td>1</td><td>3</td><td>90</td></tr><tr><td>1</td><td>4</td><td>90</td></tr><tr><td>2</td><td>1</td><td>99</td></tr><tr><td>2</td><td>2</td><td>95</td></tr><tr><td>2</td><td>3</td><td>90</td></tr><tr><td>2</td><td>4</td><td>90</td></tr></tbody></table>]]></content>
      
      
        <tags>
            
            <tag> practice </tag>
            
            <tag> MSSQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CentOS Install Java8</title>
      <link href="/2018/04/02/centos-install-java8/"/>
      <url>/2018/04/02/centos-install-java8/</url>
      <content type="html"><![CDATA[<h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><pre><code class="linux">cd /opt/wget --no-cookies --no-check-certificate --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie&quot; &quot;http://download.oracle.com/otn-pub/java/jdk/8u161-b12/2f38c3b165be4555a1fa6e98c45e0808/jdk-8u161-linux-x64.tar.gz&quot;tar xzf jdk-8u161-linux-x64.tar.gzcd /opt/jdk1.8.0_161/alternatives --install /usr/bin/java java /opt/jdk1.8.0_161/bin/java 2alternatives --config javaThere are 3 programs which provide &#39;java&#39;.  Selection    Command-----------------------------------------------*  1           /opt/jdk1.7.0_71/bin/java + 2           /opt/jdk1.8.0_45/bin/java   3           /opt/jdk1.8.0_144/bin/java   4           /opt/jdk1.8.0_161/bin/javaEnter to keep the current selection[+], or type selection number: 4</code></pre><h2 id="Setup-javac-and-jar-commands-path-using-alternatives"><a href="#Setup-javac-and-jar-commands-path-using-alternatives" class="headerlink" title="Setup javac and jar commands path using alternatives"></a>Setup javac and jar commands path using <code>alternatives</code></h2><pre><code class="linux">alternatives --install /usr/bin/jar jar /opt/jdk1.8.0_161/bin/jar 2alternatives --install /usr/bin/javac javac /opt/jdk1.8.0_161/bin/javac 2alternatives --set jar /opt/jdk1.8.0_161/bin/jaralternatives --set javac /opt/jdk1.8.0_161/bin/javac</code></pre><h2 id="Check-installed-java-version"><a href="#Check-installed-java-version" class="headerlink" title="Check installed java version"></a>Check installed java version</h2><pre><code class="linux">java -versionjava version &quot;1.8.0_161&quot;Java(TM) SE Runtime Environment (build 1.8.0_161-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)</code></pre><h2 id="Setup-Java-Environment-Variables"><a href="#Setup-Java-Environment-Variables" class="headerlink" title="Setup Java Environment Variables"></a>Setup Java Environment Variables</h2><pre><code class="linux">export JAVA_HOME=/opt/jdk1.8.0_161export JRE_HOME=/opt/jdk1.8.0_161/jreexport PATH=$PATH:/opt/jdk1.8.0_161/bin:/opt/jdk1.8.0_161/jre/bin</code></pre>]]></content>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> practice </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux-process-to-backend</title>
      <link href="/2018/03/28/linux-process-to-backend/"/>
      <url>/2018/03/28/linux-process-to-backend/</url>
      <content type="html"><![CDATA[<p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-nohup/" target="_blank" rel="noopener">Ref: Linux 技巧：让进程在后台可靠运行的几种方法</a></p><p>如果SSH登陆了远程Linux服务器，经常为Connection Timeout, 这样会自动kill掉正在运行的任务。<br>如何让命令提交后不受本地关闭终端窗口/网络断开连接的干扰？</p><h2 id="nohup-setsid-amp"><a href="#nohup-setsid-amp" class="headerlink" title="nohup/setsid/&amp;"></a>nohup/setsid/&amp;</h2><p>当用户注销logout或者网络断开时终端会收到<code>HUP</code>(hangup) 信号从而关闭所有子进程。<br>因此为解决这个问题：<br>要么让进程忽略HUP信号<br>要么让进程运行在新的会话里从而成为不属于此终端的子进程</p><ol><li>nohup， 让进程忽略HUP信号</li></ol><p>nohup，标准输出和标准错误缺省会被重定向到nohup.out文件中。<br>一般我们可在结尾加上<code>&amp;</code>来将命令同时放入后台运行</p><pre><code>[root@pvcent107 ~]# nohup ping www.ibm.com &amp;[1] 3059nohup: appending output to `nohup.out&#39;[root@pvcent107 ~]# ps -ef |grep 3059root      3059   984  0 21:06 pts/3    00:00:00 ping www.ibm.comroot      3067   984  0 21:06 pts/3    00:00:00 grep 3059[root@pvcent107 ~]#</code></pre><ol><li>setsid</li></ol><p>如果进程不属于接受HUP信号的终端的子进程，就要用setsid.</p><pre><code>[root@pvcent107 ~]# setsid ping www.ibm.com[root@pvcent107 ~]# ps -ef |grep www.ibm.comroot     31094     1  0 07:28 ?        00:00:00 ping www.ibm.comroot     31102 29217  0 07:29 pts/4    00:00:00 grep www.ibm.com[root@pvcent107 ~]#</code></pre><p>注意的是我们的进程31094其父进程为1（<code>即为init进程ID</code>），<strong>并不是当前终端的进程ID</strong></p><ol><li>&amp;</li></ol><p>将<code>&amp;</code>也放入<code>()</code>,所提交的作业不会出现在作业列表中，就是无法通过jobs来查看。<br>subshell示例:</p><pre><code>[root@pvcent107 ~]# (ping www.ibm.com &amp;)[root@pvcent107 ~]# ps -ef |grep www.ibm.comroot     16270     1  0 14:13 pts/4    00:00:00 ping www.ibm.comroot     16278 15362  0 14:13 pts/4    00:00:00 grep www.ibm.com[root@pvcent107 ~]#</code></pre><p>新提交的进程父ID为1（init进程ID）</p>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SSIS Cannot Import Package</title>
      <link href="/2018/03/26/SSIS-CanNotImportPackage/"/>
      <url>/2018/03/26/SSIS-CanNotImportPackage/</url>
      <content type="html"><![CDATA[<p>Error:</p><pre><code>The SQL Server instance specified in SSIS service configuration is not present or is not available. This might occur when there is no default instance of SQL Server on the computer. For more information, see the topic &quot;Configuring the Integration Services Service&quot; in Server 2008 Books Online.Login failed for user &#39;XXXXX&#39;. (MsDtsSrvr)</code></pre><p>Solution:</p><p>Add the user XXXX as a login to the SQL server<br>with sys_admin rights to msdb</p>]]></content>
      
      
        <tags>
            
            <tag> SSIS </tag>
            
            <tag> issue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ASP.NET MVC Request Life Cycle</title>
      <link href="/2018/03/26/asp-net-mvc-lifecycle/"/>
      <url>/2018/03/26/asp-net-mvc-lifecycle/</url>
      <content type="html"><![CDATA[<p><a href="https://www.codeproject.com/Articles/1028156/A-Detailed-Walkthrough-of-ASP-NET-MVC-Request-Life" target="_blank" rel="noopener">Ref A Detailed Walkthrough of ASP.NET MVC Request Life Cycle</a></p><p>This is mainly for <strong>Page Life Cycle</strong> other than <strong>Application Life Cycle</strong>.<br>A typical <strong>Application Life Cycle</strong> contains <strong>Application Start</strong> and <strong>Application End events</strong> while <strong>Http Life Cycle</strong> is something which is repeated for every request.</p><h2 id="MVC-Request-Life-Cycle"><a href="#MVC-Request-Life-Cycle" class="headerlink" title="MVC Request Life Cycle"></a>MVC Request Life Cycle</h2><img src="/2018/03/26/asp-net-mvc-lifecycle/mvc-life-cycle.png"><h3 id="URL-Routing-Module"><a href="#URL-Routing-Module" class="headerlink" title="URL Routing Module"></a>URL Routing Module</h3><p>The incoming request from <strong>IIS pipeline</strong> is handed over to URL Routing module which analyses the request and looks up <strong>Routing table</strong> to figure out which controller the incoming request maps to.</p><p>Routing table is a static container of routes defined in MVC application with corresponding controller action mapping. If the route is found in the routing table <code>MVCRouteHandler</code> executes and bring s the instance of <code>MVCHttpHandler</code>.</p><p><code>MVC handler</code> begins initializing and executing controller. The <code>MVCHttpHandler</code> also takes of converting route data into concrete controller that is capable of serving the request. <code>MVC handler</code> does all this with the help of MVC Controller factory and activator which are responsible for creating an instance of the controller. <span style="background-color: #FFFF00">This is also the place where the Dependency Injection is performed if the application has been designed to invoke parameterized controller constructor and satisfy its dependencies</span>.</p><p>After the controller instance is created <strong>the next major step is to find and execute the corresponding action</strong>. A component called ActionInvoker finds and executes the action defined in routing table. Before the action method is called model bindings takes place which maps data from http request to action method parameters. After the model binding, action filters are invoked which includes OnActionExecuting filter. This is followed by action execution and Action Executed filter execution and finally preparing Action Result.</p><p>Once the Action method has been finished executing the next step is Result execution. MVC separates the action declaration from Result execution. If the Result from action execution is view, then depending upon configuration, ASPX or Razor view engine will be called to find and render the html view as a response of http request. If the result was not view then it’s passed as-is to http response.</p><h2 id="Application-Life-Cycle"><a href="#Application-Life-Cycle" class="headerlink" title="Application Life Cycle"></a>Application Life Cycle</h2><p>MVC application life cycle contains two application level events that are associated with start and end events of the application. Application start fires <strong>when the application is brought to life by a very first request</strong> to the application. Application end event is fired <strong>when application has been shut down</strong>.</p><p>It’s important to understand application life cycle events to get a better understanding on how MVC life cycle starts. So far we have seen that URL Routing module is the starting point for MVC application that has a collection of predefined routes to map from. Now, the question here is <strong>how does URL routing handler gets this information from</strong>? The answer is simple, using Application start event. MVC applications provide these events in Global.asax file which contains all the application level events. All the prestart things are managed in the application start event.</p><p>MVC Application_Start event is:</p><ul><li>An event that fires when first request is received.</li><li>Can be used to <strong>run initial configuration and settings code</strong></li><li>The event takes care of <strong>registering all areas of MVC application, installing global filters, adding routes and bundles</strong>.</li></ul><h2 id="Register-Routes"><a href="#Register-Routes" class="headerlink" title="Register Routes"></a>Register Routes</h2><p>Since Application_start event is the first event that gets called when application receives its very first request, <strong>all the pre application tasks like routing takes place here</strong>.</p><p>As you see in the diagram below ResolveRequestCache needs to know the routes to choose from, and this needs to have static route collection already created.</p><img src="/2018/03/26/asp-net-mvc-lifecycle/register-routes.png"><h2 id="HttpHandlers"><a href="#HttpHandlers" class="headerlink" title="HttpHandlers"></a>HttpHandlers</h2><p>HttpHandlers are classes that implement <code>IHttpHandler</code> and generate a response to <code>HttpRequest</code>. There could be httpHandler re-assignment in a life cycle of a request but only on http handler executes and provides response.</p><h3 id="Create-HttpHandler"><a href="#Create-HttpHandler" class="headerlink" title="Create HttpHandler:"></a>Create HttpHandler:</h3><pre><code>public class SampleHttlHandler : IHttpHandler{    public book IsReusable { get{ return false;}}    public void ProcessRequest (HttpContext context)    {        context.Response.Write(&quot;&lt;b&gt;This is the response from HttpHandler&lt;/b&gt;&quot;)    }}</code></pre><h2 id="HttpModules"><a href="#HttpModules" class="headerlink" title="HttpModules"></a>HttpModules</h2><p>HttpModules are classes that implement <code>IHttpModule</code> interface and are designed to respond to Life cycle events. In a given Http Life cycle, multiple http modules <strong>can respond to one single request and can also hook into multiple life cycle events</strong>. So they are not tied to any specific event, rather they can act at several places during the life cycle and expose multiple development possibilities.</p><p>Features such as <span style="background-color: #FFFF00"><strong>Logging and Authentication</strong></span> are best examples of wrapping things up in a HttpModule. </p>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Func</title>
      <link href="/2018/03/25/Func/"/>
      <url>/2018/03/25/Func/</url>
      <content type="html"><![CDATA[<p><code>Func&lt;T1,T2,...,Tn,Tr&gt;</code> represents a function that takes <code>(T1, T2, ..., Tn)</code> and returns <code>Tr</code></p><p>E.g., you have function:</p><pre><code>double sqr(double s){    return x*x;}</code></pre><p>You could save it as some kind of a function-variable:</p><pre><code>Func&lt;double, double&gt; f1 = sqr;Func&lt;double, double&gt; f2 = x=&gt; x*x;</code></pre><p>And then use exactly as you would use sqr:</p><pre><code>f1(2);f2(f1(4))</code></pre><p>.</p>]]></content>
      
      
        <tags>
            
            <tag> c# </tag>
            
            <tag> concept </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ASP.NET Identity 原理</title>
      <link href="/2018/03/25/asp-net-identity/"/>
      <url>/2018/03/25/asp-net-identity/</url>
      <content type="html"><![CDATA[<p>转自:<br><a href="http://www.cnblogs.com/jesse2013/p/aspnet-identity-claims-based-authentication-and-owin.html" target="_blank" rel="noopener">MVC5 - ASP.NET Identity登录原理 - Claims-based认证和OWIN</a></p><p>实现登录实际上只有简单的三行代码</p><pre><code>private IAuthenticationManager AuthenticationManager{    get{        return HttpContext.GetOwinContext().Authentication;    }}private async Task SignInAsync(){    //1.    利用ASP.NET Identity获取用户对象    var user = await UserManager.FindAsync(&quot;UserName&quot;,&quot;Password&quot;);    //2.    利用ASP.NET Identity获取Identity对象    var identity = await UserManager.CreateIdentityAsync(user, DefaultAuthenticationTypes.ApplicationCookie);    //3.    将上面拿到的identity对象登录    AuthenticationManager.SignIn(new AuthenticationProperties(){        IsPersistent = true        }, identity);}</code></pre><p><code>CreateIdentityAsync</code>返回的是一个ClaimsIdentity，这又是什么？</p><h2 id="Claim-baised-Identity"><a href="#Claim-baised-Identity" class="headerlink" title="Claim-baised Identity"></a>Claim-baised Identity</h2><p>Claim-based 认证将Authentication 和 Authorization 与login 分开，将Authentication 和 Authorization 拆分为另外的web服务。</p><p>主要特点：</p><ul><li>将认证与授权拆分成独立的服务</li><li>服务调用者不需要关注如何去认证</li><li>如果用户成功登陆，认证服务会返回令牌</li><li>服务调用者从令牌中读取所需信息，诸如用户名以及角色信息等</li></ul><p>例如QQ登陆：</p><ol><li>用户到网站访问一个需要登录的页面</li><li>网站检测到用户没有登录，返回一个跳转到QQ的登录页响应（<strong>302</strong>指向QQ登录页面的地址并加上一个返回的链接页面，通常为returnUrl=)</li><li>用户被跳转到指定的QQ登录页</li><li>用户在QQ登录页面上输入用户名和密码，QQ会在自己的数据库中查询，一旦登陆成功，会返回一个跳转到我们站点的响应（<strong>302指向我们的网站页面</strong>)</li><li>用户被跳转到我们网站的一个检测登录的页面，我们可以拿到用户的身份信息，建立<strong>ClaimsPrincipal</strong>和<strong>ClaimsIdentity</strong>对象，生成<strong>cookie</strong>等</li><li>我们再把用户带到指定的页面，也就是returnUrl，那是用户登录前最后一次访问的页面</li></ol><img src="/2018/03/25/asp-net-identity/qq-claim-based-login.png"><h2 id="ClaimsIdentity-ClaimsPrincipal"><a href="#ClaimsIdentity-ClaimsPrincipal" class="headerlink" title="ClaimsIdentity, ClaimsPrincipal"></a>ClaimsIdentity, ClaimsPrincipal</h2><p>ClaimsIdentity和ClaimsPrincipal继承了接口IIdentity和IPrincipal</p><p><strong>Identity</strong></p><pre><code class="c#">public interface IIdentity{    string AuthenticationType { get; }    bool IsAUthenticated { get; }    string Name { get; }}</code></pre><p><strong>IPrincipal</strong><br>IPrincipal代表了一个安全<strong>上下文</strong>，这个上下文对象包含了上面identity以及一些角色和组的信息，每一个线程都会关联一个Principal的对象，但是这个对象是<span style="background-color: #FFFF00">属性进程或者AppDomain级别的</span>.</p><p><a href="https://stackoverflow.com/a/27108829/4336416" target="_blank" rel="noopener">Ref: What is the idea behind IIdentity and IPrincipal in .NET</a></p><p><code>IIdentity</code> is just used for the user’s authenticated identity, regardless of what roles they may have.</p><p><code>IPrincipal</code> is used to combine a user’s identity with the <code>authorized</code> roles they have in a given security context.</p><p>For example, you can use a third-party login provider, like Facebook or Google, to get the user’s identity, but you will not get a principal from those providers, as they don’t provide any roles. You can use your own application or a third-party role-based authorization provider to apply roles to , say, a <code>FacebookIdentity</code> or <code>GoogleIdentity</code>. A different application can expect a different principal, with its own roles , but still use the same identity as in another application</p><p>例子：</p><pre><code class="c#">public class HomeController : Controller{    [Authorize(Role = &quot;Users&quot;)]    public ActionResult Index(){        return View();    }    [Authorize(Roles = &quot;Managers&quot;)]    public ActionResult Manager()    {        return View();    }}</code></pre><p>登录, 在global.asax中添加了Application_AuthenticateRequest方法，<strong>就是每次MVC要对用户进行认证的时候都会进到这个方法里面</strong>，然后就神奇的把用户给登陆了。</p><pre><code class="c#">protected void Application_AuthenticateRequest(){    var claims = new List&lt;Claim&gt;();    claims.Add(new Claim(ClaimTypes.Name, &quot;Zhang san&quot;));    claims.Add(new Claim(ClaimTypes.Role, &quot;Users&quot;));    var identity = new ClaimsIdentity(claims, &quot;MyClaimsLogin&quot;);    ClaimsPrincipal principal = new ClaimsPrincipal(identity);    HttpContext.Current.User = principal;}</code></pre><p>最后结论，我们讲了ClaimsIdentity什么的，讲了这么多和今天的主题有嘛关系？我们上面说ASPNET Identity登录有三句话，第一句话可以略过，第二句话就是我们上面讲的。</p><pre><code>var identity = await UserManager.CreateIdentityAsync(user, DefaultAuthenticationTypes.ApplicationCookie);</code></pre><p>UserManager实际上只是为我们创建了一个ClaimsIdentity的对象，还是通过我们自己从数据库里面取出来的对象来创建的，它也就干了那么点事，一层小小的封装而已。不要被后面的DefaultAuthenticationTypes.ApplicationCookie吓到了，这里还没有和cookie扯上半点关系，这就是一个字符串常量，和我们上面自己定义的MyClaimsLogin是没有区别的。</p><p>到这里，我想算是把登录代码的第二句话讲完了，讲清楚了，那么我们来看看第三句话，也就是最后一句，其实它才是登录的核心，第二句只是创建了一个ClaimsIdentity的对象。</p><pre><code>private IAuthenticationManager AuthenticationManager{    get { return HttpContext.GetOwinContext().Authentication; }}AuthenticationManager.SignIn(new AuthenticationProperties() { IsPersistent = true }, identity);</code></pre><p>IAuthenticationManager 在<code>Microsoft.Owin.Security</code>命名空间下，而这个接口是定义在Microsoft.Owin.dll中。</p><p>##Owin</p><p>OWIN目标是解耦服务器和应用，这里面的服务器主要是指web服务器，比如说IIS等，那么是如何做到的呢？</p><p><strong>解耦服务器与应用程序</strong><br>首先需要复习ASP.NET或者<span style="background-color: #FFFF00">IIS集成模式管道模型</span>，也就是说一个http请求在进入IIS之后（IIS7.0以上）一直到返回response这中间所经历的步骤。</p><img src="/2018/03/25/asp-net-identity/netpipe.png"><img src="/2018/03/25/asp-net-identity/mvc-request-lifecycle.png"><p><a href="https://www.codeproject.com/Articles/1028156/A-Detailed-Walkthrough-of-ASP-NET-MVC-Request-Life" target="_blank" rel="noopener">Ref: A Detailed walkthrough of ASP.NET MVC Request lifecycle</a></p><p>我们可以开发自己的HttpModule(比方说是MyFormsModules)去注册这些事件，然后做相应的处理。比方说<code>FormsAuthenticationModule</code>就是注册了<code>AuthenticateRequest</code>事件，然后在这里去检查用户的cookie信息来判断用户是否登录了，这就是一个典型的<strong>应用程序与服务器之间的交互</strong>问题，而这些事件最后是被IIS触发的,我们是通过web.config把我们自定义的http module注册进了IIS，但是<strong>如果我们的网站不运行在IIS了，我们自己开发的这些HTTP module还能用么？</strong></p><p>另一个，我们<code>Request</code>和<code>Response</code>都是封装在<code>HttpContext</code>里面的，而这些信息从IIS里面来，最后也是交给IIS，如果web服务器不是IIS，那么这些信息从哪里获取呢？</p><p>所以能够看出来，应用程序和服务器之间的耦合很大。我们不能够轻易换掉其中任何一个。</p><h2 id="OWIN如何做到解耦"><a href="#OWIN如何做到解耦" class="headerlink" title="OWIN如何做到解耦"></a>OWIN如何做到解耦</h2><p>它通过将服务器与应用程序之间的交互归纳为一个方法签名，称之为”应用程序代理(application delegate)”</p><pre><code>AppFunc = Func&lt;IDictionary&lt;string, object&gt;, Task&gt;;</code></pre><p>在一个基于Owin的应用程序中的每一个组件都可以通过这样的一个代理来与服务器进行交互。 这们这里的交互其实是与服务器一起来处理http request，比如说ASP.NET管理模型中的那些事件，认证，授权，缓存等等，原先我们是通过自定义的http module，在里面拿到包含了request和response的HttpContext对象，进行处理。而现在我们能拿到的就是一个Dictionary。</p><p>可是别小看了这个Dictionary，我们所有的信息比如Application state, request state，server state等等这些信息全部存在这个数据结构中。这个dictionary会在Owin处理request的管道中进行传递，没错有了OWin之后，我们就不再是与ASP.NET 管道打交道了，而是OWin的管道，但是这个管道相对于ASP.NET 管道而言更灵活，更开放。</p><p>这个字典在OWin管道的各个组件中传输时，你可以任意的往里面添加或更改数据。 OWin默认为我们定义了以下的数据：<br><img src="/2018/03/25/asp-net-identity/owin-defaults.png"></p><p>有了这些数据以后，我们就不需要和.NET的那些对象打交道了，比如说ASP.NET MVC中的HttpContextBase, 以及WEB API  中的HttpRequestMessage和HttpResponseMessage。我们也不需要再考虑system.web 这个dll里的东西，我们只需要通过OWin就可以拿到我们想要的信息，做我们想做的事了。而OWin，它本身和web服务器或者IIS没有任何关系。</p><h2 id="Forms-Authentication"><a href="#Forms-Authentication" class="headerlink" title="Forms Authentication"></a>Forms Authentication</h2><p>在Forms认证中我们检测完用户名和密码之后，只需要调用小面的代码就会为我们创建用户cookie.</p><pre><code>FormsAuthentication.SetAuthCookie(&quot;Jesse&quot;, false);</code></pre><p>然后FormsAuthenticationModule(<strong>这就是一个HTTP Module</strong>)会在ASP.NET管道的AuthenticateRequest阶段去检查是否有这个cookie，并把它转换成我们需要的Identity对象，这样的话我们就不需要每一次都让用户去输入用户名和密码了。所以登录过程如下：<br>1。    用户在没有登录的情况下访问了我们需要登录的页面</p><ol><li>FormsAuthenticationModule检查不到用户身份的cookie，没有生成identity对象，HttpContext.User.IsAuthenticated = false</li><li>在ASP.NET 管道 的Authroize 授权阶段，将用户跳转到登录页面</li><li>用户输入用户名和密码点击提交</li><li>我们检查用户名和密码，如果正确，就调用FormsAuthentication.SetAuthCookie方法生成登录cookie</li><li>用户可以正常访问我们需要登录的页面了</li><li>用户再次访问我们需要登录的页面</li><li>FormsAuthenticationModule检查到了用户身份的cookie，并生成identity对象，HttpContext.User.IsAuthenticated = true</li><li>ASP.NET 管道的 Authroize授权阶段，HttpContext.User.IsAuthenticated=true，可以正常浏览</li><li>7,8,9循环</li></ol><p><strong>Forms Authentication有以下不足</strong></p><ol><li>用户名直接暴露在cookie中，需要额外的手段去将cookie加密</li><li>不支持claim-based认证</li></ol><p>我们上面Forms的登录过程，对于OWin登录来说同样适用。我们在上面讲ASP.NET Identity登录第二句话的时候已经拿到了ClaimsIdentity，那么我们接下来要看的问题就是如何借助于IAuthenticationManager 去登录？ FormsAuthenticationModuel没有了，谁来负责检测cookie？您请接着往下看！</p><h2 id="MVC5默认的StartUp配置类"><a href="#MVC5默认的StartUp配置类" class="headerlink" title="MVC5默认的StartUp配置类"></a>MVC5默认的StartUp配置类</h2><p>VS除了为我们引用OWin相关dll，以及移除FormsAuthenticationModule以外，还为我们在App_Start文件夹里添加了一个Startup.Auth.cs的文件。</p><pre><code>public partial class Startup{    public void ConfigureAuth(IAppBuilder app)    {        app.UseCookieAuthentication(new CookieAuthenticationOptions            {                AuthenticationType = DefaultAuthenticationTypes.ApplicationCookie,                LoginPath = new PathString(&quot;/Account/Login&quot;),                CookieSecure = CookieSecureOption.Never,            });    }}</code></pre><p>UseCookieAuthentication是一个IAppBuilder的扩展方法，定义在Microsoft.Owin.Security.Cookies.dll中</p><pre><code>public static IAppBuilder UseCookieAuthentication(this IAppBuilder app, CookieAuthenticationOptions options){    if(app == null)    {        throw new ArgumentNullException(&quot;app&quot;);    }    //添加OWIN middleware组件到OWIN管道    app.Use(typeof(CookieAuthenticationMiddleware), app, options);    //为前面添加的Middleware指定在IIS管道的哪个阶段执行    app.UseStageMarker(PipelineStage.Authenticate);    return app;}</code></pre><p>PipelineStage这个枚举定义与IIS管道里的那些顺序同，也是我们Http Module里面可以绑定的那些事件：</p><pre><code>public enum PipelineStage{    Authenticate = 0,    PostAuthenticate = 1,    Authorize = 2,    PostAuthorize = 3,    ResolveCache = 4,    PostResolveCache = 5,    MapHandler = 6,    PostMapHandler = 7,    AcquireState = 8,    PostAcquireState = 9,    PreHandlerExecute = 10,}</code></pre><p>也就是说我们上面注册的CookieAuthenticationMiddleware会在AuthenticaRequest 阶段执行。而它就是真正生成cookie以及读取cookie的那只背后的手。<br>顺便回顾一下如何在http module中为Authenticate绑定事件：</p><pre><code>public class MyModule : IHttpModule{    public void Init(HttpApplication context)    {        context.AuthenticateRequest += ctx_AuthRequest;    }    void vtx_AuthRequest(object sender, EventArgs e)    {    }}</code></pre><p>.</p>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> .NET </tag>
            
            <tag> Identity </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>c# constructor chaining</title>
      <link href="/2018/03/25/c-contructor-chaining/"/>
      <url>/2018/03/25/c-contructor-chaining/</url>
      <content type="html"><![CDATA[<p>Consider this sample:</p><pre><code>class Student {    string _studengType = &quot;&quot;;    string _id = &quot;&quot;;    string _fName = &quot;&quot;;    string _lName = &quot;&quot;;    public Student(string id) : this(id, &quot;&quot;, &quot;&quot;){    }    public Student(stirng id, string fName) : this(id, fName, &quot;&quot;){    }    public Student(string id, string fName, string lName){        //Validation logic...        _studentType = &quot;&lt;student_type&gt;&quot;;        _id = id;        _fName = fName;        _lName = lName;    }}</code></pre><p>通过this，调用第三个构造参数，可以复用id赋值的这个语句：<br><code>_id = id;</code></p><p>这样就不用每个构造函数都写这个逻辑，只需要用那个有最多参数构造函数即可</p>]]></content>
      
      
        <tags>
            
            <tag> c# </tag>
            
            <tag> concept </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>windows身份验证</title>
      <link href="/2018/03/22/windows-authentication/"/>
      <url>/2018/03/22/windows-authentication/</url>
      <content type="html"><![CDATA[<h3 id="IPrincipal-amp-IIdentity"><a href="#IPrincipal-amp-IIdentity" class="headerlink" title="IPrincipal &amp; IIdentity"></a>IPrincipal &amp; IIdentity</h3><p>IPrincipal定义用户对象的基本功能<br>IIdentity定义标识对象的基本功能</p><h3 id="Windows-Authentication-过程"><a href="#Windows-Authentication-过程" class="headerlink" title="Windows Authentication 过程"></a>Windows Authentication 过程</h3><p>IIS传递给Asp.Net一个Windows Token, 用这个Token创建一个<code>WindowsIdentity</code>对象,然后根据<code>WindowsIdentity</code>创建<code>WindowsPrincipal</code>对象，之后将这个对象赋值给<code>HttpContext.User</code></p><pre><code>token = context.WorkerRequest.GetUserToken()</code></pre><h3 id="Form-Authentication-过程"><a href="#Form-Authentication-过程" class="headerlink" title="Form Authentication 过程"></a>Form Authentication 过程</h3><p>通过用户名和密码创建一个包含<code>FormsAuthenticationTicket</code>的登陆<code>Cookie</code>, ASP.NET 解析登陆的<code>Cookie</code>然后创建一个<code>GenericPrincipal</code>对象,这个对象包含<code>FormsIdentity</code>,之后把这个Principal对象赋值给<code>HttpContext.User</code></p><p>REF:<br><a href="https://www.cnblogs.com/fish-li/archive/2012/05/07/2486840.html" target="_blank" rel="noopener">细说ASP.NET Windows身份认证</a></p>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> practice </tag>
            
            <tag> Asp.Net </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DNS Resolution in Private Subnet with VPN to on-premises network</title>
      <link href="/2018/03/20/dns-forwarding/"/>
      <url>/2018/03/20/dns-forwarding/</url>
      <content type="html"><![CDATA[<h3 id="DNS-Forwarding-Definition"><a href="#DNS-Forwarding-Definition" class="headerlink" title="DNS Forwarding Definition"></a>DNS Forwarding Definition</h3><p>DNS forwarding is the process by which particular sets of DNS queries are handled by a designated server, rather than being handled by the initial server contacted by the client. Usually, all DNS servers that handle address resolution within the network are configured to forward requests for addresses that are outside the network to a dedicated forwarder.<br><a href="http://social.dnsmadeeasy.com/blog/understanding-dns-forwarding/" target="_blank" rel="noopener">reference doc</a></p><h3 id="Issue"><a href="#Issue" class="headerlink" title="Issue"></a>Issue</h3><p>AWS EC2 instances in private subnet cannot resolve dns names.<br>But EC2 instances can communicate with corporate network through VPN, the corporate network is able to correctly resolve dns.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>Change private subnet dns server to corporate dns server.</p><ul><li><p>How to see current network dns server:</p><ul><li>windows: <code>ipconfig/all --&gt; dns server</code></li><li>linux:<br>  <code>cat /etc/resolv.conf</code> can show your DNS servers</li></ul></li><li><p>How to check if corporate dns is success or not:</p><ul><li>windows: <ul><li><code>nslookup</code></li><li>type <code>server 10.82.XX.XX</code>, where <code>10.82.XX.XX</code> is your corporate dns server ip address</li><li>type any dns name, like baidu.com, bing.com, and press <code>Enter</code></li><li>check if the ip address is returned:<img src="/2018/03/20/dns-forwarding/nslookup.png"></li></ul></li><li>linux(centos):<ul><li>normally <code>dig baidu.com</code></li><li>check if ip address is returned:<img src="/2018/03/20/dns-forwarding/dig.png"></li><li>resolve use specific DNS server, like Google’s<pre><code class="linux">dig @8.8.8.8 baidu.com</code></pre></li><li>If you are just looking for IP address, you can add <code>+short</code> at the end<pre><code class="linux">dig @8.8.8.8 baidu.com +short</code></pre></li></ul></li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> practice </tag>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DNS CNAME ANAME</title>
      <link href="/2018/03/19/dns-cname/"/>
      <url>/2018/03/19/dns-cname/</url>
      <content type="html"><![CDATA[<img src="/2018/03/19/dns-cname/dns_cname.png">]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> DNS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL identity column increment suddenly jumps</title>
      <link href="/2018/03/15/sql-id-increment-jump/"/>
      <url>/2018/03/15/sql-id-increment-jump/</url>
      <content type="html"><![CDATA[<p>SQL SERVER 2016</p><img src="/2018/03/15/sql-id-increment-jump/sql_id_increment.jpg"><p>SQL Server 2012 now uses a cache size of 1,000 when allocating IDENTITY values in an int column and restarting the service can “lose” unused values (The cache size is 10,000 for bigint/numeric).</p><p>Workarounds:</p><ul><li>You can use a <code>SEQUENCE</code> instead of an identity column and define a smaller cache size for example and use <code>NEXT VALUE FOR</code> in a column default</li></ul><p>e.g:</p><pre><code class="sql"> CREATE SEQUENCE Service_Ticket_Seq AS INTEGER START WITH 1 INCREMENT BY 1 MINVALUE 1 MAXVALUE 100 CYCLE; </code></pre><p>We can put a <code>SEQUENCE</code> in the <code>DEFAULT</code> clause of the DDL for table:</p><pre><code class="sql">CREATE TABLE Service_Tickets(ticket_nbr INTEGER DEFAULT NEXT VALUE FOR Service_Ticket_Seq, department_code CHAR(1) NOT NULL CHECK (department_code IN (&#39;M&#39;, &#39;F&#39;))); </code></pre><p>Now play with code:</p><pre><code class="sql">INSERT INTO Service_Tickets (department_code)VALUES (&#39;M&#39;);SELECT * FROM Service_Tickets;</code></pre><p>Now we get:</p><table><thead><tr><th style="text-align:left">ticket_nbr</th><th style="text-align:left">department_code</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">M</td></tr></tbody></table><p>Let’s re-do the Meats and Fish tables.</p><pre><code>CREATE TABLE Meats(ticket_seq INTEGER DEFAULT NEXT VALUE FOR Service_Ticket_Seq        PRIMARY KEY, meat_type VARCHAR(15) NOT NULL);CREATE TABLE Fish(ticket_seq INTEGER DEFAULT NEXT VALUE FOR Service_Ticket_Seq        PRIMARY KEY, fish_type VARCHAR(15) NOT NULL);</code></pre><p>Now try:</p><pre><code>INSERT INTO Meats (meat_type) VALUES (&#39;pig&#39;);INSERT INTO Fish (fish_type) VALUES (&#39;squid&#39;);SELECT * FROM Meats;SELECT * FROM Fish;</code></pre><p>We get:</p><table><thead><tr><th style="text-align:left">ticket_nbr</th><th style="text-align:left">department_code</th></tr></thead><tbody><tr><td style="text-align:left">2</td><td style="text-align:left">pig</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">squid</td></tr></tbody></table><ul><li><p>Apply trace flag 272 which makes the <code>IDENTITY</code> allocation logged as in previous versions.</p><ul><li>Run <strong>SQL Server Configuration Manager</strong></li><li><p>Select <strong>SQL SERVER SERVICES</strong>, right-click <code>SQL Server</code> and select <code>Properties</code>, select <code>Startup Parameters</code>, type <code>-T272</code> , Add, Apply, close and restart.</p><img src="/2018/03/15/sql-id-increment-jump/sql_server_config.jpg"></li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> issue </tag>
            
            <tag> MSSQL </tag>
            
            <tag> configuration </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python List and Tuple, Dict and Set</title>
      <link href="/2018/03/15/python-list-tuple/"/>
      <url>/2018/03/15/python-list-tuple/</url>
      <content type="html"><![CDATA[<p><strong>Python 3</strong></p><p><strong>list与tuple都是有序列表</strong></p><h3 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h3><p>是一种有序的集合，可以随时添加或删除元素</p><pre><code class="python">p = [&#39;asp&#39;, &#39;php&#39;]s = [&#39;python&#39;, &#39;java&#39;, p, &#39;angular&#39;]</code></pre><p>如果想要拿到php，可以写成<code>s[2][1]</code>,因此s可以看作为二维数组</p><p>常用方法：</p><pre><code class="python">&gt;&gt;&gt; len(classmates) ***获取元素个数***&gt;&gt;&gt; s[-2] ***获取倒数第二个元素***&gt;&gt;&gt; s.append(&#39;vue&#39;) ***追加元素到末尾***&gt;&gt;&gt; s.insert(2,&#39;vue&#39;) ***把元素插入到索引号为2的位置，索引从0开始***&gt;&gt;&gt; s.pop() ***删除list末尾元素***&gt;&gt;&gt; s.pop(1) ***删除索引位置为i的元素***&gt;&gt;&gt; s[1] = &#39;vue&#39; ***把某个索引位置的元素替换成另一个元素***</code></pre><h3 id="TUPLE"><a href="#TUPLE" class="headerlink" title="TUPLE"></a>TUPLE</h3><p><strong>tuple一旦初始化就不能修改，这里的不能修改指的是tuple中的每个元素的指向不变</strong></p><pre><code class="python">classmates=(&#39;Jane&#39;, &#39;Anna&#39;, &#39;Ed&#39;)</code></pre><p>现在这个classmates就无法更改，没有append(),insert()可以调用</p><p>但是有时候却能看见给tuple添加元素的操作：</p><pre><code class="python">def two(**s):    print(&#39;s is &#39;, s)    t = ()    for i in s.values():        t += (i,) #这里tuple竟然可以添加元素    print(t)dic = dict(    d1=1,    d2=2,    d3=3)if __name__ == &#39;__main__&#39;:    two(**dic) #输出为tuple(1, 2, 3)</code></pre><p><span style="color: red"><strong>当执行上面的操作的时，其实stucture is changed. 即你每新增一个新的，其实是一个新的Object.</strong></span><br>比如：</p><pre><code class="python">&gt;&gt;&gt; tup = (1, 2, 3)&gt;&gt;&gt; id(tup)140153476307856&gt;&gt;&gt; tup += (4, 5)&gt;&gt;&gt; id(tup)140153479825840</code></pre><p>而如果是list的话：</p><pre><code class="python">&gt;&gt;&gt; lst = [1, 2, 3]&gt;&gt;&gt; id(lst)140153476247704&gt;&gt;&gt; lst += [4, 5]&gt;&gt;&gt; id(lst)140153476247704</code></pre><p><a href="https://drillearningss.wordpress.com/2018/01/04/python-list-and-tuple/" target="_blank" rel="noopener">Ref link</a></p><p>如果想要定义一个只有一个参数的tuple,<strong>不能写成</strong></p><pre><code class="python">&gt;&gt;&gt; t = (1)&gt;&gt;&gt; t</code></pre><p><strong>因为这个时候t是数字1，（）这个时候当作数学括号来解析</strong><br>需要写成</p><pre><code class="python">&gt;&gt;&gt; t = (1, )&gt;&gt;&gt; t(1, )</code></pre><h3 id="DICT"><a href="#DICT" class="headerlink" title="DICT"></a>DICT</h3><p>使用键值对存储, 且dict的<strong>key是不可变对象</strong></p><pre><code class="python">&gt;&gt;&gt; d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85}&gt;&gt;&gt; d[&#39;Michael&#39;]95</code></pre><p>为避免key不存在报错：</p><pre><code class="python">&gt;&gt;&gt; &#39;Thomas&#39; in dFalse&gt;&gt;&gt; d.get(&#39;Thomas&#39;) //返回None&gt;&gt;&gt; d.get(&#39;Thomas&#39;, -1)</code></pre><p><span style="color: red">注意，dict的添加就是直接赋值就好了，例如<br><code>d[&#39;newkey&#39;]=&#39;newvalue&#39;</code></span></p><h3 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h3><p>Set也是一组Key的集合，但不存储value，且Key也不能重复。</p><pre><code class="python">&gt;&gt;&gt; s = set([1,2,3])&gt;&gt;&gt; s{1,2,3}</code></pre><p><strong>注意传入的参数<code>[1,2,3]</code>是一个list，而显示的<code>{1,2,3}</code>只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的</strong></p><p>重复元素再set中会自动被过滤掉</p><pre><code class="python">&gt;&gt;&gt; s = set([1,1,2,2,3,3,])&gt;&gt;&gt; s{1,2,3}&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s{1,2,3,4}&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; s{1,2,3}</code></pre><p><strong>SET可以看成无序且无重复元素的集合，因此两个set可以做数学意义上的交集、并集等操作</strong></p><pre><code class="python">&gt;&gt;&gt; s1 = set([1,2,3])&gt;&gt;&gt; s2 = set([2,3,4])&gt;&gt;&gt; s1 &amp; s2{2,3}&gt;&gt;&gt; s1 | s2{1,2,3,4}</code></pre>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python 可变参数，关键字参数</title>
      <link href="/2018/03/15/python-parameter/"/>
      <url>/2018/03/15/python-parameter/</url>
      <content type="html"><![CDATA[<ul><li><p>可变参数*args</p><ul><li>变的是个数</li><li>在函数调用的时候自动组装为一个tuple</li><li>传入的时候直接传值即可</li></ul></li><li><p>关键字参数**kwargs</p><ul><li>在函数调用的时候自动组装为一个dictionary</li><li>传入的时候必须是以含参数名的形式传递</li></ul></li></ul><pre><code class="python">def func(a, b, c=0, *args, **kwargs):    print (&#39;a=&#39;, a, &#39;b=&#39;, b, &#39;c=&#39;, c, &#39;args=&#39;, args, &#39;kwargs=&#39;, kwargs)if __name__ == &#39;__main__&#39;:    func(1,2,3,spence,shao,name=&#39;spence&#39;,gender=&#39;male&#39;)&gt;&gt;&gt;a=1,b=2,c=3,args=(spence,shao),kwargs={&#39;name&#39;:&#39;spence&#39;,&#39;gender&#39;:&#39;male&#39;}</code></pre>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML GET请求自动添加参数列表</title>
      <link href="/2018/03/15/html-auto-add-parameter/"/>
      <url>/2018/03/15/html-auto-add-parameter/</url>
      <content type="html"><![CDATA[<pre><code class="html">&lt;form action=&quot;/action&quot; method=&quot;get&quot;&gt;&lt;textarea name=&quot;message&quot;&gt;&lt;/textarea&gt;        &lt;input name=&quot;author&quot;&gt;        &lt;!-- /?message=输入的内容 --&gt;        &lt;button type=&quot;submit&quot;&gt;GET 提交&lt;/button&gt;&lt;/form&gt;&lt;form action=&quot;/&quot; method=&quot;post&quot;&gt;        &lt;textarea name=&quot;message&quot;&gt;&lt;/textarea&gt;        &lt;button type=&quot;submit&quot;&gt;POST 提交&lt;/button&gt;&lt;/form&gt;</code></pre><p>对于GET请求，GET提交之后，浏览器会在<code>host:port[action]?author=xx&amp;message=xx</code>, 例如<br><code>localhost:3000/action?author=spencer&amp;message=test</code></p>]]></content>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Excel generate random value from a list</title>
      <link href="/2018/03/15/excel-random-value/"/>
      <url>/2018/03/15/excel-random-value/</url>
      <content type="html"><![CDATA[<p><code>=INDEX($E:$E, RANDBETWEEN(1,COUNTA($E:$E)),1)</code></p><img src="/2018/03/15/excel-random-value/excel_random_value.png">]]></content>
      
      
        <tags>
            
            <tag> Excel </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux find directory</title>
      <link href="/2018/03/15/linux-find-directory/"/>
      <url>/2018/03/15/linux-find-directory/</url>
      <content type="html"><![CDATA[<p><code>find / -type d -name &#39;dir-name-here&#39;</code></p>]]></content>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> command </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>nginx location匹配</title>
      <link href="/2018/03/14/nginx-location/"/>
      <url>/2018/03/14/nginx-location/</url>
      <content type="html"><![CDATA[<p>转载补充自<a href="http://seanlook.com/2015/05/17/nginx-location-rewrite/" target="_blank" rel="noopener">http://seanlook.com/2015/05/17/nginx-location-rewrite/</a></p><pre><code class="nginx">location  = / {  # 精确匹配 / ，主机名后面不能带任何字符串  [ configuration A ]}location  / {  # 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求  # 但是正则和最长字符串会优先匹配  [ configuration B ]}location ^~ /images/ {  # 匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。  [ configuration D ]}location ~* \.(gif|jpg|jpeg)$ {  # 匹配所有以 gif,jpg或jpeg 结尾的请求  # 然而，所有请求 /images/ 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则  [ configuration E ]}</code></pre><ul><li>以<code>=</code>开头表示精确匹配<br>如A中只匹配根目录结尾的请求，后面不能带任何字符串</li><li><code>^~</code>开头表示uri以某个常规字符串开头，<span style="color: red"><strong>不是正则匹配</strong></span></li><li><code>~</code>开头表示区分大小写的正则匹配</li><li><code>~*</code>开头表示不区分大小写的正则匹配</li><li><code>/</code>通用匹配， 如果没有其他匹配，任何请求都会匹配到</li><li>前缀匹配时，nginx不对url做编码，因此请求<code>/static/20%/aa</code>, 可以被规则 <code>^~ /static/ /aa</code> 匹配到</li></ul><p>多个 location 配置的情况下匹配顺序为：</p><ul><li>首先精确匹配 <code>=</code></li><li>其次完整路径</li><li>其次前缀匹配  <code>^~</code></li><li>其次按文件中顺序的正则匹配</li><li>匹配不带任何修饰的前缀匹配</li><li>最后 <code>/</code> 通用匹配</li><li>当有匹配成功的时候，停止匹配，按当前匹配规则处理请求</li></ul>]]></content>
      
      
        <tags>
            
            <tag> concept </tag>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/03/14/hello-world/"/>
      <url>/2018/03/14/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
