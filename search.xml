<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2019%2F06%2F26%2Fpython-numpy-axis%2F</url>
    <content type="text"><![CDATA[摘自https://zhuanlan.zhihu.com/p/30960190 &amp; https://www.cnblogs.com/zhouyang209117/p/6512302.html &amp; https://www.zhihu.com/collection/249082247 Axis axis就是计数方式，直白来说就是最外面的括号代表axis=0, 依次往里面的括号对应的axis技术就依次+1 比方说对于矩阵$$x = \begin{bmatrix}0 &amp; 1\2 &amp; 3\end{bmatrix}$$在numpy里面，这个矩阵表达成x=[[0,1],[2,3]],则最外层的括号代表axis=0,里面一层的括号代表axis=1 所以对应的运算就有 更加高维的运算： 设axis=i,则numpy就沿着第i个下标变化的方向进行操作** 比方说np.sum(a, axis=1)二维数组 $$ \begin{bmatrix} \begin{bmatrix} 1, &amp;2, &amp;3 \end{bmatrix},\ \begin{bmatrix} 4, &amp;5, &amp;6 \end{bmatrix},\ \begin{bmatrix} 7, &amp;8, &amp;9 \end{bmatrix} \end{bmatrix} $$ 就会朝着a[0][i](i=0,1,2)的方向变化,就是a[0][1],a[0][2],a[0][3]相加变成6 $$\begin{bmatrix}\begin{bmatrix}6\end{bmatrix},\\begin{bmatrix}15\end{bmatrix},\\begin{bmatrix}24\end{bmatrix}\end{bmatrix}$$ ​ 再看一个三维数组: 如果要计算np.sum(a, axis=1),则这个时候就是a[0][i](i=0,1)的方向进行变化,也就是对于a[0][0],a[0][1]相加,即$$\begin{bmatrix}[1,2,3,4] + [1,3,4,5]\end{bmatrix}$$变成$$\begin{bmatrix}[2,5,7,9]\end{bmatrix}$$ ​ 再看一个十分复杂的思维数组 12345678910111213141516171819202122232425262728293031323334353637383940a = np.arange(72).reshape(4,3,2,3)a[[[[ 0 1 2] [ 3 4 5]] [[ 6 7 8] [ 9 10 11]] [[12 13 14] [15 16 17]]] [[[18 19 20] [21 22 23]] [[24 25 26] [27 28 29]] [[30 31 32] [33 34 35]]] [[[36 37 38] [39 40 41]] [[42 43 44] [45 46 47]] [[48 49 50] [51 52 53]]] [[[54 55 56] [57 58 59]] [[60 61 62] [63 64 65]] [[66 67 68] [69 70 71]]]] 那么如果np.sum(a, axis=0),则意味着a[i](i=0,1,2,3)依次相加,也就是a[0],a[1],a[2],a[3]依次相加,a0000+a1000+a2000+a3000=0+18+36+54=108,第二个a0001+a1001+a2001+a3001=1+19+37+55=112,其最终相加之后的结构也应该等于a[0]的结构,也就是一个shape为(3,2,3)的数组: 12345678[[[108 112 116] [120 124 128]] [[132 136 140] [144 148 152]] [[156 160 164] [168 172 176]]] 如果axis = 1,则相当于a0000+a0100+a0200=0+6+12=18,axis=1最终的结构应该相当于4个a[0][0],也就是 1234567891011[[[ 18 21 24] [ 27 30 33]] [[ 72 75 78] [ 81 84 87]] [[126 129 132] [135 138 141]] [[180 183 186] [189 192 195]]] 如果axis=2,则即a[0][0][i](i=0,1)依次相加,a000+a001 = 0+3 = 3,,也就是 [0 1 2]+[3 4 5] = [3 5 7],其最终的结果为 123456789101112131415[[[ 3 5 7] [ 15 17 19] [ 27 29 31]] [[ 39 41 43] [ 51 53 55] [ 63 65 67]] [[ 75 77 79] [ 87 89 91] [ 99 101 103]] [[111 113 115] [123 125 127] [135 137 139]]] 如果axis=3,则相当于a[0][0][0][i](i=0,1,2)依次相加,其最终结果为 123456789101112131415[[[ 3 12] [ 21 30] [ 39 48]] [[ 57 66] [ 75 84] [ 93 102]] [[111 120] [129 138] [147 156]] [[165 174] [183 192] [201 210]]] Transposetranspose就是更换矩阵的顺序，比方说一个shape为(2,3,4)的矩阵 12import numpy as npx = np.arrange(24).reshape([2,3,4]) 则此时这个$$x = \begin{bmatrix}\begin{bmatrix}\begin{bmatrix}0 &amp; 1 &amp; 2 &amp; 3\end{bmatrix}\\begin{bmatrix}4 &amp; 5 &amp; 6 &amp; 7\end{bmatrix} \\begin{bmatrix}8 &amp; 9 &amp; 10 &amp; 11\end{bmatrix}\end{bmatrix} \\begin{bmatrix}\begin{bmatrix}12 &amp; 13 &amp; 14 &amp; 15\end{bmatrix}\\begin{bmatrix}16 &amp; 17 &amp; 18 &amp; 19\end{bmatrix}\\begin{bmatrix}20 &amp; 21 &amp; 22 &amp; 23\end{bmatrix}\end{bmatrix}\end{bmatrix}$$首先需要了解shape的直观概念，shape中的各个数就是对应的axis的元素个数，如下图： 所以shape的值为(2,3,4)也就是说对于axis=0,每隔两个元素往下走(每个元素相差12)，对于axis=1，每隔3个元素往下走（每个元素相差4），对于axis=2来说，每隔4个元素往下走（每个元素相差1） 这个时候我们定义另外一个参数strides，记录每个axis跳过的数，则上面的strides=(12,4,1) 那么，transpose的本质就是对strides中的各个数的顺序进行了调换，比方说 1x.transpose(1,0,2) 则这个时候strides就变成(4,12,1), shape就变成(3,2,4),也就是说一个大的矩阵里面包含三个矩阵b，其中每个b里面又有两个矩阵c, 每个c矩阵里面有4列，画出来就变成这样的形式$$x = \begin{bmatrix}\begin{bmatrix}\begin{bmatrix}x &amp; x &amp; x &amp; x\end{bmatrix}\\begin{bmatrix}x &amp; x &amp; x &amp; x\end{bmatrix}\end{bmatrix}\\begin{bmatrix}\begin{bmatrix}x &amp; x &amp; x &amp; x\end{bmatrix}\\begin{bmatrix}x &amp; x &amp; x &amp; x\end{bmatrix}\end{bmatrix}\\begin{bmatrix}\begin{bmatrix}x &amp; x &amp; x &amp; x\end{bmatrix}\\begin{bmatrix}x &amp; x &amp; x &amp; x\end{bmatrix}\end{bmatrix}\end{bmatrix}$$这个时候再定义里面strides跳跃，则可以确定此时变换后的矩阵变成：$$x = \begin{bmatrix}\begin{bmatrix}\begin{bmatrix}0 &amp; 1 &amp; 2 &amp; 3\end{bmatrix}\\begin{bmatrix}12 &amp; 13 &amp; 14 &amp; 15\end{bmatrix}\end{bmatrix}\\begin{bmatrix}\begin{bmatrix}4 &amp; 5 &amp; 6 &amp; 7\end{bmatrix}\\begin{bmatrix}16 &amp; 17 &amp; 18 &amp; 19\end{bmatrix}\end{bmatrix}\\begin{bmatrix}\begin{bmatrix}8 &amp; 9 &amp; 10 &amp; 11\end{bmatrix}\\begin{bmatrix}20 &amp; 21 &amp; 22 &amp; 23\end{bmatrix}\end{bmatrix}\end{bmatrix}$$ np.argmaxnp.argmax中有一个参数是axis，默认是0，代表第几维的最大值，比方说二维的情况 123456import numpy as npa = np.array([[1, 5, 5, 2], [9, 6, 2, 8], [3, 7, 9, 11] ])print(np.argmax(a, axis=0)) axis=0的含义就是a[0][j],a[1][j], a[2][j] (j=0,1,2,3)中最大值的索引 a[1][j]中9&gt;3, 6&gt;5, 8&gt;2所以此时a[1][j]与a[0][j]相比索引变成(1,1,0,1) 然后a[2][j]再与这个时候的(1,1,0,1)对应的值比较，7&gt;6,9&gt;5,11&gt;8，所以此时的索引值变成(1,2,2,2) 如果axis=1，其含义就是第二维比最大值，a[i][0],a[i][1],a[i][2],a[i][3](i=0,1,2,3)中最大索引的值，所以a[i][0]初始最大索引值为(0,0,0)，然后第二列做比较，则5&gt;1,7&gt;3此时的索引值变为(1,0,1),再和第三列做比较，比较后索引值为(1,0,2),最后和第四列作比较,则这个时候索引值变为(1,0,3) 可以再看一个三维的情况 123456789101112131415import numpy as npa = np.array([ [ [1, 5, 5, 2], [9, -6, 2, 8], [-3, 7, -9, 1] ], [ [-1, 5, -5, 2], [9, 6, 2, 8], [3, 7, 9, 1] ] ])print(np.argmax(a, axis=0)) 当axis=0比较的是a[0][j][k],a[1][j][k](j=0,1,2,k=0,1,2,3),a[0]矩阵就是$$\begin{bmatrix} \begin{bmatrix} 1， &amp; 5， &amp; 5， &amp; 2 \end{bmatrix},\ \begin{bmatrix} 9， &amp; -6， &amp; 2， &amp; 8 \end{bmatrix},\ \begin{bmatrix} -3， &amp; 7， &amp; -9， &amp; 1 \end{bmatrix}\end{bmatrix}$$这个时候a[0][j][k]的初始索引值为(0,0,0,0),(0,0,0,0),(0,0,0,0)然后拿a[0][j][k]与a[1][j][k]的对应项去做比较，1&gt;-1,5=5,5&gt;-5,2=2;9=9,-6&lt;6,2=2,8=8;-3&lt;3,7=7,-9&lt;9,1=1则这个时候索引大小变为(0,0,0,0);(0,1,0,0);(1,0,1,0) 如果axis=1,则比较的是a[i][0][k],a[i][1][k],a[i][2][k]对应的项去比较，则初始的索引值为(0,0,0,0),(0,0,0,0),a[0][0][k] vs. a[0][1][k]的索引值为(1,0,0,1),a[1][0][k] vs. a[1][1][k]的索引值为(1,1,1,1),这个时候对应最大值的数组为((9,5,5,8),(9,6,2,8)).然后再拿(9,5,5,8)和a[i][2][k]对应项来比较,即(9,5,5,8)和(-3,7,-9,1)来比较,则这个时候的索引值变为(1,2,0,1),同理,对于a[1][2][k]相比较,得出的索引变为(1,2,2,1)]]></content>
      <tags>
        <tag>concept</tag>
        <tag>python</tag>
        <tag>numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NodeJs与数据库的交互]]></title>
    <url>%2F2019%2F06%2F05%2Fnodejs-database%2F</url>
    <content type="text"><![CDATA[NodeJs操作数据库也是异步的使用模块co-mysql可以使用async/await来实现异步 12345678910111213141516171819202122232425262728293031323334353637const http = require('http');const mysql = require('mysql');const co = require('co-mysql');const url = require('url');const fs = require('fs');//直接建立连接池let conn = mysql.createPool(&#123; host: 'localhost', port: 3306, user: 'root', password: '', database: 'testdb', connectionLimit: 10&#125;);let db = co(conn);let server = http.createServer(async (req,res)=&gt;&#123; const &#123;pathname, query&#125; = url.parse(req.url, true); if(pathname == '/reg')&#123; try&#123; let &#123;username, password&#125; = query; let data = await db.query(`SELECT ID FROM testdb WHERE username='$&#123;username&#125;'`); if(data.length &gt;0)&#123; &#125;else&#123; await db.query(`INSERT INTO testdb (username, password) VALUES ('$&#123;username&#125;','$&#123;password&#125;')`); res.write('Reg success!'); &#125; &#125;catch(e)&#123; res.write('DB Fail'); &#125; res.end(); &#125;&#125;);server.listen(8080);]]></content>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs 入门]]></title>
    <url>%2F2019%2F04%2F10%2Fnodejs-basics%2F</url>
    <content type="text"><![CDATA[简介nodejs其实就是javascript的后台版本。 一般用于中间层，小型服务，工具。 中间层​ 不让客户端直接跟主服务端来沟通，一般都是和中间的中间层来沟通。保障安全/性能（缓存，布点），也可以降低主服务器的复杂度。 使用1const multer = require("multer");//用的是require,而不是ES6的import 1&gt; node file.js 常用模块http模块123456const http = require('http');let server = http.createServer(function(req,res)&#123; res.write('abc'); res.end();//必须显式告诉这个请求结束&#125;)server.listen(8081); fs文件读写 ​ fs.readFile返回的是二进制Buffer数据，不是可读数据，给浏览器发的时候发Buffer数据即可 12345678910111213141516const fs = require('fs');//path, data, callbackfs.writeFile('./a.txt','abcdefghi',err=&gt;&#123; if(err)&#123; console.log('失败'); &#125;else&#123; console.log('成功'); &#125;&#125;);fs.readFile('./a.txt',(err,data)=&gt;&#123; if(err)&#123; console.log('失败'); &#125;else&#123; console.log('成功',data); //data返回的是Buffer数据，是二进制数据 &#125;&#125;) 例，根据用户请求的网页展示网页 123456789101112131415const http = require('http');const fs = require('fs');let server = http.createServer(function(req,res)&#123; fs.readFile(`www$&#123;req.url&#125;`,(err,buffer)=&gt;&#123; if(err)&#123; res.writeHeader(404); res.write('Not Found'); &#125;else&#123; res.write(buffer); &#125; res.end(); &#125;)&#125;);server.listen(8081); HTTP报文结构http header大小要&lt;= 32K, Body部分大小&lt;=2G 接收GET数据GET数据会一次性都发给你 12345678const http = require('http');const url = require('url');let server = http.createServer(function(req,res)&#123; let &#123;pathname, query&#125; = url.parse(req.url,true); console.log(pathname, query);&#125;);server.listen(8081); 接收POST数据POST数据可能分多次给你，但是这样写有一个问题，就是数据会全部存到缓存里面 12345678910111213141516const http = require('http');const querystring = require('querystring');let server = http.createServer(function(req,res)&#123; let arr = []; //只要有数据，就调用这个事件，buffer是二进制 req.on('data', buffer=&gt;&#123; arr.push(buffer); &#125;); req.on('end',()=&gt;&#123; let buffer = Buffer.concat(arr); let postResult = querystring.parse(buffer.toString()); console.log(postResult); &#125;);&#125;);server.listen(8081); NodeJs 模块化引入模块require ​ 如果带有路径，会去路径下面找 1const mod1 = require('./mod1'); //mod1.js存放在当前目录 ​ 如果没有路径，会先去项目的node_modules去找，如果没有，会去系统级的node_modules去找 1const mod1 = require('mod1'); 导出数据module,exports1234567891011121314151617181920module.exports = &#123; a:12, b:9&#125;;module.exports = function()&#123; console.log("This is mod1");&#125;; //到后面使用的时候直接const mod1 = require('mod1'); mod1();exports.a = 12;exports.b = 9;//与上面的module.exports相同//也可以导出一个classmodule.exports = class&#123; constructor(name)&#123; this.name = name; &#125; show()&#123; console.log(this.name); &#125;&#125;;//到后面使用的时候let p = mod1(99); p.show(); NodeJs常用系统包assert断言12345const assert = require('assert');//assert(条件，消息)assert(5&lt;3,'Fail');//deepEqual还比较里面的成员，相当于js里面的==，assert.deepEqual(变量,预期值,msg);//deepStrictEqual还比较里面的类型，相当于js里面的===,assert.deepStrictEqual(变量,预期值,msg); net网络通信模块，数据不走http协议的时候来用OSI七层模型物理层 &gt; 数据链路层（内网通讯，就是家里电脑手机跟路由器）&gt; 网络层（外网通信，不同计算机之间，IP层） &gt; 传输层（丢包，顺序，保证传输的质量， TCP协议） &gt; 会话层（保存两个计算机相互通话的信息，双方认识对方）&gt; 表现层（屏蔽各种网络之间的不同，让各种网络之间展示的效果相同） &gt; 应用层(HTTP) net是传输层 数据通信原生上传文件 如果在form中不添加enctype，则默认的值为application/x-www-form-urlencoded，用这种方法提交文件，到后台会以参数&amp;的形式展现，只能传输文字型的数据，传输不了文件内容，如usesrname=blue&amp;password=123456&amp;file=test.txt enctype要定义为multipart/form-data 123456&lt;form action="http://localhost:8081/upload" method="post" enctype="multipart/form-data"&gt; 用户：&lt;input type="text" name="username"&gt;&lt;br&gt; 密码：&lt;input type="text" name="password"&gt;&lt;br&gt; &lt;input type="file" name="f1"&gt; &lt;input type="submit" value="submit"&gt;&lt;/form&gt; 1234567891011const http = require('http');let server = http.createServer((req,res)=&gt;&#123; let arr = []; req.on('data', buffer=&gt;&#123; arr.push(buffer); &#125;); req.on('end',()=&gt;&#123; let buffer = Buffer.concat(arr); console.log(buffer.toString()); &#125;);&#125;).listen(8081); 用这种方法，得出的后台响应为： 123456789101112131415------WebKitFormBoundaryqBq7JniR9FBBpsA7Content-Disposition: form-data; name=&quot;username&quot;blue------WebKitFormBoundaryqBq7JniR9FBBpsA7Content-Disposition: form-data; name=&quot;password&quot;123456------WebKitFormBoundaryqBq7JniR9FBBpsA7Content-Disposition: form-data; name=&quot;f1&quot;; filename=&quot;aaa.txt&quot;Content-Type: text/plainI&apos;m aaa!Who are you?------WebKitFormBoundaryqBq7JniR9FBBpsA7-- 如何把上面的post数据抽取出来（注意这里的Buffer是二进制） 12345678910111213//封装一个二进制Buffer的Split，Buffer这个对象没有Split方法exports.bufferSplit = function(buffer, delimiter)&#123; let arr=[]; let n = 0; while((n=buffer.indexOf(delimiter)) != -1)&#123; arr.push(0, delimiter); //跳过分隔符的长度 buffer = buffer.slice(n+delimiter.length); &#125; arr.push(buffer); return arr;&#125; 更改server.js 123456789101112131415161718192021222324252627282930313233343536373839404142434445const util = require("buffer_util");const fs = require("fs");http.createServer((req,res)=&gt;&#123; let boundary = '--'+req.headers['content-type'].split("; ")[1].split('=')[1]; let arr = []; req.on('data', buffer=&gt;&#123; arr.push(buffer); &#125;); req.on('end', ()=&gt;&#123; let buffer = Buffer.concat(arr); //1.按分隔符切分 let res = util.bufferSplit(buffer, boundary); //2.去掉最开始分割出来的Null，和最后面的一个分隔符 res.pop(); res.shift(); //3.每一个处理一下 res.forEach(buffer=&gt;&#123; //2是\r\n的字符数，这个时候的数据格式为\r\n字段信息\r\n\r\n内容\r\n buffer = buffer.slice(2, buffer.length-2); let n = buffer.indexOf('\r\n\r\n'); let info = buffer.slice(0,n); let data = buffer.slice(n+4); if(info.indexOf('\r\n')!=-1)&#123; //处理的是文件 let res2 = info.split('\r\n')[0].split('; '); let name = res2[1].split('=')[1]; let filename = res2[2].split('=')[1]; fs.writeFile(`upload/$&#123;filename&#125;`, data, err=&gt;&#123; if(err)&#123; console.log(err); &#125;else&#123; console.log('上传成功'); &#125; &#125;) &#125;else&#123; //普通字符串信息 &#125; &#125;) &#125;)&#125;) ajax及跨域ajax为什么不能跨域你的请求资源应该跟你是在同一个域名下，如果不是，浏览器会禁用这个请求 ajax的请求是被浏览器给拦截的，浏览器会拦截掉服务器的response 要由服务器来告诉浏览器，我相信这个请求，是安全的，浏览器才能放这个response回去 12345http.createServer((req,res)=&gt;&#123; res.setHeader('access-control-allow-origin','*'); res.write('&#123;"a":1,"b":"hellow"&#125;'); res.end();&#125;).listen(8081); fetch - 原生的ajax,比xhr方便好用解析二进制图片 12345678910111213141516171819&lt;script&gt; window.onload = function()&#123; let oBtn = document.getElementById("btn1"); let oImg = document.getElementById("img1"); oBtn.onclick = async function()&#123; //1. 请求 let res = await fetch("data/1.png"); //2. 解析 let data = await res.blob(); //如果是json文件res.json(),如果是text文件json.text() let url = URL.createObjectURL(data); oImg.src = url; &#125; &#125;&lt;/script&gt;&lt;body&gt; &lt;input type="button" value="Read" id="btn1"&gt; &lt;img id = "img1" /&gt;&lt;/body&gt; jsonp - 原理就是在引用的js里面调用原来页面的一个函数123456789101112131415161718192021222324252627&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script&gt; function txtFunction(s)&#123; let result = []; if(s.g)&#123; (s.g).forEach(item=&gt;&#123; result.push(item.q); &#125;) console.log(result); &#125; &#125; window.onload = function()&#123; let oTxt = document.getElementById("txt1"); oTxt.oninput = function()&#123; let url = `https://www.baidu.com/sugrec?pre=1&amp;p=3&amp;ie=utf-8&amp;json=1&amp;prod=pc&amp;from=wise_web&amp;sugsid=26524,1426,21126,28775,28722,28838,28585,26350,28891,28701&amp;wd=$&#123;this.value&#125;&amp;req=2&amp;csor=2&amp;pwd=s&amp;cb=txtFunction`; let oS = document.createElement('script'); oS.src = url; document.head.appendChild(oS); &#125; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" id="txt1"&gt;&lt;/body&gt; FormData - 也是原生提交数据的一种方法,是ajax2.0里面添加的一个新特性特别适用于直接把Form丢进去的情况 FormData帮助构建一个表单，可以把文件包在里面，最方便的做法就是用&lt;form&gt;包住 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;form id="form1" action="http://localhost:8081/" method="post"&gt; 用户：&lt;input type="text" name="user" /&gt;&lt;br&gt; 密码：&lt;input type="password" name="pass" /&gt;&lt;br&gt; 文件：&lt;input type="file" name="file1" /&gt;&lt;br&gt; &lt;input type="submit" value="提交" /&gt; &lt;/form&gt;&lt;/body&gt;&lt;script&gt; let oForm = document.querySelector("#form1"); oForm.onsubmit = function()&#123; let formdata = new FormData(oForm); let xhr = new XMLHttpRequest(); xhr.open(oForm.method, oForm.action, true); xhr.send(formdata); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if(xhr.status &gt;= 200 || xhr.status == 304)&#123; alert("Success!"); &#125;else&#123; alert("Fail!"); &#125; &#125; &#125;; return false; &#125;&lt;/script&gt; 1234567891011121314151617const http = require("http");const multiparty = require("multiparty");http.createServer((req, res)=&gt;&#123; let form = new multiparty.Form(&#123;uploadDir: './upload/'&#125;); form.parse(req); form.on('field',(name,value)=&gt;&#123; console.log('field:', name, value); &#125;); form.on('file', (name,file)=&gt;&#123; console.log("file:", name, file); &#125;); form.on('close', ()=&gt;&#123; console.log("Finish!"); &#125;);&#125;).listen(8081); 用jQuery提交FormData1234567891011121314151617181920212223242526&lt;body&gt;&lt;form id="form1" action="http://localhost:8080/" method="post"&gt; 用户：&lt;input type="text" name="user" /&gt;&lt;br&gt; 密码：&lt;input type="password" name="pass" /&gt;&lt;br&gt; 文件：&lt;input type="file" name="file1" /&gt;&lt;br&gt; &lt;input type="submit" value="提交" /&gt;&lt;/form&gt;&lt;script src="jquery.js" type="application/javascript" charset="utf-8"&gt;&lt;/script&gt;&lt;script&gt; $('#form1').on('submit', function()&#123; let formData = new FormData(this); //this=#form1 //默认不写明ProcessData和ContentType,jquery会直接把数据转换成它认为合适上传的东西，比方说字符串 //而formData本身就是一个可以提交的状态，已经自动赋值好了contentType这类的信息 //所以要告诉jQuery哪些东西不要让它处理，并且让其保留原来的contentType不要随意篡改 $.ajax(&#123; url: this.action, type: this.method, data: formData, processData: false, contentType: false &#125;); return false; &#125;)&lt;/script&gt;&lt;/body&gt; 自己构建Form,表单是动态的，程序生成的比方说 12345678910111213141516171819202122232425262728293031&lt;body&gt; &lt;div id="div1"&gt; 用户:&lt;input type="text" id="user" /&gt; &lt;br&gt; 密码:&lt;input type="password" id="pass" /&gt; &lt;br&gt; 文件:&lt;input type="file" id="f1" /&gt; &lt;br&gt; &lt;input id="btn1" type="button" value="submit"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; let oBtn = document.querySelector("#div1"); let formdata = new FormData(); //可以用formdata.append方法来实现 formdata.append('username', document.querySelector("#user").value); formdata.append('password', document.querySelector("#pass").value); formdata.append('f1', document.querySelector("#f1").files[0]); let xhr = new XMLHttpRequest(); xhr.open('post', 'http://localhost:8080/', true); xhr.send(formdata); xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4)&#123; if(xhr.status == 200)&#123; alert("success!"); &#125;else&#123; alert("fail!"); &#125; &#125; &#125;&lt;/script&gt; WebSocket优点： 比ajax性能高，普通的HTTP是基于文本的，基于字符的通信，而websocket在建立之初是文本协议（交换密钥等），但一旦连接建立，协议升级完成了会是一个二进制的状态，所以无需对数据做转换 是双向通信，服务器可以主动来找你 websocket直接跨域 websocket天然加密具有安全特性 5.如果断开了会自动重连，如果在断开的时候发了消息会帮你缓存 是长连接，但是只会消耗保持连接信息的那一小块空间，对CPU对网络没有负担 socket.io一个比较好用的库是socket.io,这个库1. 简单，方便 2. 兼容IE5 3. 自动对数据进行解析 举例 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en" dir="ltr"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt; &lt;/title&gt; &lt;script src="http://localhost:8080/socket.io/socket.io.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script&gt; let sock = io.connect('ws://localhost:8080/'); // sock.emit('aaa',12,5); sock.on('timer', time=&gt;&#123; console.log(time); &#125;) &lt;/script&gt;&lt;/head&gt;&lt;/html&gt; 12345678910111213141516171819202122const http = require('http');const io = require('socket.io');//1. 建立普通httplet server = http.createServer((req, res)=&gt;&#123;&#125;);server.listen(8080);//2. 建立websocketlet wsServer = io.listen(server);wsServer.on('connection', sock=&gt;&#123; // sock.on('aaa', function(a,b)&#123; // console.log(a,b,a+b); // &#125;) setInterval(function()&#123; sock.emit('timer', new Date().getTime()); &#125;,1000);&#125;); 原生的websocket原生的ws请求头与一般的http头会有一些不同,主要是这些 1234Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bitsSec-WebSocket-Key: SAPSH0k/Q/jUSv5l13gwAw==Sec-WebSocket-Version: 13Upgrade: websocket Upgrade协议升级，现在虽然给你发的是http请求，但是希望之后升级协议变成websocket,你觉得如何？ Extension是扩展信息 Key是认证协议，注意！这个不是加密协议，因为现在的请求是ws://localhost:8080/发出的，如果是wss://则是安全websocket协议。这个Key是为了用来校验对方真的知道我在说什么。 Version是告诉服务器版本是多少 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt; let ws = new WebSocket('ws://localhost:8080/'); //这个open并不是说服务器那边connect就可以了，必须是双方都交流过握手握过了才算onopen ws.onopen= function()&#123; alert('on open'); &#125;; ws.onmessage= function()&#123;&#125;; ws.onclose= function()&#123;&#125;; ws.onerror= function()&#123;&#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const net = require('net');//帮助创建原始的服务器，可以接受任何协议，缺点就是所有的东西都是自己来const crypto = require('crypto');function parseHeader(str)&#123; let arr = str.split('\r\n').filter(line =&gt; line);//filter把后面的空行都过滤掉 arr.shift();//第一行的GET / HTTP/1.1不需要就拿掉 let headers = &#123;&#125;; arr.forEach(line=&gt;&#123; let [name, value] = line.split(':'); name = name.replace(/^\s+|\s+$/g,'').toLowerCase();//把行首和行尾的空格都去掉，变成全小写 value = value.replace(/^\s+|\s+$/g,''); headers[name] = value; &#125;); return headers;&#125;let server = net.createServer(sock =&gt;&#123; //sock 是原始sock sock.once('data', buffer=&gt;&#123; let str = buffer.toString(); let headers = parseHeader(str); if(headers['upgrade'] != 'websocket')&#123; console.log('no upgrade'); sock.end(); &#125;else if(headers['sec-websocket-version'] != '13')&#123; console.log('no 13, version does not match'); sock.end(); &#125;else&#123; let key=headers['sec-websocket-key']; let uuid='258EAFA5-E914-47DA-95CA-C5AB0DC85B11'; let hash=crypto.createHash('sha1'); hash.update(key+uuid); let key2=hash.digest('base64'); //101状态码告诉协议已经切换 sock.write(`HTTP/1.1 101 Switching Protocols \r\nUpgrade: websocket\r\nConnection: upgrade\r\nSec-Websocket-Accept:$&#123;key2&#125;\r\n\r\n`); &#125; &#125;); sock.on('end', ()=&gt;&#123; console.log('connection end'); &#125;);&#125;);server.listen(8080);]]></content>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础正则表达式]]></title>
    <url>%2F2019%2F04%2F10%2Fregex%2F</url>
    <content type="text"><![CDATA[风格1234//JS风格let re = new RegExp('\\d+','g');//perl风格let re = /\d+/g; // '/'为定界符 选项i, 忽略大小写123let str = 'AAdsfasdfaertert';let re = /a/i; //找到aalert(str.search(re)); g, 全局匹配方法match 匹配123let str = "234sdfsfsd aser0934534sdf lert09345";let re = /\d+/g; //找出所有的数字alert(str.match(re)); replace替换12let str = "sdf3aedfsafd Adsffg Asdf";alert(str.replace(/a/gi,'*'));//替换掉所有的a为* test测试​ test返回true/false,注意的是如果是用test，不限定行首行尾的话，只要部分匹配就算true 量词 量词 释义 x? x,零次或一次 x* x,零次或多次 x+ x,一次或多次 x{n} x,恰好n次 x{n,} x,至少n次 x{n,m} x,至少n次，不超过m次 元字符-[]任何一个​ /a[abc]q/ - 可以匹配aaq,abq,acq,在正则中只要不写量词，默认就是匹配一个 范围​ /[a-z]/i ​ /[0-9] ​ /[a-z0-9]/ ​ [3-59] 这个不是匹配3~59而是代表可以是3~5或者是9，因为正则没有分隔符 排除^​ [^a-z0-9] 排除字母a-z和数字0-9 转义 转义名称 含义 \w [a-z0-9] \d [0-9] \s 空白字符，包括换行，tab \D [^0-9] \W [^a-z0-9] \S 非空白字符 . 任意字符，例如a，任意字符5-18，z，那么可以写成/a.{5,18}z/ 修饰符 修饰符 含义 ^ 注意，只有在元字符[]里面的^才代表排除，行首 $ 结尾 例，判定是否为QQ号，规则是第一个不为0，共5~12位数字，这里必须要加入行首^和行尾$ 123456let re = /^[1-9]\d&#123;4,11&#125;$/;if(str.test(re))&#123; //str.test如果正则里面不包含行首和结尾限定符（从头到尾），则只要字符串部分匹配也为true,例如ssd124768625d，也可以通过 alert("Pass");&#125;else&#123; alert("Fail");&#125; 优先级​ |-或优先级，或的优先级非常低，所以如果要匹配gif/png/jpg结尾的图片，写成/\.jpg|gif|png$/i其实是错的!在计算机眼里，因为或优先级很低，所以会读成要么.jpg,要么gif，要么png$, 所以字符串sdfgifsdgterstpng也可以匹配成功 12let re = /\.jpg|gif|png$/i; //Wronglet re = /\.(jpg|gif|png)$/i; 例，判定0-9999 123let re = /^(\d|[1-9]\d|[1-9]\d\d|[1-9]\d\d\d)$/;//可以简写成let re = /^(\d|[1-9]\d&#123;1,3&#125;)$/;]]></content>
      <tags>
        <tag>regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 基础知识]]></title>
    <url>%2F2019%2F04%2F09%2Fes6-basics%2F</url>
    <content type="text"><![CDATA[let vs. var先来看一个var的典型错误，主要原因是var没有块级作用域 12345678910window.onload = function()&#123; var aBtn = document.getElementByTagName('input'); for(var i=0; i&lt;aBtn.length; i++)&#123; aBtn[i].onclick = function()&#123; alert(i); &#125; &#125;&#125;//下面有四个&lt;input&gt;button 如果是用var来声明i，由于没有块级作用域，所以每次循环不会新建一个i，用的都是老的i，所以不管哪个button，alert的全都是4 要修改这个问题，可以声明i的时候用let，因为let是有块级作用域的，在for循环就是一个块级作用域，所以每循环一次会新建一个i 解构赋值123456let &#123;a,b,c&#125; = &#123;a:12,b:5,c:7&#125;;let [a,b,c] = [12,5,8];console.log(a,b,c);let &#123;a,b,c&#125; = &#123;12,5,8&#125;;//这个就会报错，右边必须要写全，如果是jsonlet &#123;a,b,c&#125; = &#123;d:5,e:8,f:0&#125;; //这个也会报错，因为右边没有a,b,c 箭头函数本质上就是一个简写 123456789function(para)&#123; &#125;//等同于(para)=&gt;&#123;&#125;//如果有且仅有一个参数，()可省略，如果有且仅有一条语句且这个语句为return，&#123;&#125;也可以省略let sum = (a,b)=&gt;a+b; 箭头函数另一个重要的功能就是修复了this 先来看一下this的问题，在别的语言里面this指向的是当前对象，但在JS里面会变。如果用箭头函数的话，这个this会牢牢绑定在当前的环境之下 12345678910let json = &#123; a:5, b:7, show:function()&#123; alert(this.a+this.b); &#125;&#125;//json.show(); //这个时候能够正确弹出12document.onclick = json.show; //但是这个时候却弹出的是NaN，因为这个时候你把json把绑到了document上面，this指向了document而不是json了！！ 如果这个时候你把json里面的show函数改成了箭头函数，则这个时候会指向window,因为json就是声明在全局里面的，这个时候全局是window,这个时候其实要用class才能把this绑定在json上面 系统对象 Array map 映射， 1对1，每个元素都变个样子 12345678let arr = [100,78,89,45,80];let res = arr.map(function(item,index)&#123; if(item&gt;=60)&#123; return 'Pass'; &#125;else&#123; return 'Fail'; &#125;&#125;); reduce 减少,多对一，多个进去，出来一个 1234567891011121314let arr = [34,234,56,123,76];//tmp是两个数相加的结果，第一个tmp的值为第一个数，即34arr.reduce(function(tmp,item,index)&#123; return tmp+item; //第一次tmp=34,item=234;第二次tmp=34+234,item=56&#125;);//求平均数arr.reduce(function(tmp,item,index)&#123; if(index &lt; arr.length - 1)&#123; return tmp+item; &#125;else&#123; return (tmp+item)/arr.length; &#125;&#125;) forEach 遍历， 循环一遍，与for循环一样 12345let arr = [12,78,455,80];arr.forEach((item,index)=&gt;&#123; alert('第'+index+'个是'+item); alert(`第$&#123;index&#125;个是&#123;item&#125;`);//也可以写成这种string拼接的形式&#125;) filter 过滤 12let arr = [12,67,8,3,4,78];arr.filter(item=&gt;item%2==0).filter(item=&gt;item&gt;=8); 异步操作 promise, 对异步操作进行了一个封装 123456789101112131415161718let p = new Promise(function(resolve,reject)&#123; $.ajax(&#123; url:'1.json', dataType:'json', success(data)&#123; resolve(data); &#125;, error(res)&#123; reject(res); &#125; &#125;)&#125;);p.then(function(data)&#123; alert(data);&#125;,function(res)&#123; alert(res);&#125;); //function(data)&#123;&#125;其实就是resolve,function(res)&#123;&#125;就是reject promise可以有all操作，只有里面的东西都完成了才能到then, all里面的执行是并行的，只要有一个有错，就全错 123456789Promise.all([ $.ajax(&#123;url:'1.json', dataType:'json'&#125;), $.ajax(&#123;url:'2.json', dataType:'json'&#125;), $.ajax(&#123;url:'3.json', dataType:'json'&#125;),]).then([data1,data2,data3]=&gt;&#123; //解构赋值可以直接放在参数里面 console.log(data1,data2,data3);&#125;,res=&gt;&#123; alert("Fail");&#125;) 如果第二个异步请求需要用到第一个异步请求的结果呢？用async/await async/awaitawait后面跟的是一个promise, 注意，这里只是方便了书写，但内部编译后还会是异步的 ,用async和await可以解决需要等待上一个异步操作结果的情况 1234567891011async function show()&#123; let data1 = await $.ajax(&#123;url:'1.json',dataType:'json'&#125;); if(data1.a &lt; 10)&#123; let data2 = await $.ajax(&#123;url:'2.json',dataType:'json'&#125;); alert(data2); &#125;else&#123; let data3 = await $.ajax(&#123;url:'3.json',dataType:'json'&#125;); alert(data3); &#125; console.log(data1, data2, data3);&#125; //写的样子像是同步的，但其实内部编译后还是异步的 ES6兼容性解决-babel 安装nodejs 安装babel 12npm init -y //生成package.json项目文件npm i @babel/core @babel/cli @babel/preset-env -D 修改package.json中的scripts 123456789101112&#123; "name": "Frontend", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "build": "babel src -d dest" &#125;, //用babel 编译src目录下的文件，到dest目标文件夹中 "keywords": [], "author": "", "license": "ISC"&#125; 建立预设环境.babelrc，比方说默认编译成什么版本 123&#123; "presets":["@babel/preset-env"]&#125; 运行脚本 1npm run build 面向对象class对象 12345678910111213class Person&#123; constructor(name,age)&#123; this.name = name; this.age = age; &#125; show()&#123; alert(this.name); alert(this.age); &#125;&#125;let p = new Person('hi',28);p.show(); 继承 1234567891011121314class Worker extends Person&#123; constructor(name,age,job)&#123; super(name,age); this.job = job; &#125; showJob()&#123; alert(this.job); &#125;&#125;let w = new Worker('ho',23,'farmer');w.show();w.showJob(); 闭包=留着别删每调用一个函数，就会为这个函数分配一个空间，这个空间就是栈。一般函数执行完了以后，这个空间就需要回收，但是闭包可以做到不让这个栈被回收。闭包底层是栈，其把整个函数封装到一个对象里面，这个对象就是栈，所以可以保存这个对象。 1234567function show()&#123; let a = 19; document.onclick = function()&#123; alert(a); &#125;&#125;show();//按理来说，这个a在执行外show以后需要被回收，但是document.onclick一直在用这个a，所以a就不会被回收 ES6模块化-webpackmod1.js 12//声明模块,需要输出什么就要export什么export let a = 12; index.js 123//引用模块import * as mod1 from './mod1'; //当前目录要加./alert(mod1.a); 安装webpack 1npm i webpack -g 配置webpack.config.js 12345678910const path = require('path');//node的模块化module.exports=&#123; mode: 'production', entry: './index.js', //nodejs里面同级目录必须要加./ output: &#123; //output必须是个object path: path.resolve(__dirname,'build'), //必须是绝对路径 filename: 'bundle.js' &#125;&#125;; Build webpack 1webpack Export/Import export export let a=12; export const a = xx; export {a,b,c}; export function xxx(){}; export class XXX{}; export default xx; 导出默认成员 import import * as mod from &quot;./xxx&quot;; import {a,b,c} from &quot;./xxx&quot;; import xxx from &quot;./mod&quot;; 模块里面没有xxx,这个时候引入的其实就是export default默认成员 import &quot;./1.css&quot;; import &quot;./1.jpg&quot;; 只是引入模块的代码，不引入内部成员，要配合webpack loader用 let promise = import(&quot;./mod1&quot;); 异步引用]]></content>
      <tags>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Mathjax设置]]></title>
    <url>%2F2019%2F04%2F08%2Fhexo-mathjax%2F</url>
    <content type="text"><![CDATA[转自ShallowLearner https://www.jianshu.com/p/7ab21c7f0674 问题hexo自带的hexo-renderer-marked渲染工具会将特殊的Markdown转换成相应的html标签，所以会有可能出错 123456789101112131415::after &#123; content: " "; position: absolute; -webkit-border-radius: 50%; border-radius: 50%; background: #fc625d; width: 12px; height: 12px; top: 0; left: 20px; margin-top: 13px; -webkit-box-shadow: 20px 0px #fdbc40, 40px 0px #35cd4b; box-shadow: 20px 0px #fdbc40, 40px 0px #35cd4b; z-index: 3; &#125; 解决方法 更换hexo markdown渲染引擎为hexo-renderer-kramed 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 解决行内公式的渲染找到node_modules\kramed\lib\rules\inline.js把escape和em变量修改为 1234// escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,escape: /^\\([`*\[\]()#$+\-.!_&gt;])/// em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/ 重新启动hexo 12hexo cleanhexo generate 在主题中开启mathjax开关 进入主题目录找到_config.yml更改mathjax默认的false为true 1234# MathJax Supportmathjax:enable: trueper_page: true 在Front-matter里打开Mathjax开关 123456---title: index.htmldate: 2016-12-28 21:01:30tags:mathjax: true--]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[math-basics]]></title>
    <url>%2F2018%2F09%2F12%2Fmath-basics%2F</url>
    <content type="text"><![CDATA[与其恐惧，不如直面它吧！ 对数函数基本公式为：$\log_a{MN} = \log_aM + \log_aN$$\log_a{\frac{M}{N}} = \log_aM - \log_aN$$\log_a{M^n} = n\log_aM$$\log_{a^n}M = \frac{1}{n}\log_aM$换底公式$\log_ba = \frac{\log_ca}{\log_cb}$倒数公式$\frac{1}{\log_ab} = \log_ba$ 三角函数[Ref:https://zhuanlan.zhihu.com/p/20102140][Ref:https://www.youtube.com/watch?v=diMjCkwL9Xo&amp;list=PLF38FCD363F7184B0&amp;index=7] 基础定义设角$\alpha$的的终边与单位圆交于点P(x,y),则有$\sin\alpha =y, \cos\alpha = x$$\tan\alpha = \frac{y}{x}, \cot\alpha = \frac{x}{y}$$\sec\alpha = \frac{1}{x},\csc\alpha = \frac{1}{y}$sec pronounces secantcsc pronounces cosecant 同角三角函数基本关系可以由上面的式子直接推导：$\tan\alpha\cot\alpha=1$$\sin\alpha\csc\alpha=1$$\cos\alpha\sec\alpha=1$还可以得出：$\frac{\sin\alpha}{\cos\alpha}=\tan\alpha=\frac{\sec\alpha}{\csc\alpha}$ $\frac{\cos\alpha}{\sin\alpha} = \frac{\csc\alpha}{\sec\alpha}$同时结合勾股定理，还可以得到$\sin^2\alpha + \cos^2\alpha =1$ 可以结合下面的图进行定义 基本公式的记忆方法根据一个单位圆就可以得出：$1^2+\tan^2\alpha=\sec^2\alpha$$1^2+\cot^2\alpha=\csc^2\alpha$ 广义角的定义与传统第一象限的三角函数定义相同，只不过带上了各个象限的讯息，就是到底是在x轴上下，还是y轴左右，还是x,y是同号还是异号。广义角的定义可以推出后面的傅里叶变换 角度制，弧度制弧度制也是描述角度的一种单位弧度制的含义就是一个单位圆，我把半径为1的长度放到周长上面，这个时候对应的角叫做一个Rad。那么如果我这个弧度角转一周，产生出来的角度是多少？也就是说可以用多少长度为1的线段来描述这个圆周，其实就是$$2\pi\text{r} = 360°$$也就是$2\pi = 360°$这样的话，对于弧长s/圆周长，就=这个时候的弧度角/一周的角，也就是：$$\frac{s}{2\pi\text{r}} = \frac{\theta}{2\pi}$$$$s=r\theta$$ 那么同理，对于面积：$$\frac{A}{\pi\text{r}^2} = \frac{\theta}{2\pi}$$也就是$A=\frac{\theta\text{r}^2}{2}$,又因为$s=\theta\text{r}$,所以：$$A = \frac{1}{2}sr$$有一点点像是一个三角形的面积，以s为底，r为高 偶函数与奇函数偶函数 f(x) = f(-x)，对y轴在做对称，cos(x)是偶函数, tan(x)也是偶函数 tan(x) = tan(-x)奇函数 f(x) = -f(-x),对原点在做对称，sin(x)是奇函数，cot(x)也是奇函数 三角函数的诱导公式]]></content>
      <tags>
        <tag>Math</tag>
        <tag>Concept</tag>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linear-algebra-graphics]]></title>
    <url>%2F2018%2F09%2F03%2Flinear-algebra-graphics%2F</url>
    <content type="text"><![CDATA[没想到我有生之年，还要再次学习一下线性代数。 凹！被数学支配的恐惧还涌在心头，依稀记得在大学的时候学的时候感觉都懂，过一个暑假全忘了（这种特殊技能同样包括各种电视剧，比方说什么射雕英雄传，鹿鼎记，还珠格格这种，看的时候那是比谁都清楚，看完就忘） 我也是佩服我自己的。好了，废话不多说了，现在毕竟科技发达了，不如以往，只能靠老师教的方法学。现在各种网上的资源很是丰富啊。 在众多资源中，一个3Blue1Brown的大神还有meetmath做的系列脱颖而出，我决定引用他们的例子，用这种图形化的学习方式重温一下线性代数。 MeetMath:[Ref: https://mp.weixin.qq.com/s?__biz=MzAxNzg3MTE3Ng==&amp;mid=2247485798&amp;idx=1&amp;sn=15a52a1e1fc3a2ba51353b66faa735db&amp;scene=21#wechat_redirect] 3Blue1Brown: [Ref:https://www.bilibili.com/video/av6240005/?spm_id_from=333.788.videocard.2] 向量的加法向量的加法这种，是唯一一个情况需要把一个向量移开原点的情况。为什么要移开呢？因为可以理解为从 $\vec{v}$ ,走到 $\vec{w}$ 就相当于$\vec{v}$+$\vec{w}$ 线性变换概念：必须具有两个性质，首先直线必须在变换后还是直线，且原点不能变 如何用数值来描述线性变换？变换后的向量都可以用基本的$\hat{i}$和$\hat{j}$来表示,只要告诉你变换后$\hat{i}$和$\hat{j}$的坐标，你就可以计算出$\begin{bmatrix}x\\y\end{bmatrix}$ 你就可以计算出$\begin{bmatrix}x\\y\end{bmatrix}$ -&gt; x$\begin{bmatrix} 1 \\ -2\end{bmatrix}$ + y$\begin{bmatrix}3 \\ 0\end{bmatrix}$ = $\begin{bmatrix}1x+3y \\ -2x+0y \end{bmatrix}$ shear的意思是保持x轴不变，然后转y轴 矩阵相乘对于矩阵$\begin{bmatrix}a &amp; b\\ c&amp;d \end{bmatrix}$$\begin{bmatrix} e&amp;f\\ g&amp;h \end{bmatrix}$,其实就是相当于先做了$\begin{bmatrix} e&amp;f\\ g&amp;h \end{bmatrix}$矩阵变换，然后做了$\begin{bmatrix}a &amp; b\\ c&amp;d \end{bmatrix}$矩阵变换，所以得出的结果就是： 所以如果根据矩阵相乘图形变化来思考M$_1$M$_2$ 是否= M$_2$M$_1$就很容易理解，因为两次矩阵变换的结果是不同的 ##行列式 DeterminantHow much the transformation strech/squish the areas?How much are areas scaled? Determinant is just how much your area scaled? from ASpace to X times ASpace, then A is the determinant of the matrix 行列式也可以是负数，负数的意思就是按照矩阵描述的变换方法变换，但结果这个平面翻转了，比方说原来$\hat{j}$在$\hat{i}$的左边，但是变换后$\hat{j}$在$\hat{i}$右边，这就造成了翻转 如果是3D的情况，则是volume被变了行列式的计算公式： det$(\begin{bmatrix}a &amp; b\\ c&amp;d \end{bmatrix})$ = ad-bc 逆矩阵 Inverse Matrices 列空间Column Space，秩Rank与零空间 Null Space对于$A\vec{x}=\vec{v}$,图形含义是对于向量$\vec{x}$，经过矩阵A的变换，与向量$\vec{v}$重合,也就是说A的行列式会变成0（也就是压缩成了一条线或者一个平面），还是strech/squish成之前一样的2/3维，也就是行列式不等于0 如果行列式不等于0：逆矩阵的意思是逆过来再做一次A矩阵，所以先做一次A矩阵，再做一次A逆矩阵，就相当于什么也没有做$A^{-1}A = \begin{bmatrix} 1&amp;0 \\ 0&amp;1 \end{bmatrix}$这个时候：$A\vec{x} = \vec{v}$就可以写成$A^{-1}A\vec{x} = A^{-1}\vec{v}$,也就是$\vec{x} = A^{-1}\vec{v}$这个含义就是You are playing the transformation in reverse and following v 如果行列式等于0,则没有逆矩阵的情况，因为不可能有一个逆操作，从一条线变成一个平面 方程组的解$$\begin{cases}a_1x+b_1y+c_1z=d_1 \\a_2x+b_2y+c_2z=d_2 \\a_3x+b_3y+c_3z=d_3\end{cases}$$上面用方程写成的矩阵向量相乘，也可以表示成$\begin{pmatrix} a_1&amp;b_1&amp;c_1 \\ a_2&amp;b_2&amp;c_2 \\ a_3&amp;b_3&amp;c_3 \end{pmatrix}$$\begin{pmatrix} x \\ y \\ z \end{pmatrix} = \begin{pmatrix} d_1 \\ d_2 \\ d_3 \end{pmatrix}$ 常系数矩阵A，未知量向量$\vec{x}$，两者的乘积得到列向量$\vec{v}$所以求解Ax = v就意味着我们要找到一个向量x，使得它再变换后与v完全重合如果有逆矩阵$\vec{x} = A^{-1}\vec{v}$来理解，也就是向量v经过矩阵A的逆变换到达了x 或者，对于方程组： $$\begin{cases}x+y=2 \\2x+2y=1 \\\end{cases}$$ 从列视图可以看作向量$\begin{pmatrix} 2 \\ 1 \end{pmatrix}$没有落在矩阵$A=\begin{pmatrix} 1&amp;1 \\ 2&amp;2 \end{pmatrix}$所指向的空间内(其实就是基向量$\begin{pmatrix} 1&amp;0 \\ 0&amp;1 \end{pmatrix}$做矩阵A的变化)，从下图的动画中可以看到经过矩阵变换后，空间最终被压缩成了一条直线，而变化全程向量$\vec{v}$都处在直线外，所以这个方程组无解 这个方程组有解就代表矩阵A所代表的变换没有将空间进行扁平化的压缩。即$det(A) \neq 0$ width=100% height=600px frameborder=”0” scrolling=”no” src=”http://mmbiz.qpic.cn/mmbiz_gif/WBqG5VGfdMEA8wxqLQrofiaN5OAAEiaMduI9WiaiaibPHWf4O5kHdGodlgp1WBEDvJLY1Iuze2yCyO13DCM8PghGfmw/0?wx_fmt=gif&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&quot; Rank矩阵的秩When the output of transformation is a line, meaning it’s one-dimensional, then we say the transformation has a rank of 1 If all the vectors land on some two-dimensional plane, we say the transformation has a rank of 2. 也就是说矩阵的秩代表着变换后，其空间的维数 Column SpaceThis set of all possible outputs for your matrix, whether it’s a line, a plane, 3-D space whatever, is called the “column space” of your matrix Full Rank满秩When this rank is as high as it can be, meaning it equals the numner of columns, we call the matrix “full rank” Null Space/Kernal零空间，核This set of vectors that lands on the origin is called the “null space” or the “kernal” of your matrix,一般表示成dim Ker(X),也就是零空间的维度 维数定理如果A是m*n 矩阵，维数定理就是：$dim Ker(A) + rank(A) = n$ 点积Dot Product与对偶性duality点积Dot Product[Ref:https://betterexplained.com/articles/vector-calculus-understanding-the-dot-product/] Think of the dot product as directional multiplication.If a vector is “growth in a direction”, there’s a few operations we can do: Add vectors, Accumulate the growth contained in several vectors Multiply by a constant: Make an existing vector stronger Dot product: Applyt the directional growth of one vector to another. The result is how much stronger we’ve made the original. 所以当有两个不同方向的向量相乘，这代表什么意思呢？可以理解为两个向量不同组成部分的相乘由于$\vec{a}$可以由$a_x$和$a_y$来表示，$\vec{b}$也可以由$b_x$和$b_y$来表示，那么$\vec{a} \cdot \vec{b}$ = $a_x \cdot b_x$ + $a_y \cdot b_x$(=0) + $a_x \cdot b_y$(=0) + $a_y \cdot b_y$来表示 由于两个垂直的向量相乘=0，所以$\vec{a} \cdot \vec{b}$也就可以表示成： $$a_x \cdot b_x + a_y \cdot b_y$$ 或者通过Rotate来理解点积由于想要知道两个向量的growth,可以把其中一个向量投影到另一个向量（即与另一个向量相同部分），这样两个向量就是相同的方向，其点积也就是相同方向向量的点积。 所以$\vec{a}$在$\vec{b}$上面相同的部分就是$\vec{a}$在$\vec{b}$上面的投影，也就是$|a|\cos(\theta) \cdot |b|$ 点积的图形意义就是向量$\vec{w}$在向量$\vec{v}$上的投影长度 * 向量$\vec{v}$的长度，如果是反方向，则点积为负，如果是相同方向，点积为正，如果两个向量成直角，则点积为0. 并且$(2\vec{v} \cdot \vec{w}) = 2(\vec{v} \cdot \vec{w})$ 但是为什么点积的计算方式（就是对应变量相乘然后相加）会与Projection（投影）有关呢？ 点积的几何意义：What it means to apply one of these transofrmations to a vector.例如对于向量$\begin{bmatrix} 4 \\ 3 \end{bmatrix}$,有一个线性变换，将$\hat{i}$和$\hat{j}$变换至1和-2，也就是说这个transform matrix就是$\begin{bmatrix} 1&amp;-2 \end{bmatrix} $,要跟踪向量$\begin{bmatrix} 4 \\ 3 \end{bmatrix}$变换后的去向，就将这个向量分解成为4*$\hat{i}$ + 3*$\hat{j}$，由于线性性质，所以在变换后，这个向量的位置就是4*变换后的$\hat{i}$，也就是1,加上变换后的$\hat{j}$，也就是3(-2)，所以最终它变换成-2 Duality对偶性(我觉得我看了不下5遍…)那么为什么点积坐标的相加与投影有关系呢？ 在坐标中可以定义一个u轴穿越原点。我们的目标就是将坐标中的任意一个向量，变成u轴上面的一个数字。换句话说，我们要能找到一个1*2的矩阵，能够描述这个变化。或者说，任意变量经过线性变换后，跑到了U轴上变成一个点，这个时候$\hat{i}$与$\hat{j}$也在U轴上面。那么$\hat{i}$和$\hat{j}$的值又是什么呢？ 这个时候，我们可以加一条对称线来辅助计算。变换后的$\hat{i}$和$\hat{j}$就是这个矩阵的列值。根据对称性，变换后的$\hat{i}$其实就是$\vec{u}$在x轴上面的投影，也就是$u_x$,同理，变换后的$\hat{j}$其实就是$u_y$，也就是说这个变化矩阵transform matrix就是$\begin{bmatrix} u_x&amp;u_y \end{bmatrix}$ 那么，对于空间中任意一个向量$\begin{bmatrix} x \\ y \end{bmatrix}$,从自身一个二维向量映射到U轴上面的数值的这一变化，就可以描述成$$\begin{bmatrix} u_x&amp;u_y \end{bmatrix}\begin{bmatrix} x \\ y \end{bmatrix} = u_x \cdot x + u_y \cdot y$$，也就是向量在U轴上面投影的长度 对于这种二维向量变成一维数值，其本身的定义就是$$\begin{bmatrix} u_x \\ u_y \end{bmatrix} \cdot \begin{bmatrix} x \\ y \end{bmatrix} = u_x \cdot x + u_y \cdot y$$ 这么一来，可以发现$\begin{bmatrix} u_x&amp;u_y \end{bmatrix}\begin{bmatrix} x \\ y \end{bmatrix} = u_x \cdot x + u_y \cdot y$与$\begin{bmatrix} u_x \\ u_y \end{bmatrix} \cdot \begin{bmatrix} x \\ y \end{bmatrix} = u_x \cdot x + u_y \cdot y$相等 也就是说，对于单位向量的点积可以解读为将向量投影到单位向量所在的直线上所得到的长度 至此，两个向量点积，就是将其中一个向量转化为线性变换$$\begin{bmatrix} x_1 \\ y_1 \end{bmatrix} \cdot \begin{bmatrix} x_2 \\ y_2 \end{bmatrix}$$$$\begin{bmatrix} x_1&amp;y_1 \end{bmatrix}\begin{bmatrix} x_2 \\ y_2 \end{bmatrix}$$ Cross products叉积[Ref:https://betterexplained.com/articles/cross-product/] 点积关注的是相同部分的interaction,而叉积关注的是不同部分，见下图： 而面积其实就是不同部分造成的一种结果。比方说两个相同方向的变量，是没有面积的，只有不同方向且不在一条线上的变量才有面积/体积的概念。在物理中比方说力矩(torque)，只有在不同方向上才有力矩的概念 叉积就是想定义一个rule,把所有不同的部分加起来再看一遍上面的图，根据右手定理，x cross y能够定义一个正z，但是y cross x就是一个负zy cross z is x, z cross z is -x;所以记住这个Order XYZXYZ（这个就是一个正的顺序，只要按照这个顺序做，就是正的方向）。那么：$$(1,2,3) \times (4,5,6) = ?$$ 先看z，z由x,y来定义，根据XYZ这个顺序，只要是x cross y，则z为正，所以$$z = 1 \times 5 - 2 \times 4 = -3$$再看y，y由x,z来决定，根据XYZXYZ这个顺序。只要是z cross x，则y为正，所以$$y = -1 \times 6 + 3 \times 4 = 6$$最后看x，x由y,z决定，根据XYZ这个顺序，y cross z = positive x:$$x = 2 \times 6 - 3 \times 5 = -3$$所以最终结果为(-3,6,-3) ———————————-3Blue1Brown———————————— 叉积的定义就是两个向量组成的平行四边形的面积$$\vec{v} \times \vec{w} = \text{Area of parallelogram} $$如果$\vec{v}$在$\vec{w}$的右边，叉积为正，如果在左边，叉积为负 由于变换后的向量构成面积就相当于行列式，所以$$\vec{v} \times \vec{w} = det(\begin{bmatrix} 3&amp;2 \\ 1&amp;-1 \end{bmatrix})$$ 更为准确的理解是在3D视图中，叉积是指以两个向量的面积为长度，右手定理大拇指为方向的一个向量，注意，这里$\vec{p}$是一个向量$$\vec{v} \times \vec{w} = \vec{p}$$$\vec{p}$的长度就是$\vec{v}$和$\vec{w}$所形成的平行四边形的面积同时$\vec{p}$的方向与这个平行四边形垂直 更为通用的公式： 这里就有一个疑问了，我为什么行列式第一列要放$\hat{i},\hat{j},\hat{k}$?这里要用对偶性来解释 对偶性：无论何时你看到一个二维到一维的线性变换，你都能在平面中这个到这个向量。用这个线性变换得到的结果与用这个向量做点积是一样的结，比方说$\begin{bmatrix} 4&amp;1 \end{bmatrix}$这个线性变换，线性变换后的结果与以$\begin{bmatrix} 4 \\ 1 \end{bmatrix}$做点积结果相同. 数值上来解释的话，这是因为这类线性变换可以用一个只有一行的矩阵来描述，而这个矩阵的每一列给出了变换后基向量的位置。 这里的收获在于，每当你看到一个从空间到数轴的线性变换，你就能找到一个向量（成为这个线性变换的对偶向量），使得应用线性变换和对偶向量点乘等价。 回到叉积上面1，叉积就是要根据给定的$\vec{v}$和$\vec{w}$做一个从3维空间到一维的线性变换（回忆一下，二维到一维的变换就是给定了一个$\vec{u}$）2，然后我们要根据这个变换找到其对应的对偶向量3，这个对偶向量就会是$\vec{v}$和$\vec{w}$的叉积 对于空间中任意一个向量$\begin{bmatrix} x \\ y \\ z \end{bmatrix}$,其与$\vec{v}$与$\vec{w}$形成的平行四边形的体积可以表示成：$$f(\begin{bmatrix} x\ y\ z \end{bmatrix}) = det(\begin{bmatrix} x&amp;v_1&amp;w_1 \\ y&amp;v_2&amp;w_2 \\ z&amp;v_3&amp;w_3 \end{bmatrix})$$ 这个函数一个重要特征就是，这是个线性函数：(平行，等距，固定原点)1.易知，当u取原点时，这一变换会使之缩到原点，因为这个平行六面体已经没有高了.2.根据相似的原理，当u在一条直线上运动时，这个平行六面体的体积与u的长度成正比3.所以在这条直线上等距取u时，这一变换会使得这些点在数轴上等距分布 一旦你知道这个是线性的，我们就可以运用对偶性来解决问题，也就是f()部分可以改成一个1x3矩阵与向量$\begin{bmatrix} x \ y \z \end{bmatrix}$的线性变换： $$\begin{bmatrix} ?&amp;?&amp;? \end{bmatrix}\begin{bmatrix} x \\ y \\ z \end{bmatrix} = det(\begin{bmatrix} x&amp;v_1&amp;w_1 \\ y&amp;v_2&amp;w_2 \\ z&amp;v_3&amp;w_3 \end{bmatrix})$$ 并且由于对偶性（也就是线性变换可以用这个矩阵的倒置与特定向量(x,y,z)来做点积来表示） $$\begin{bmatrix} ?\\?\\? \end{bmatrix} \cdot \begin{bmatrix} x \ y \ z \end{bmatrix} = det(\begin{bmatrix} x&amp;v_1&amp;w_1 \\ y&amp;v_2&amp;w_2 \\ z&amp;v_3&amp;w_3 \end{bmatrix})$$ 所以说我们要找的就是这个特殊的3D向量$\vec{p}$，使得向量p与其他任一向量(x,y,z)的点积等于一个3x3矩阵的行列式(这个矩阵第一列为这个任一向量(x,y,z),其余两列分别为v和w的坐标) 这个时候我们从计算的角度来看，p的值单纯就由向量$\vec{v}$与向量$\vec{w}$来表示$$\begin{cases}p_1 = v_2 \cdot w_3 - v_3 \cdot w_2 \\p_2 = v_3 \cdot w_1 - v_1 \cdot w_3 \\p_3 = v_1 \cdot w_2 - v_2 \cdot w_1\end{cases}$$ 这个计算过程与叉积的计算定义是如此的相似,而叉积定义中的$\hat{i},\hat{j},\hat{k}$只不过在传递一个信号，也就是我们应该把这些系数解读为一个向量的坐标 从Geomatrically理解 首先$\vec{p} \cdot \begin{bmatrix} x\\y\\z \end{bmatrix}$的几何意义就是将这个(x,y,z)向量映射到向量$\vec{p}$上，然后将这个投影长度与p的长度相乘: 然后再从平行六边形体积的计算方式来看，首先是一个平行四边形面积(向量$\vec{v}$,$\vec{w}$)的底乘以向量(x,y,z)在垂直于平行四边形方向上的分量 这个时候我们来看这个公式：$$\vec{p} \cdot \begin{bmatrix} x \ y \ z \end{bmatrix} = det(\begin{bmatrix} x&amp;v_1&amp;w_1 \ y&amp;v_2&amp;w_2 \ z&amp;v_3&amp;w_3 \end{bmatrix})$$就可以看成：$$\vec{p} \cdot \begin{bmatrix} x \ y \ z \end{bmatrix} = \text{(Area of the parallelogram)} \times \text{(Component of }\begin{bmatrix} x\y\z \end{bmatrix} \text{perpendicular to v and w)}$$其中左边代表向量(x,y,z)映射到$\vec{p}$的长度再$\times \vec{p}$的长度，右边(Component….)刚好与“向量(x,y,z)映射到$\vec{p}$的长度”的意义相同，所以$\vec{p}$的长度也就是(Area of the parallelogram) 基变换 用我们的基变量替换别人的基变量得到在我们坐标下变换后的变量其实这个计算过程，就相当于矩阵的相乘：]]></content>
      <tags>
        <tag>Concept</tag>
        <tag>Maths</tag>
        <tag>LinearAlgebra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-crawler]]></title>
    <url>%2F2018%2F08%2F14%2Fpython-crawler%2F</url>
    <content type="text"><![CDATA[XPath路径表达式* nodename选取此节点的所有子节点 * /从根节点选取 * //从匹配的当前节点选择文档中的节点，而不考虑他们的位置 * . 选取当前节点 * .. 选取当前节点的父节点 * @选取属性 1234567891011&lt;?xml version="1.0"?&gt;&lt;bookstore&gt; &lt;book&gt; &lt;title lang="eng"&gt;Harry Potter&lt;/title&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt; &lt;book&gt; &lt;title lang="eng"&gt;Learn XML&lt;/title&gt; &lt;price&gt;75&lt;/price&gt; &lt;/book&gt;&lt;/bookstore&gt; 例子 * bookstore 选取bookstore元素的所有子节点 * /bookstore 选取根元素bookstore * /bookstore/book 选取属于bookstore的子元素的所有book元素 * //book 选取所有book元素，而不管它们在文档中的位置。 * bookstore//book 选择属于bookstore元素的后代的所有book元素 * //@lang 选取名为lang的所有属性 谓语 * 嵌在[]中用来查找某个特定节点或包含某个指定值得节点。 * /bookstore/book[1] 第一个book元素 * /bookstore/book[last()] 最后一个book元素 * /bookstore/book[position()&lt;3] 选择前2个 * //title[@lang] 选择所拥有有名为lang的属性的title元素 * /bookstore/book[price&gt;35.00] 正则表达式基本匹配规则 * [0-9] 任意一个数字，等价\d * [a-z] 任意一个小写字母 * [A-Z]任意一个大写字母 * [^0-9] 匹配非数字，等价\D * \w 等价[a-z0-9_]，字母数字下划线 * \W 等价对\w取非 * . 任意字符 * [] 匹配内部任意字符或子表达式 * [^] 对字符集合取非 * * 匹配前面的字符或者子表达式0次或多次 * + 匹配前一个字符至少1次 * ？ 匹配前一个字符0次或1次 * ^ 匹配字符串开头 * $ 匹配字符串结束 * 用selenium模拟用户打开浏览器然后抓数据包含如果网页有惰性加载的情况，需要scroll到页面最底部12345678910111213141516171819202122232425from selenium import webdriverimport timebrowser = webdriver.Chrome()browser.set_page_load_timeout(30)browser.get('http://www.17huo.com/search.html?sq=2&amp;keyword=%E7%BE%8A%E6%AF%9B')page_info = browser.find_element_by_css_selector('body &gt; div.wrap &gt; div.pagem.product_list_pager &gt; div')# print(page_info.text)pages = int((page_info.text.split('，')[0]).split(' ')[1])for page in range(pages): if page &gt; 2: break url = 'http://www.17huo.com/?mod=search&amp;sq=2&amp;keyword=%E7%BE%8A%E6%AF%9B&amp;page=' + str(page + 1) browser.get(url) browser.execute_script("window.scrollTo(0, document.body.scrollHeight);") time.sleep(3) # 不然会load不完整 goods = browser.find_element_by_css_selector('body &gt; div.wrap &gt; div:nth-child(2) &gt; div.p_main &gt; ul').find_elements_by_tag_name('li') print('%d页有%d件商品' % ((page + 1), len(goods))) for good in goods: try: title = good.find_element_by_css_selector('a:nth-child(1) &gt; p:nth-child(2)').text price = good.find_element_by_css_selector('div &gt; a &gt; span').text print(title, price) except: print(good.text) 保存图片用Requests12345678910111213import requestsfrom PIL import Imagefrom io import BytesIOr = requests.get('https://images.unsplash.com/photo-1504714146340-959ca07e1f38?ixlib=rb-0.3.5&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;s=2c5ef407d31cf63f60bd7782132ee877&amp;auto=format&amp;fit=crop&amp;w=925&amp;q=80')image = Image.open(BytesIO(r.content))image.save('scenary.png')#原始数据处理,例stream数据，一点点读出来，而不是一次性读出来r = requests.get('https://images.unsplash.com/photo-1504714146340-959ca07e1f38?ixlib=rb-0.3.5&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;s=2c5ef407d31cf63f60bd7782132ee877&amp;auto=format&amp;fit=crop&amp;w=925&amp;q=80', stream = True)with open('scenary2.png', 'wb+') as f: for chunk in r.iter_content(1024): f.write(chunk) ScrapyArchitecture Overview 1. Engine从Spider那里拿到初始Url 2. Engine把Requests丢给Scheduler,Scheduler返回下一个需要爬的requests 3. Scheduler生成下一个Requests 4. Engine把新的Requests丢给Downloader，让其下载页面 5. Downloader下载完（生成Response）后返回给Engine 6. Engine把这个Response丢给Spider让他处理 7. Spider把Response变成你定义规则的Scraped Items，如果有新的需要爬的，重新传给Engine 8. Engine把Scraped Items传给Item Pipelines,在ItemPipelines里面可以保存到数据库，对数据清洗等等。然后Engines再问Schedule是否还有需要Requests的东西 9. 从Step1循环，直至没有新的Requests User Login注意点一，start_requests()方法必须返回一个iterable.Scrapy calls it only once, so it is safe to implement start_requests() as a generator. 注意点二，用FormRequest可以通过HTTP POST方式发送数据123return [FormRequest(url="http://www.example.com/post/action", formdata=&#123;'name': 'John Doe', 'age': '27'&#125;, callback=self.after_post)] 注意点三，FormRequest.from_response()可以模拟用户登陆1234567891011121314151617181920import scrapyclass LoginSpider(scrapy.Spider): name = 'example.com' start_urls = ['http://www.example.com/users/login.php'] def parse(self, response): return scrapy.FormRequest.from_response( response, formdata=&#123;'username': 'john', 'password': 'secret'&#125;, callback=self.after_login ) def after_login(self, response): # check login succeed before going on if "authentication failed" in response.body: self.logger.error("Login failed") return # continue scraping with authenticated session... 注意点四，scrapy.FormRequest的meta作用，是向response传递数据注意点五，dont_filter=True意味着如果需要多次提交表单，且url一样，那么就让爬虫继续爬，否则爬虫会有去重机制不会再爬这个页面示例：登陆然后爬数据 例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import scrapyfrom PIL import Imagefrom urllib.request import urlretrieveclass MovieCommentSpider(scrapy.Spider): name = 'movie_comment' allowed_domains = ['accounts.douban.com', 'douban.com'] headers = &#123; "User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.221 Safari/537.36 SE 2.X MetaSr 1.0" &#125; def start_requests(self): return [scrapy.FormRequest("https://accounts.douban.com/login" , headers=self.headers , meta=&#123;"cookiejar": 1&#125;, callback=self.parse_before_login)] def parse_before_login(self, response): captcha_id = response.xpath('//input[@name="captcha-id"]/@value').extract_first() captcha_image_url = response.xpath('//img[@id="captcha_image"]/@src').extract_first() if captcha_image_url is None: formdata = &#123; "source": "index_nav", "form_email": "************@yahoo.com.cn", "form_password": "***************", &#125; else: save_image_path = "D:\\captcha.jpeg" # 将图片验证码下载到本地 urlretrieve(captcha_image_url, save_image_path) # 打开图片，以便我们识别图中验证码 try: im = Image.open('captcha.jpeg') im.show() except: pass # 手动输入验证码 captcha_solution = input('**********Please input capture:*************') formdata = &#123; "source": "None", "redir": "https://www.douban.com", "form_email": "******************@yahoo.com.cn", # 此处请填写密码 "form_password": "*****************", "captcha-solution": captcha_solution, "captcha-id": captcha_id, "login": "登录", &#125; # 提交表单 return scrapy.FormRequest.from_response(response , meta=&#123;"cookiejar": response.meta["cookiejar"]&#125; , headers=self.headers , formdata=formdata , callback=self.parse_after_login) def parse_after_login(self, response): ''' 验证登录是否成功 ''' account = response.xpath('//a[@class="bn-more"]/span/text()').extract_first() if account is None: print("Login Failed") else: print("Login Success,Current account is &#123;0&#125;".format(account))]]></content>
      <tags>
        <tag>practice</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-third-packages]]></title>
    <url>%2F2018%2F08%2F09%2Fpython-third-packages%2F</url>
    <content type="text"><![CDATA[数值计算numpy1，numpy的ndarray是一个多维数组对象，该对象由两部分组成： 1，实际的数据 2，描述这些数据的元数据，比方说数据是如何排列的，结构是什么样 3，很多时候我们只修改的是元数据，而不更改实际数据2，numpy能够直接对数组和矩阵进行操作，不需要写python，所以会比较快3，numpy基本索引和切片：123456789101112131415161718192021222324252627import numpy as np# 数组乘法/减法，对应元素相乘/相减arr = np.array([[1.0,2.0,3.0],[4.,5.,6.]])print(arr * arr)print(arr - arr)# 标量操作作用在数组的每个元素上arr = np.array([[1.0,2.0,3.0],[4.,5.,6.]])print(1/arr)print(arr**0.5) #开根号# 通过索引访问二维数组某一行或某个元素arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])print(arr[2])#打印出第三个元素print(arr[0][2])#打印出第一个元素中的第三个元素print(arr[0, 2]) # 普通Python数组不能用。# 对更高维数组的访问和操作arr = np.array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])print (arr[0]) # 结果是个2维数组print (arr[1, 0]) # 结果是个2维数组old_values = arr[0].copy() # 复制arr[0]的值arr[0] = 42 # 把arr[0]所有的元素都设置为同一个值print (arr)arr[0] = old_values # 把原来的数组写回去print (arr) 4，numpy boolean索引123456789101112131415import numpy as npimport numpy.random as np_randomprint ('使用布尔数组作为索引')name_arr = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])rnd_arr = np_random.randn(7, 4) # 随机7*4数组print (rnd_arr)print (name_arr == 'Bob') # 返回布尔数组，元素等于'Bob'为True，否则False。print (rnd_arr[name_arr == 'Bob'])# 利用布尔数组选择行print (rnd_arr[name_arr == 'Bob', :2]) # 增加限制打印列的范围print (rnd_arr[-(name_arr == 'Bob')])# 对布尔数组的内容取反mask_arr = (name_arr == 'Bob') | (name_arr == 'Will') # 逻辑运算混合结果print (rnd_arr[mask_arr])rnd_arr[name_arr != 'Joe'] = 7 # 先布尔数组选择行，然后把每行的元素设置为7。print (rnd_arr) 5，numpy的花式索引1234567891011121314151617#比方说我想要索引在第5，第3，第1位的元素a = [1,2,3,4,5]b = a[[5,3,1]] #即可import numpy as npprint ('Fancy Indexing: 使用整数数组作为索引')arr = np.empty((8, 4))for i in range(8): arr[i] = iprint (arr)print (arr[[4, 3, 0, 6]]) # 打印arr[4]、arr[3]、arr[0]和arr[6]。print (arr[[-3, -5, -7]]) # 打印arr[3]、arr[5]和arr[-7]行arr = np.arange(32).reshape((8, 4)) # 通过reshape变换成二维数组print (arr[[1, 5, 7, 2], [0, 3, 1, 2]]) # 打印arr[1, 0]、arr[5, 3]，arr[7, 1]和arr[2, 2]print (arr[[1, 5, 7, 2]][:, [0, 3, 1, 2]]) # 1572行的0312列print (arr[np.ix_([1, 5, 7, 2], [0, 3, 1, 2])]) # 可读性更好的写法 6，numpy的ndarray数组转置和轴对换12345678910111213import numpy as npprint("矩阵的乘积，(axb)*(cxd)=(a'xd')，要求b=c")arr1 = [[1,2,3],[4,5,6]]arr2 = [[4,5],[6,7],[8,9]]# print(np.dot(arr1,arr2))print("高维矩阵轴变换")arr3 = np.arange(16).reshape((2,2,4))print(arr3)# 决定总共有多少列取决于原来的A[x][y][z]的z，最大层有几个元素取决于原来的x，所以如果轴变换为（2，1，0）那么最终由两列，四个最大层元素。把结构画好了以后再转换就会很快# print(np.ndim(arr3))print(arr3.transpose((2,1,0))) 7，numpy where条件过滤12345678910111213141516171819202122import numpy as npimport numpy.random as np_randomprint("where")cond = np.array([True,False,True,True,False])cond_1 = np.array([True,False,True,True,False])cond_2 = np.array([False,True,False,True,False])result = []#传统代码如下for i in range(len(cond)): if cond_1[i] and cond_2[i]: result.append(0) elif cond_1[i]: result.append(1) elif cond_2[i]: result.append(2) else: result.append(3)print(result)# np版本result = np.where(cond_1 &amp; cond_2, 0, np.where(cond_1, 1, np.where(cond_2, 2, 3)))print(result) 8，numpy 求和求平均12345678import numpy as npprint("求和，求平均")arr = np.random.randn(5,4)print(arr)print(arr.mean())#所有元素求平均print(arr.mean(axis = 1)) #对每一行的元素求平局print(arr.sum())#所有元素求和print(arr.sum(0))#对每一列的元素求和 9，numpy布尔型数组过滤123456789import numpy as npprint("对正数求和")arr = np.random.randn(100)print((arr&gt;0).sum())print("对数组逻辑操作")bools = np.array([False,False,True,False])print(bools.any())#有一个为True则返回Trueprint(bools.all())#有一个为False则返回False 10，利用数组进行数据处理和排序12345678910print ('二维数组排序')arr = np_random.randn(5, 3)print (arr)arr.sort(1) # 对每一行元素做排序print (arr)print ('找位置在5%的数字')large_arr = np_random.randn(1000)large_arr.sort()print (large_arr[int(0.05 * len(large_arr))]) 11，利用数组来去重以及其它集合运算 例子：距离矩阵的计算给定m*n阶矩阵X，满足X = [x1,x2,…,x n],这里第i列向量是m维向量。求n * n矩阵，使得Dij=||xi - x&gt; j||2 这个例子的意思是有xi,xjDij = (x[0][i] - x[0][j])2 + (x[1][i] - x[1][j])2 + … + (x[m][i] - x[m][j])2 12345678910111213141516171819202122232425262728293031323334import numpy as npimport numpy.linalg as laimport timeX = np.array([range(0,500),range(500,1000)])# print(X)m,n = X.shapet = time.time()D = np.zeros([n,n])for i in range(n): for j in range(i+1, n): D[i,j] = la.norm(X[:, i] - X[:, j]) ** 2 D[j,i] = D[i,j]print(time.time() - t) t = time.time()D = np.zeros([n,n])#d[k] = X[k][i] -X[k][j]#d[i,j] = d[0]^2 + d[1]^2for i in range(n): for j in range(i+1, n): #把第i列和第j列相减 d = X[:, i] - X[:, j] #然后做矩阵乘法的运算 D[i,j] = np.dot(d,d) D[j,i] = D[i,j]print(time.time()-t)t = time.time()G = np.dot(X.T, X)H = np.tile(np.diag(G), (n, 1))D = H + H.T - G * 2print (time.time() - t) 数据处理分析pandas数据结构Series1，Series是一种类似于一维数组的对象，它由一组数据（各种NumPy数据类型）以及一组与之相关的数据标签（即索引）组成2，Series的字符串表现形式为：索引在左边，值在右边3，默认是数字索引1234567891011121314from pandas import Seriesprint("用数组生成series")obj = Series([5,7,-1,3])print(obj)print("指定Series的index")obj2 = Series([5,7,-1,3], index = ['a','b','c','d'])print(obj2)print("使用字典生成Series")dData = &#123;'ohio':3999,"texas":2000,"oregon":123123&#125;obj3 = Series(dData)print(obj3) 数据结构DataFrame1，DataFrame是一个表格型数据结构，它含有一组有序的列，每列可以试不同的值的类型（数值、字符串、布尔值等）2，DataFrame既有行索引，也有列索引，可以被看做由Series组成的字典（共用同一个索引）。1234567891011121314151617181920212223242526272829import numpy as npfrom pandas import Series, DataFrameprint('用字典生成DataFrame，key为列的名字。')data = &#123;'state':['Ohio', 'Ohio', 'Ohio', 'Nevada', 'Nevada'], 'year':[2000, 2001, 2002, 2001, 2002], 'pop':[1.5, 1.7, 3.6, 2.4, 2.9]&#125;print(DataFrame(data))print(DataFrame(data, columns = ['year', 'state', 'pop'])) # 指定列顺序print '指定索引，在列中指定不存在的列，默认数据用NaN。'frame2 = DataFrame(data, columns = ['year', 'state', 'pop', 'debt'], index = ['one', 'two', 'three', 'four', 'five'])print frame2print frame2['state']print frame2.yearprint frame2.ix['three']frame2['debt'] = 16.5 # 修改一整列print frame2frame2.debt = np.arange(5) # 用numpy数组修改元素print frame2printprint '赋值给新列'frame2['eastern'] = (frame2.state == 'Ohio') # 如果state等于Ohio为Trueprint frame2print frame2.columnsprint 3，数据的清理用drop123456789101112131415161718import numpy as npfrom pandas import Series, DataFrameprint 'Series根据索引删除元素'obj = Series(np.arange(5.), index = ['a', 'b', 'c', 'd', 'e'])new_obj = obj.drop('c')print new_objprint obj.drop(['d', 'c'])printprint 'DataFrame删除元素，可指定索引或列。'data = DataFrame(np.arange(16).reshape((4, 4)), index = ['Ohio', 'Colorado', 'Utah', 'New York'], columns = ['one', 'two', 'three', 'four'])print dataprint data.drop(['Colorado', 'Ohio'])print data.drop('two', axis = 1) #axis=1代表处理的是列print data.drop(['two', 'four'], axis = 1) #原始数据并没有被删除 Pandas Data Selection 准备数据123456import pandas as pdimport randomdata = pd.read_csv('https://s3-eu-west-1.amazonaws.com/shanebucket/downloads/uk-500.csv')data['id'] = [random.randint(0,1000) for x in range(data.shape[0])]data.head(5) 1, By row numbers(.iloc)“iloc” in pandas is used to select rows and columns by numberdata.iloc[&lt;row selection&gt;,&lt;column selection&gt;] 注意是开区间，你选择[1:5]返回的是1,2,3,4123456789101112131415# Single selections using iloc and DataFrame# Rows:data.iloc[0] # first row of data frame (Aleshia Tomkiewicz) - Note a Series data type output.data.iloc[1] # second row of data frame (Evan Zigomalas)data.iloc[-1] # last row of data frame (Mi Richan)# Columns:data.iloc[:,0] # first column of data frame (first_name)data.iloc[:,1] # second column of data frame (last_name)data.iloc[:,-1] # last column of data frame (id)# Multiple row and column selections using iloc and DataFramedata.iloc[0:5] # first five rows of dataframedata.iloc[:, 0:2] # first two columns of data frame with all rowsdata.iloc[[0,3,6,24], [0,5,6]] # 1st, 4th, 7th, 25th row + 1st 6th 7th columns.data.iloc[0:5, 5:8] # first 5 rows and 5th, 6th, 7th columns of data frame (county -&gt; phone1). 2, By label or by a conditional statement(.loc) a) Selecting rows by label/index b) Selecting rows with a boolean/conditional lookup 注意用loc就不是开区间，而是闭区间了，Veness行和email列都会被选出来123456789101112data.set_index("last_name", inplace=True)data.head()data.loc['Andrade':'Veness', 'city':'email']#Conditional lookupdata.loc[data['first_name'] == 'Erasmo',['company_name','email']]# Select rows where the email column ends with 'hotmail.com', include all columnsdata.loc[data['email'].str.endswith("hotmail.com")] # Select rows with last_name equal to some values, all columnsdata.loc[data['first_name'].isin(['France', 'Tyisha', 'Eric'])] 在这里注意了如果data.loc[data[&#39;first_name&#39;] == &#39;Erasmo&#39;,&#39;email&#39;]即以.loc[,String]形式，返回的是一个Series 如果data.loc[data[&#39;first_name&#39;] == &#39;Erasmo&#39;,[&#39;email&#39;]即以.loc[,List]形式，返回的是一个DataFrame 可视化matplotlib/seaborn1234import numpy as np; np.random.seed(0)import seaborn as sns; sns.set()uniform_data = np.random.rand(10, 12)ax = sns.heatmap(uniform_data) 机器学习Sklearn/keras python监督学习典型的三部曲1234567train_x, train_y, test_x, text_y = getData()model = somemodel()#选择一种模型model.fit(train_x, train_y)predictions = model.predict(test_x)score = score_function(test_y, predictions) 交互pygame网络Selenium]]></content>
      <tags>
        <tag>concept</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python多线程/多进程]]></title>
    <url>%2F2018%2F08%2F07%2Fpython-concurrent%2F</url>
    <content type="text"><![CDATA[全局解释器锁GIL1，GIL是一个全局排他锁，同一时刻只有一个线程在运行，就类似于Python是个单线程的程序2，multiprocessing库很大程度上是为了弥补GIL低效的缺陷，它完整复制了一套thread所提供的接口方便迁移，唯一不同的是它使用了多进程而不是多线程，所以每个进程有自己的独立的GIL，因此不会出现进程间的GIL争抢3，多进程的fork操作，调用一次返回两次，操作系统会自动把当前进程（称为父进程）复制了一份（作为子进程），然后分别在父进程和子进程内返回。子进程永远返回0，而父进程返回子进程的ID。子进程只需要调用getppid()就可以拿到父进程的ID12345678import osprint('Process (%s) start...' % os.getpid())pid = os.fork()if pid == 0: print("Child Process &#123;0&#125;, Parent Process &#123;1&#125;".format(os.getpid(), os.getppid()))else: print("Parent Process is me &#123;0&#125;, my child process is &#123;1&#125;".format(os.getpid(),pid)) multiprocessing1234567891011from multiprocessing import Processimport timedef f(n): time.sleep(1) print n*nif __name__ == "__main__": for i in range(10): p = Process(target = f, args = [i,]) p.start() 进程间通信Queue1，Queue是多进程安全的队列，可以实现多进程之间的数据传递2，Queue.qsize() 返回队列的大小 Queue.empty() 如果队列为空，返回True,反之False Queue.full() 如果队列满了，返回True,反之False Queue.get([block[, timeout]]) 获取队列，timeout等待时间 Queue.get_nowait() 相当Queue.get(False) 非阻塞 Queue.put(item) 写入队列，timeout等待时间 Queue.put_nowait(item) 相当Queue.put(item, False)1234567891011121314151617181920212223from multiprocessing import Process, Queueimport timedef write(q): for i in ['A','B','C','D','E']: print('Put &#123;0&#125; to queue'.format(i)) q.put(i) time.sleep(0.5)def read(q): while True: v = q.get(True) print('Get &#123;0&#125; from queue'.format(v))if __name__ == '__main__': q = Queue() pw = Process(target = write, args=(q,)) pr = Process(target = read, args=(q,)) pw.start() pr.start() pw.join() pr.join() pr.terminate() 进程池Pool1，用于批量创建子进程，可以灵活控制子进程的数量123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from multiprocessing import Poolimport timedef f(x): print x*x time.sleep(2) return x*xif __name__ == '__main__': '''定义启动进程的数量''' pool = Pool(processes = 5) res_list = [] for i in range(10): '''以异步并行的方式启动进程，如果要同步等待的方式，可以在每次启动进程之后调用res.get()方法，也可以是用Pool.apply''' res = pool.apply_async(f, [i,]) print('-----------:',i) res_list.append(res) pool.close() pool.join() #强制等待所有进程运行完毕 for r in res_list: print("result: ",(r.get(timeout = 5)))#结果'''ubuntu@bosch-shiny1:~$ python multiPython.py -----------: 00-----------: 1-----------: 2-----------: 3-----------: 4-----------: 5-----------: 6-----------: 7-----------: 8-----------: 9149162536496481result: 0result: 1result: 4result: 9result: 16result: 25result: 36result: 49result: 64result: 81''' 多进程与多线程对比1，主要区别就在于线程之间可以共享进程的资源，而进程是独立的2，由于进程之前是互相独立的，所以结果会是1234567891011121314151617181920212223from multiprocessing import Processimport threadingimport timelock = threading.Lock()def run(info_list,n): lock.acquire() info_list.append(n) lock.release() print("&#123;0&#125;\n".format(info_list))if __name__ == '__main__': info = [] for i in range(10): p = Process(target=run, args=[info,i]) p.start() p.join() time.sleep(1) print('------------------------threading--------------------') for i in range(10): p = threading.Thread(target=run, args=[info,i]) p.start() p.join() 结果为12345678910111213141516171819202122232425262728293031323334353637383940[0][1][2][3][4][5][6][7][8][9]------------------------threading--------------------[0][0, 1][0, 1, 2][0, 1, 2, 3][0, 1, 2, 3, 4][0, 1, 2, 3, 4, 5][0, 1, 2, 3, 4, 5, 6][0, 1, 2, 3, 4, 5, 6, 7][0, 1, 2, 3, 4, 5, 6, 7, 8][0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 如果想让multiprocessing也像多进程一样，可以用Queue12345678910111213141516171819202122232425262728from multiprocessing import Process,Queueimport timeimport threadinglock = threading.Lock()def run(queue,info_list,n): lock.acquire() while not queue.empty(): value = queue.get(True) info_list.append(value) lock.release() if len(info_list) &gt; 0: print('&#123;0&#125;\n'.format(info_list))def foo(q,n): q.put(n)if __name__ == '__main__': info = [] q = Queue() for i in range(10): for j in range(1,i+1): q.put(j) p = Process(target=run,args=[q,info,i]) p.start() p.join() 函数式编程1，有并发的思想，三大特性：immutable data不可变数据，first class functions函数像变量一样使用,尾递归优化：每次递归都重用stack2，好处：并行，惰性求值（在使用的时候再求值），确定性3，技术：map&amp;reduce,pipeline,recursing递归,currying归一化,higher order function高阶函数12345678910def inc(x): def incx(y): return x+y return incxinc2 = inc(2)inc5 = inc(5)print(inc2(5)) #输出7print(inc5(5)) #输出10 4，lambda快速定义单行的最小函数，即inline的匿名函数123g = lambda x: x*2print(g(3)) # 6print(lambda x: x*2)(4) # 8 5，map，filter，reduce map(function, sequence)：对sequence中的item依次执行function(item),执行结果组成一个List返回123456# 对于这个函数for n in ["qi", "yue", "July"]: print(len(n))#可以写成name_len = map(len, ["qi", "yue", "July"])print(name_len) filter(function, sequence):对sequence中的item一次执行function(item),将执行结果为True的item组成一个List/String/Tuple(取决于sequence的类型)返回 123number_list = range(-5,5)less_than_zero = list(filter(lambda x: x&lt;0, number_list))print(less_than_zero) reduce(function, sequence, starting_value):对sequence中的item顺序迭代调用function,如果有starting_value,还可以作为初始值调用 1234def add(x,y): return x+yprint reduce(add,range(1,5))# 10print reduce(add,range(1,5),10) # 20 例：计算数组中的平均数 1234num = [2, -5, 9, 7, -2, 5, 3, 1, 0, -3, 8]true_list = list(filter(lambda x: x&gt;0, num))total = reduce(lambda x,y:x+y,true_list)average = total/len(true_list) Hadoop &amp; Spark1，核心设计就是MapReduce和HDFS(Hadoop Distributed File System2，mrjob是在Hadoop Streaming的命令行上面包了一层，有了统一的Python界面，无序直接调用复杂的Hadoop Streaming命令3，Spark是基于map reduce算法实现的分布式计算框架，其中间输出和结果可是直接保存在内存中，不再需要读写HDFS4，Spark能更好地用于数据挖掘与机器学习等需要迭代的map,reduce的算法5，Spark的核心为弹性分布式数据集RDD(Resilient Distributed Datasets),它是一个集群节点上不可变、已分区的对象，可以序列化，可以控制存储级别（内存、磁盘等）来进行重用6，用PySpark实现WordCount123456789101112131415import sysfrom operator import addfrom pyspark import SparkContextsc = SparkContext()lines = sc.textFile("stormofswords.csv")counts = lines.flatMap(lambda x: x.split(','))\ .map(lambda x: (x, 1)) .reduceByKey(add)output = counts.collect() #这个时候才开始计算output = filter(lambda x:not x[0].isnumeric(), sorted(output, key=lambda x:x[1], reverse=True))for (word,count) in output[:10]: print("&#123;0&#125;:&#123;1&#125;".format(word, count))sc.stop()]]></content>
      <tags>
        <tag>concept</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-file]]></title>
    <url>%2F2018%2F08%2F03%2Fpython-file%2F</url>
    <content type="text"><![CDATA[文件读写操作读文件方法一12345678910111213# 默认是只读file1 = open("test.txt")# w是全部重写，a是append到最后file2 = open("output.txt","w")while True: line = file1.readline() file2.write('"' + line + '"' + ".") if not line: breakfile1.close()file2.close() 读文件有3种方法：1，read()将文本文件所有行读到一个字符串中2，readline()是一行行读3，readlines()是将文本文件中所有行读到一个List中，文本文件每一行是list的一个元素。 方法二文件迭代器1234file2 = open("output.txt","w")for line in open("test.txt"): file2.write('"' + line + '"' + ".")file2.close() 方法三文件上下文管理器12345#用with.open自带关闭文本的功能with open('somefile.txt','r') as f: data = f.read() for line in f: #处理每一行 二进制文件读写python默认读取的都是文本文件。要是想要读取二进制文件，需要把刚刚的”r”/“w”改成”rb” 任何非标准的文本文件（Python2-ASCII, Python3-unicode）你就需要用二进制读入这个文件，然后再有.decode(&#39;...&#39;)的方法来解码这个二进制文件12f = open('ABC.jpg','rb')u = f.read().decode('ABC')]]></content>
      <tags>
        <tag>concept</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-oop]]></title>
    <url>%2F2018%2F08%2F02%2Fpython-oop%2F</url>
    <content type="text"><![CDATA[创建类1，类中函数的第一个参数必须是self,它是为了指代它所存在的类2，构造函数用init表示123456789101112131415161718192021#创建类class Foo: name = 'Jan' #类里面的函数,类中第一个参数必须是self，指代本类的东西 def bar(self): pass def hello(self, name): print('self name &#123;0&#125;'.format(self.name)) #指Jan print('I am &#123;0&#125;'.format(name)) def __init__(self): #其职责就是在模型创建初期完成一些动作 self.name = "Jan2"obj=Foo()obj.bar()obj.hello('july')obj1 = Foo()obj2 = Foo() 访问限制1，直接在构造函数中用self.xx赋值会导致xx外界也能访问2，self.__name = name,这样写就是告诉python __name不能被外界访问3，如果既要保证安全，又要能被外部更改呢？用getter+setter4，python中，如果变量名类似__x__,以双下划线开头和结尾的，是特殊变量，特殊变量可以直接访问，不是private变量5，如果变量名是以一个下划线开头的_x，这样的实例变量外部是可以访问的，但是按照约定俗称的规定，这类变量虽然可以访问，但是请视为私有变量，不要随意访问12345678910111213141516171819202122class Student: def __init__(self,name,age): self.name = name #用self赋值在类中别的方法也能直接访问的到 self.age = age self.__name = name self.__age = age def detail(self): print(self.name) print(self.age) print(self.__name) print(self.__age) def get_name(self): return self.__name def set_name(self,name): self.__name = nameLiLei = Student('LiLei',12)LiLei.age = 20 #外界可以更改，访问ageLilei.__age = 20 #不能被更改 继承1234567891011121314151617class PrimaryStudent(Student): def lol(self): print("lalalala")class CollegeStudent(Student): #这里改写了父类的构造函数 def __init__(self,name,age,gender): self.__name = name self.__age = age self.__gender = gender def gender_detail(self): print(self.__gender)obj1 = PrimaryStudent('向往',7)obj1.lol()obj1.detail()#继承爸爸的方法 python 类属性和实例属性1234567891011121314class A(): a = 10# scenario1obj1 = A()obj2 = A()print(obj1.a,obj2.a,A.a)# scenario2obj1.a += 2print(obj1.a,obj2.a,A.a)# scenario3A.a += 3print(obj1.a,obj2.a,A.a) 情形1的结果是：10 10 10；情形2的结果是：12 10 10；情形3的结果是：12 13 13； 为什么呢？在python中， A属于类对象，obj1属于实例对象，从对象的角度上来说，A与obj1是两个无关的对象，但是，Python通过下面的查找树建立了对象A与实例对象obj1,obj2之间的关系 12345 A |---------| |obj1 obj2 当调用A.a的时候，直接从A获取属性a在scenario1中调用obj1.a,python按照从obj1到A的顺序自下到上查找属性a注意的是在这个时候，obj1是没有属性a的，所以python到Class A中找，找到并返回 在scenario2中obj1.a += 2包含了属性获取以及属性设置两个操作属性的获取和上面一样，按照查找规则进行，即这个时候找到了类A的属性a但是当进行属性的设置时，obj1这个实例对象没有属性a，因此会自身动态添加一个属性a自此，类A和实例obj1都有自己的一个属性 那么，在scenario3中，再次调用obj1.a的时候，按照就近原则，找到的时实例对象的a，所以返回12，对于obj2.a由于一开始没有自己的实例对象a,所以返回的时类A的a，也就是13 可以验证，如果手动删除obj1.a，那么当再次调用obj1.a的时候，返回的会是1312del obj1.aprint(obj1.a) python 装饰器1，主要用于AOP2，简单版，等同于use_logging(foo())123456789101112def use_logging(func): def wrapper(): logging.warn("%s is running" % func.__name__) return func() return wrapper@use_loggingdef foo(): print("i am foo")foo() 3，带业务函数参数*args,**kwargs1234def wrapper(*args, **kwargs): logging.warn("%s is running" % func.__name__) return func(*args, **kwargs) return wrapper 4，装饰器本身带参数这种写法本质上就是把原本real_decorator这个装饰器再在外面包一层装饰器12345678910111213141516def makeHtmlTag(tag,*args,**kwds): def real_decorator(fn): css_class = " class '&#123;0&#125;'".format(kwds["css_class"]) if "css_class" in kwds else "" def wrapped(*args, **kwds): return "&lt;"+tag+css_class+"&gt;"+fn(*args,**kwds)+"&lt;/"+tag+"&gt;" return wrapped return real_decorator@makeHtmlTag(tag="b", css_class="bold_css")@makeHtmlTag(tag="i", css_class="italic_css")def hello(*s,**kwds): return "hello world!&#123;0&#125;&#123;1&#125;".format(s,kwds)print(hello('spencer','shao',name="ss",surname="shao"))#结果为：&lt;b class 'bold_css'&gt;&lt;i class 'italic_css'&gt;hello world!('spencer', 'shao')&#123;'name': 'ss', 'surname': 'shao'&#125;&lt;/i&gt;&lt;/b&gt; 5，类装饰器注意，这里调用顺序会先是decorator的init函数， 12345678910111213141516171819202122232425262728class makeHtmlTagClass(object): def __init__(self, tag, css_class=""): print("inside makeHtmlTagDecorator.__init.__()") self._tag = tag self._css_class = " class '&#123;0&#125;'".format(css_class) if css_class != "" else "" def __call__(self, fn): def wrapped(*args, **kwargs): print("inside makeHtmlTagDecorator.__call__()") return "&lt;"+self._tag+self._css_class+"&gt;"+fn(*args,**kwargs)+"&lt;/"+self._tag+"&gt;" return wrapped@makeHtmlTagClass(tag="b", css_class="bold_css")@makeHtmlTagClass(tag="i", css_class="italic_css")def hello(name): return "Hello, &#123;&#125;".format(name)print("Finished decorating hello()")print(hello("Baby"))#输出结果顺序为：#inside makeHtmlTagDecorator.__init.__()#inside makeHtmlTagDecorator.__init.__()#Finished decorating hello()#inside makeHtmlTagDecorator.__call__()#inside makeHtmlTagDecorator.__call__()#&lt;b class 'bold_css'&gt;&lt;i class 'italic_css'&gt;Hello, Baby&lt;/i&gt;&lt;/b&gt; 6，装饰器副作用原本的函数变成了一个wrapper函数，所以会丢失原本函数的一些元信息，比方说name, __doc__之类这个时候可以用Python的functools1234567891011121314from functools import wrapsdef hello(fn): @wraps(fn) def wrapper(): print("Hi,&#123;0&#125;".format(fn.__name__)) fn() print("Bye,&#123;0&#125;".format(fn.__name__)) return wrapper@hellodef foo(): print("Foo")foo() slots1，可以限制class实例能够添加哪些属性2，__slots__只对当前类的实力起作用，对继承的子类不求作用 property类的特殊方法和定制str1，返回用户看到的字符串2，convert an object to a string3，与toString()十分类似，也可以override这个方法 123456789class MyClass: def __init__(self, name): self.name = name def __str__(self): return "Hello" + self.nameprint(MyClass('Tome')) # Hello Tome # 如果没有def __str__，则默认打印的是&lt;__main__.MyClass object at 0x109afb190&gt; str()与repr()1，Example of str()123s = 'Hello, Geeks.'print str(s)print str(2.0/11.0) output:12Hello, Geeks.0.181818181818 2，Example of repr()123s = 'Hello, Geeks.'print repr(s)print repr(2.0/11.0) output:12'Hello, Geeks.'0.18181818181818182 3，Difference: str() is used for creating output for end users/ repr() is mainly used for debugging and development repr() shows a representation that has all information about the object/ str() is sued to show a representation that is useful for printing the object ** Both of them can be overriden for any class and there are minor differences.If both are defined, function defined in str is used. iter1，如果一个类想要被用于for ... in循环，就必须实现一个__iter__()方法，该方法返回一个迭代对象，在def __iter__(self)里实力本身就是迭代对象，所以返回自己self即可，主要是在__next__里面写逻辑，知道遇到StopIteration错误时退出循环 123456789101112131415class Fib100: def __init__(self): self._1, self._2 = 0, 1 def __iter__(self): return self def __next__(self): self._1, self._2 = self._2, self._1 + self._2 if self._1 &gt; 100: raise StopIteration() return self._1for i in Fib100(): print(i) getitem1，如果想实现下标访问，就需要实现__getitem__123456789class Fib(object): def __getitem__(self, n): a, b = 1, 1 for x in range(n): a, b = b, a + b return af = Fib()f[0] call123456789class MyClass: def __call__(self): print("U can call cls() directly")cls = MyClass()cls()print(callable(cls))print(callable(max)) 元类MetaClass1，python是动态语言，是在运行时编译的2，用type动态生成一个类,第二个参数是继承自什么，一定要显式写成元组类型12345678910def init(self, name): self.name = namedef say_hello(self): print('Hello &#123;0&#125;'.format(self.name))Hello = type('Hello',(object, ), dict(__init__ = init, hello = say_hello))h = Hello('Tom')h.hello() 3，metaclass就是为了控制类的创建过程，就是告诉用户我这个class有哪些方法，存在attrs的表里面，attrs就是函数和方法的一个表123456789101112131415161718def add(self, value): self.append(value)class ListMetaClass(type): def __new__(cls, name, bases, attrs): attrs['add'] = add attrs['name'] = 'Jerry' return type.__new__(cls, name, bases, attrs)class MyList(list, metaclass = ListMetaClass): passmli = MyList()mli.add(1)mli.add(2)print(mli.name) # Jerryprint(mli) # [1,2]]]></content>
      <tags>
        <tag>concept</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-basics]]></title>
    <url>%2F2018%2F07%2F31%2Fpython-basics%2F</url>
    <content type="text"><![CDATA[PYTHON 3.6 字符串换行1，字符串中末尾加”\”最终会打印出一行2，字符串换行方法一加\n3，字符串换行方法二用多行写法123456789101112131415str = 'abcd' \ 'efgh'# 结果是abcdefghprint(str)#结果是Hello#worldstr = 'Hello\nworld!'print(str)#结果是Hello#worldstr = """Helloworld!""" 单引号与双引号1，单引号里可以直接写双引号2，双引号里可以直接写单引号3，单/双引号里面要单/双引号，则需要转义 12345678# abc"123"efgprint('abc"123"efg')# abc'123'efgprint("abc'123'efg")# abc'123'efgprint('abc\'123\'efg')# abc"123"efgprint("abc\"123\"efg") 常见字符串处理1，取出空格及特殊符号strip,lstrip,rstrip2，复制字符串：str1 = str23，连接字符串 str2 += str1 new_str = str2 + str14，查找字符串：pos = str1.index(str2)5，比较字符串：str1 == str2/str1 &lt; str26，字符串长度：len(str)7，大小写转换： u_str = str.upper() l_str = str.lower()8，首字母大写：str.capitalize();string.capword(str)9，分割与合并字符串：split,splitlines,join10，类型转换：int，float转换11，格式化字符串12，不能修改字符串1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import strings = 'abc'#报错s[0] = 'd'#去除空格 s = ' abcd efg ' print(s.strip()) #返回的是新的字符串 print(s.lstrip()) print(s.rstrip())# 字符串的连接s1 = 'abc's2 = 'def'print(s1 + "\n" + s2)# 位置比较s_1 = 'abcdefg's_2 = 'abdeffxx'print(s_1.index('bcd')) # 1print(s_2.index('bcd')) # Exception# 空字符串 不能写成 == False，不等于None# 空字符串在内存中还是被分配了对象的# s = ''if not s: print('Empty')# 字符串的分割和连接s = 'abc,def,ghi'splitted = s.split(',')print(typeof(splitted)) #&lt;class 'list'&gt;print(splitted)#['abc','def','ghi']s="""abcdefghi"""s_1 = s.splitted('\n')s_2 = s.splitlines()print(s_1)print(s_2)# 字符串的连接s = ['abc','def','ghi']print(''.join(s))print('-'.join(s)) # abc-def-ghi#常用判断print('1234abcd'.isalnum())print('\t12ab'.isalnum())#Falseprint('abcd'.isalpha())print('12345'.isdigit())print(' '.isspace())#数字到字符串print(str(5))print(str(5.))print(str(5.12345))#字符串到数字print(int('1234'))print(float('1234.56'))print((int('ffff',16)) #16进制的ffff转成10进制 条件判断12345678910111213# None的判断x = Noneif not x: print('None')else: print('Not None')if x is None: print('None')# forfor i in range(start,end,step): print(i) AND/OR1，AND/OR不一定只会返回True/False2，AND return the first Falsey value if there are any, else return the last value in the expression3，OR return the first Truthy value if there are any, else return the last value in the expression 123456[] and [] + [1,2] # returns []#Spotted,[] and [] + [1,2] is actually this: [] and ([] + [1,2]),你必须把后面的+[1,2]与前面的[]看作是一个整体[] + [1,2] # returns [1,2]10 or 7 - 2 # returns 10,同理，10 or (7 - 2)要看成这种形式 循环for/elsefor loop也有一个elseelse 是在loop正常结束后执行的，也就是说这个loop没有break 下面这个是一个基本的12345678for item in container: if search_something(item): #Found it! process(item) break else: #Didn't find anything not_found_in_container() 函数1234567891011121314151617181920212223242526272829303132333435363738394041#默认参数def func(x,y = 500): return x+yprint(func(100)) # 600def func(p): print('x=',p['x']) print('y=',p['y'])print(func(&#123;'x':100,'y':200&#125;))#可变参数，*告诉pytnhon后面都放到这个numbers数组#这样写有一个问题，你传进去的可变tuple每个元素是没有名字的，你除非知道他们的索引才能用def func(name,*numbers): print(numbers[0]) print(numbers[3]) print(type(numbers)) #Tuple# tuple = 只读数组func('tom',1,2,3,4,"Hello")#可变参数方法二, **代表key/values的字典def func(name,**kvs): print(type(kvs)) #&lt;class 'dict'&gt; print(kvs)#&#123;'uk':'London','china':'Beijing'&#125;func('Tom',china="Beijing",uk="London")def func(a,b,c,*,china,uk): print(china,uk)func(1,2,3,china='BJ',uk='LD')# 函数可以作为参数def sum(x,y,p=None): s = x+y if p: p(s) return ssum(100,200,print) 变量经常会碰到这样的错误：local variable ‘a’ referenced before assignment 12345a = 3def func(): print(a) a = a+1 #这一句会报错func() a=3定义了全局变量a，作用域从定义处到代码结束，在a=3以下的函数中是可以引用全局变量a的，但是如果要修改函数中与全局变量同名的变量，在函数中的该变量就会变成局部变量，在修改之前对该变量的引用就会引发为定义的错误,所以，哪个函数需要修改全局变量，就需要在这个函数中声明一下，但是有一个函数不需要声明，就是主函数 123456789101112a = 3def func(): global a print(a) a = a+1 #这一句会报错func()if __name__ == &quot;__main__&quot;: print (a) # 2 a = a + 1 Fuc() print (a) # 3 ##**练习*** 1，求100以内的素数12345678910111213#找素数,1不是素数，最小的质数/素数为2#素数的概念，除了1和它本身外，不能被其他自然数整除def findPrimeNumber(num): for i in range(1,num+1): if i &gt; 1: for j in range(2,i): if i%j == 0: break else: print(i)findPrimeNumber(100) 2，冒泡排序1234567891011#冒泡排序def bubbleSort(array): for i in range(len(array)-1,0,-1): for j in range(i): if array[j] &gt; array[j+1]: temp = array[j] array[j] = array[j+1] array[j+1] = temp print(array)bubbleSort([54,26,100,17,77]) 容器1，list列表，索引从0开始，列表的数据项不需要具有相同的类型2，tuple元组，只读列表3，dist字典4，set集合，是一个无序不重复的数组 5，not XX 和 is None不是一回事，not XX代表其还是在内存分配空间了的6，切片，切出一个子数组7，生成器，只有用到的时候才去计算，不用的时候不算,用next/for来循环,非常省内存8，迭代器，如果是Iterable,则可以用for来循环，如果是Iterator则说明是生成器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#list/tuple基本操作li = [1,2,3,'tete',[1,2,3],&#123;1:'one',2:'two'&#125;]print(type(li))# class list# 元素访问print(li[0])#倒数第一个元素print(li[-1])# 查找元素位置print(li.index('tete')) #3print(li.index([1,2,3])) #4print(li.index(-1)) # error# 添加元素l_a = [1,2]l_a.append(4)l_a.append(5)#如果想要一次性加多个元素进去，就需要用extend,否则如果用append，会把其作为一个list，添加到原list中l_b = [6,7,8]l_a.extend(l_b)# 删除元素del(li[-1]) # del(list[index])# 判断容器是否为空l_a = []if not l_a: print('Empty') # print thisif l_a is None: print('None')# 遍历for i in li: print(i)for i in range(len(li)): print(li[i])# 元组t = (1,2,3,'456')t[0]='a' # error,不可以修改# 字典d = &#123;'a':1,'b':2,1:'one',2:'two'&#125;print(d[1]) #根据key来做访问# 判断元素是否存在，是判断key是否存在print('c' in d) # falseprint(1 in d) # true# 添加# 删除del(d[2])# 遍历for key in d: print(d[key])for key, value in d.items(): print(key,value)keys = d.keys()print(keys)# sets_a = set([1,2,2,3,4,5,6])s_b = set([4,5,6,7,8])print(s_a)# &#123;1,2,3,4,5,6&#125;# 判断元素是否存在print(5 in s_a)# 并集print(s_a | s_b) #&#123;1，2，3，4，5，6，7，8&#125;print(s_a.union(s_b))# 交集print(s_a &amp; s_b)print(s_a.intersection(s_b)) #生成一个新的set &#123;4，5，6&#125;# 差集(a - a&amp;b )pprint(s_a - s_b)print(s_a.difference(s_b)) #&#123;1,2,3&#125;# 对称差(A|B) - (A&amp;B)，把两个集合相同的元素去除print(s_a ^ s_b)print(s_a.symmetric_diff(s_b)) #&#123;1,2,3,7,8&#125;# 添加s_a.add('x')s_a.update([4,5,60,70])# 删除，因为set没有索引，要直接删值s_a.remove(70)# 遍历for i in s_a: print i# 切片[start:end:step] &gt;= start * &lt; endli = list(range(10)) #[0,1,2,3,4,5,6,7,8,9]print(li[2:5]) # [3,4,5]print(li[:4]) # [0,1,2,3]print(li[0:10:3])#[0,3,6,9]print(li[5:-2])#[5,6,7]print(li[9:0:-1])#[9,8,7,6,5,4,3,2,1]print(li[9::-1])#[9,8,7,6,5,4,3,2,1,0]# 列表推导#生成10个偶数li = [i*2 for i in range(10)]#二维数组浅拷贝li_2d = [[0]*3]*3print(li_2d)li_2d[0][0] = 100print(li_2d)#这样写会每个元素的首元素变成100，因为*3这样写是浅拷贝，每个引用的是同一个空间#二维数组深拷贝li_2d = [[0]*3 for i in range(3)]li_2d[0][0] = 100s = &#123;x for x in range(10) if x%2 == 0&#125;print(s) #s=setd = &#123;x:x%2 == 0 for x in range(10)&#125;print(d)#d=dict# 生成器square_generator = (x*x for x in range(50000))print(next(square_generator))for i in range(10): print(next(square_generator))# 迭代器from collections import Iterablefrom collections import Iteratorprint(isinstance([1,2,3],Iterable)) #trueprint(isinstance([1,2,3],Iterator)) #falseprint(isinstance(&#123;&#125;,Iterable))#true# ##**练习***123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#任意给定一个值，在一个数组中找到两个数，相加=给定值，返回这两个数的索引，如果没有，返回-1def find_two_sums(ls, target): for i in range(len(ls) - 1): for j in range(i+1, len(ls)): if ls[i] + ls[j] == target: return i, j return -1, -1print(find_two_sums([1, 3, 2, 6, 18, 4, 2], 3))#螺旋矩阵，给定一个m*n要素的矩阵，按照螺旋顺序，返回该矩阵的所有要素#方法一，我自己写的一个笨方法，只用到上面学的内容，应该是符合所有常识人理解matrix2 = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]def myspiralmatrix(matrix): if len(matrix) &lt; 1: return [] #宽 m = len(matrix[0]) #长 n = len(matrix) matrix3 = matrix ls = [] #以横着读一批+竖着第一批作为一批，最多只有可能走m/n遍就能遍历完 if m &gt;= n: t = n else: t = m for tt in range(1, t + 1): # 如果是奇数次遍历，那么就是顺时针读 if tt % 2 != 0: #横：读出matrix第一个元素的所有值 ls.extend(matrix3[0][:m]) #竖：除了matrix第一个元素之外，遍历剩下n-1个元素，只读出来第m-1个 for k in range(1, n): ls.append(matrix3[k][m - 1]) #重置数组，将下回要遍历的数组宽，长都-1，重新生成新的数组 m = m - 1 n = n - 1 tmp = matrix3 matrix3 = [] for em in range(1, n + 1): matrix3.append(tmp[em][:m]) # 如果是偶数次遍历，那么就是逆时针读 else: # 逆序打印这个时候matrix的最后一行 ls.extend(matrix3[n - 1][m::-1]) # 逆序竖着打印除了最后一行元素之后的所有元素的第一个元素 for i in range(n - 1, 0, -1): ls.append(matrix3[i - 1][0]) #重置数组，将下回要遍历的数组宽，长都-1，重新生成数组 m = m - 1 n = n - 1 tmp = matrix3 matrix3 = [] for em in range(0, n): matrix3.append(tmp[em][1:]) return lsprint(mySpiralOrder(matrix2))#方法二，LeetCode上面某个大神的写法：# 这里第一个matrix and是为了保证当所有元素都pop掉后，会返回一个空matrix,不会再做后面的pop和递归操作# matrix.pop()的操作是直接改在matrix上的，所以后面的递归是基于新的matrix上面# 后面的递归spiralOrder([*zip(*matrix)][::-1])生成的是一个剔除原先第一行元素后逆序的matrixdef spiralOrder(matrix): return matrix and [*matrix.pop(0)] + spiralOrder([*zip(*matrix)][::-1])#用栈实现队列：支持push(element),pop()和top()方法。pop和top都应该返回第一个元素的值# 矩阵转换，给定矩阵A，令矩阵B里每个元素B[i][j]的值等于A[0][0]到A[i][j]子矩阵元素的和# 解： 除了第一行和第一列，其余B矩阵里面所有的元素都可以表示为# B[i][j] = B[i][j-1] + B[i-1][j] - B[i-1][j-1] + A[i][j]def matrixTransform(A): B = A for i in range(1,len(A[0])): B[0][i] += B[0][i-1] for i in range(1,len(A),1): B[i][0] += B[i-1][0] for i in range(1,len(A),1): for j in range(1, len(A[0]), 1): B[i][j] += B[i-1][j] + B[i][j-1] - B[i-1][j-1] return B 容器补充知识点1，*list的含义， * operator unpacks an argument list. It allows you to call a function with the list items as individual arguments. For instance, if sys.argv is [“./foo”, “bar”, “quux”], main(*sys.argv) = main(&quot;./foo&quot;,&quot;bar&quot;,&quot;quux&quot;)2，zip takes n number of iterables and returns list of tuples. ith element of the tuple is created using the ith element from each of the iterables.123456789101112list_a = [1, 2, 3]list_b = [4, 5, 6]zipped = zip(a, b) # Output: Zip Object. &lt;zip at 0x4c10a30&gt;len(zipped) # TypeError: object of type 'zip' has no len()zipped[0] # TypeError: 'zip' object is not subscriptablelist_c = list(zipped) #Output: [(1, 4), (2, 5), (3, 6)]list_d = list(zipped) # Output []... Output is empty list becuase by the above statement zip got exhausted. 123456matrix2 = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]print(*matrix2) # [1, 2, 3, 4] [5, 6, 7, 8] [9, 10, 11, 12] 这里不是一个list，是三个list对象print([*zip(matrix2)]) #[([1, 2, 3, 4],), ([5, 6, 7, 8],), ([9, 10, 11, 12],)]print([*zip(list(matrix2))]) #[([1, 2, 3, 4],), ([5, 6, 7, 8],), ([9, 10, 11, 12],)] 与上面相同，因为list(matrix2)还是只有一个对象print([zip(*matrix2)]) # [&lt;zip object at 0x00935350&gt;]print([*zip(*matrix2)]) #[(1, 5, 9), (2, 6, 10), (3, 7, 11), (4, 8, 12)]]]></content>
      <tags>
        <tag>concept</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[net-design-pattern]]></title>
    <url>%2F2018%2F07%2F26%2Fnet-design-pattern%2F</url>
    <content type="text"><![CDATA[依赖倒置原则：怎么抽象1，上层和下层中间应该通过一个抽象层进行工作，抽象是稳定的，实现是多变的！所以定义抽象要谨慎2，每一层模块应该都要有抽象，有一个类cls,就要有一个ICls3，调用者左边为抽象，右边为具体实现 12345678910111213141516171819202122232425262728293031323334//caller&#123; AbstractPhone phone = new iPhone(); phone.Call();&#125;&#123; AbstractPhone phone = new Lumia(); phone.Call();&#125;//中间层，就相当于定义的一个规范public abstract class AbstractPhone&#123; public int Id &#123;get;set;&#125; public string Branch &#123;get;set;&#125; public abstract void Call();&#125;//下层实现层public class iPhone:AbstractPhone&#123; public override void Call() &#123; Console.WriteLine(&quot;This is iPhone calling!&quot;) &#125;&#125;public class Lumia:AbstractPhone&#123; public override void Call() &#123; Console.WriteLine(&quot;This is Lumia calling!&quot;); &#125;&#125; 其实中间层也可以写成一个泛型1234public void Call&lt;T&gt;(T phone) where T : AbstractPhone&#123; Console.WriteLine(&quot;This is &#123;0&#125; calling&quot;, phone.Name);&#125; 接口隔离原则划分接口的时候，首先不能大而全，也不能太碎，要按照一定的规则进行分组 设计模式-创建型设计模式，关注对象的创建单例模式，就是保证类型只有一个实例，减少初始化的消耗局限：1，实例会常驻内存2，实例中的变量，在多线程的情况下会被影响 使用场景：数据库连接池 方法一1，构造函数私有化，保证不会被外部创建2，对外提供一个公开方法提供这个对象3，实例定义成一个静态变量，保证内存中就只有一个4，注意了，如果class Singleton变成class Singleton,就无法保证实例是单例的，因为解释器会在编译的时候动态生成类型1234567891011121314151617public class Singleton&#123; private Singleton() &#123; &#125; //volatile保证多线程的时候值不会被多次修改 private static volatile Singleton _singleton = null; private static object Singleton_Lock = new object(); public static Singleton CreateInstance() &#123; if(_singleton == null) _singleton = new Singleton(); return _singleton; &#125;&#125; 如果多线程同时调用上面的CreateInstance，就无法保证只构造一次(假设一个构造函数要构造40s)，所以需要加一层Lock 但是只加一次lock也不行，因为如果第二轮开5个线程让构造Singleton,则会发现第二轮的也在等待锁，而这个时候明明已经Singleton实例化好了的 所以在lock外面会再加上一层if判断 经典的双if-lock:123456789101112131415public static Singleton CreateInstance()&#123; if(_singleton is null)//保证对象初始化之后，不会再去等待锁 &#123; lock(Singleton_Lock)//保证只有一个线程进去 &#123; Thread.Sleep(1000); Console.WriteLine(&quot;这里等待了1s的锁&quot;); if(_singleton == null)//保证只会被实例化一次 _singleton = new Singleton(); &#125; &#125; return _singleton;&#125; 方法二1，通过静态构造函数来返回实例,是由CLR来保证程序第一次使用这个类型前被调用且只调用一次123456789public class SingletonSecond&#123; private static volatile SingletonSecond _singletonSecond = null; static SingletonSecond() &#123; _singletonSecond = new SingletonSecond(); Console.WriteLine(&quot;SingletonSecond starts&quot;). &#125;&#125; 方法三1，使用静态字段，在第一次使用这个类之前，也是由CLR保证的，初始化且只初始化一次1234567891011121314public class SingletonThird&#123; private SingletonThird() &#123; &#125; private static SingletonThird _singletonThird = new SingletonThird(); public static SingletonThird CreateInstance() &#123; return _singletonThird; &#125;&#125; 原型模式,解决对象重复创建的问题局限：1，常驻内存2，多线程的话，会在内存中创建多个实例，即使这个实例跟第一次创建的实例是一样的 1，通过MemberwiseClone来clone新对象，避免重复创建对象2，每次Clone的时候都是以第一次SingletonSecond静态构造函数构造的来copy，所以每次返回的是新的对象12345public static SingletonSecond CreateInstancePrototype()&#123; SingletonSecond sp = (SingletonSecond)_singletonPrototype.MemberwiseClone(); return sp;&#125; 三大工厂+建造者模式简单工厂局限：1，细节没有消失，只是转移，并且矛盾都集中在了一个地方1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; //不好，左右两边都是具体实现 Human human = new Human(); player.PlayWar3(human);&#125;&#123; //好，左边是抽象，右边是细节 IRace human = new Human(); player.PlayWar3(human);&#125;&#123; //如何把右边也替换掉？简单工厂模式,就是帮忙完成对象的创建 IRace human = ObjectFactory.CreateRace(RaceType.Human); player.PlayWar3(human);&#125;public static IRace CreateRace(RaceType raceType)&#123; IRace iRace = null; switch(raceType) &#123; case RaceType.Human: iRace = new Human(); break; case RaceType.Undead: iRace = new Undead(); break; default: throw new Exception(&quot;Wrong race!&quot;); &#125; return iRace;&#125;//简单工厂的升级，用反射//这样写程序里面完全没有细节，细节都在config文件里面private static string IRaceTypeConfigReflection = ConfigurationManager.AppSettings[&quot;IRaceTypeConfigReflection&quot;];private static string DllName = IRaceTypeConfigReflection.Split(&apos;,&apos;)[1];private static string TypeName = IRaceTypeConfigReflection.Split(&apos;,&apos;)[0];///IOC的雏形public static IRace CreateRaceConfigReflection()&#123; Assembly assembly = Assembly.Load(DllName); Type type = assembly.GetType(TypeName); IRace iRace = Activator.CreateInstance(type) as IRace; return iRace;&#125; 工厂方法1，将职责单一化，一个工厂只负责一种实例的创建2，创建的工厂作为一个中间层，把细节包了一层3，这样写方便扩展,可以增加新的行为12345678910111213141516171819202122&#123; IFactory factory = new HumanFactory(); //IFactory factory = new HumanFactoryAdvanced(); IRace race = factory.CreateRace();&#125;public class HumanFactory: IFactory&#123; public virtual IRace CreateRace() &#123; return new Human(); &#125;&#125;//这样写方便扩展,可以增加新的行为public class HumanFactoryAdvanced:HumanFactory&#123; public override IRace CreateRace() &#123; Console.WriteLine(&quot;This is an extension.&quot;); return new Human(); &#125;&#125; 抽象工厂1，从外表来说是一个工厂去创建多个对象2，适用于工厂里面的对象都紧密相连123456789101112131415161718192021222324252627282930public class HumanFactory:FactoryAbstract&#123; public override IRace CreateRace() &#123; return new Human(); &#125; public override IArmy CreateArmy() &#123; return new HumanArmy(); &#125; public override IHero CreateHero() &#123; return new HumanHero(); &#125;&#125;public abstract class FactoryAbstract&#123; public abstract IRace CreateRace(); public abstract IArmy CreateArmy(); public abstract IHero CreateHero();&#125;//caller&#123; FactoryAbstract humanFactory = new HumanFactory(); IRace race = humanFactory.CreateRace(); IArmy army = humanFactory.CreateArmy(); IHero hero = humanFactory.CreateHero();&#125; 经验之谈：在创建一个对象的时候，尽量不要直接去创建这个对象，而是通过一个中间层，这样细节的变化只会波及到工厂，只改工厂的就好，不会波及到上层 设计模式-结构型设计模式：关注类与类之间的关系纵向可以：继承–实现横向可以：聚合，组合，关联，依赖（是指在方法里用了别的类）核心：组合优于继承 适配器模式Adapter是在项目重构升级的时候会用，之前的方法已经都稳固了，但是这个时候想要用第三方的方法，就把第三方的方法与我们的方法适配一下 比方说我们之前定义了一个IHelper,里面定义了增删改查四个方法，并且已经有了MySqlHelper,OracleHelper 这个时候我们想要用一个第三方软件提供的RedisUtility,这里面也定义了自己增删改查方法，但是第三方是不可能继承于我们的类IHelper的，这个时候我们就需要写一个适配方法 方法一：纵向问题：侵入性很强因为通过了继承，我多出了很多功能，我其实只需要IHelper的增删改查就好，但是这个时候我还拥有了RedisUtility里面的AddRedis之类的方法。并且如果RedisUtility什么时候也增加了Add方法，那么我们现在的方法就要改1234567891011121314151617181920212223242526public class RedisHelperClass: RedisUtility, IHelper&#123; public void Add&lt;T&gt;() &#123; base.AddRedis&lt;T&gt;(); &#125; public void Delete&lt;T&gt;() &#123; base.DeleteRedis&lt;T&gt;(); &#125; public void Update&lt;T&gt;() &#123; base.UpdateRedis&lt;T&gt;(); &#125; public void Query&lt;T&gt;() &#123; base.QueryRedis&lt;T&gt;(); &#125;&#125;//caller&#123; IHelper helper = new RedisHelperClass(); helper.Add&lt;Program&gt;();&#125; 方法二：组合另一种写法是组合，在类的内部内置了需要类的属性，字段 组合的写法就比较灵活，不仅类里面可以有redisHelper，如果将来想要有Cache也可以直接加上去 12345678910111213141516171819202122232425public class RedisHelperObject: IHelper&#123; private RedisUtility _redisHelper = null; public RedisHelperObject(RedisUtility redisHelper)//这里可能是一个抽象的接口注入进来 &#123; this._redisHelper = redisHelper; &#125; public RedisHelperObject() &#123; this._redisHelper = new RedisUtility(); &#125; public void Add&lt;T&gt;() &#123; this._redisHelper.AddRedis&lt;T&gt;(); &#125; public void Delete&lt;T&gt;() &#123; this._redisHelper.DeleteRedis&lt;T&gt;(); &#125; //...&#125; 代理模式1，有一个真实的做事情的类2，有一个接口3，有一个代理的类，这个类继承于接口，也有方法的实现，但是到真正的实现是调用真实类来实现4，代理只能传达原有逻辑，不能新增业务逻辑，就是包一层5，真正调用的时候不再调用RealSubject，而是调用ProxySubject6，这种模式可以让用户在真正使用的时候才去创建对象(DoSomething方法)。因为我在用的时候是调用的ProxySubject，这个构建不消耗资源1234567891011121314151617181920212223242526272829303132333435public class ProxySubject: ISubject&#123; //这个是单例代理 private static ISubject _iSubject = null; private void Init() &#123; _iSubject = new RealSubject(); &#125; //下面这个是缓存代理 private static bool _booleanResult = false; private static bool _isInit = false; private static Dictionary&lt;string,bool&gt; _cache=new Dictionary&lt;string,bool&gt;(); public bool GetSomething() &#123; if(!_isInit)//缓存 &#123; _booleanResult = _iSubject.GetSomething(); _isInit = true; &#125; return _booleanResult; &#125; //这个是延迟代理，延迟构建RealSubject public void DoSomething() &#123; if(_iSubject == null) &#123; this.Init(); &#125; _iSubject.DoSomething(); &#125;&#125; 装饰器模式1，声明一个你需要用的变量2，在构造函数中把你需要的变量初始化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public class BaseStudentDecorator: AbstractStudent&#123; //用的是组合的方式，通过构造函数初始化变量 private AbstractStudent _student = null; public BaseStudentDecorator(AbstractStudent student) &#123; this._student = student; &#125; public override void Study() &#123; this._student.Study(); &#125;&#125;public class StudentPayDecorator: BaseStudentDecorator&#123; public StudentPayDecorator(AbstractStudent student) :base(student) &#123; &#125; public override void Study() &#123; Console.WriteLine(&quot;Pay&quot;); base.Study(); &#125;&#125;//caller&#123; AbstractStudent student = new StudentVip() &#123; Id = 381, Name = &quot;Bird&quot; &#125;; //BaseStudentDecorator decorator = new BaseStudentDecorator(); //把左边BaseStudentDecorator换成AbstractDecorator //AbstractStudent decorator = new BaseStudentDecorator(); //decorator.Study(); student = new BaseStudentDecorator(student); student.Study();//输出的是vip学习 //StudentPayDecorator studentPayDecorator = new StudentPayDecorator(decorator); //AbstractStudent studentPayDecorator = new StudentPayDecorator(decorator); //studentPayDecorator.Study(); //也可以写成如下，这个时候的student为BaseStudentDecorator student = new StudentPayDecorator(student); student.Study();//输出先是pay，然后BaseStudentDecorator的Study,即输出vip学习 //所以之后如果你想给一个对象加一些行为，都可以像这样写 //AOP的雏形 student = new BaseStudentDecorator(student); student = new StudentRegDecorator(student); student = new StudentPayDecorator(student); //最终打出来的是付费，注册，vip学习 student.Study();&#125; 设计模式-行为型设计模式：关注对象和行为的分离通俗来讲，就是把方法写在哪里更适合哪里变化 就封装哪里，让别人传进来，自己不去完成 观察者模式12345678910111213141516171819202122232425262728293031private List&lt;IObserver&gt; _observerList = new List&lt;IObserver&gt;();public void Add(IObserver observer)&#123; this._observerList.Add(observer);&#125;public void Remove(IObserver observer)&#123; this._observerList.Remove(observer);&#125;public void MiaoObserver()&#123; foreach(var observer in this._observerList) &#123; observer.Action(); &#125;&#125;//上面这就类似于event,event就是委托的一个实例public event Action MiaoHandler;public void MiaoEvent()&#123; if(MiaoHandler != null) &#123; foreach(Action item in this.MiaoHandler.GetInvocationList()) &#123; item.Invoke(); &#125; //this.MiaoHandler(); &#125;&#125; 责任链模式1，行为型设计模式经常会有这种Context类，用来表示上下文.因为行为经常是各种类乱跑的2，下一个审批人不是由当前类来指定的，而是由调用者来指定的，所以当前类就不需要承担指定下一个类的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class ApplyContext&#123; public int Id &#123;get;set;&#125; public string Name &#123;get;set;&#125; public int Hour &#123;get;set;&#125; public string Description &#123;get;set;&#125; public bool AuditResult&#123;get;set;&#125; public string AuditRemark &#123;get;set;&#125;&#125;public abstract class BaseAuditor&#123; protected BaseAuditor _nextAuditor &#123;get;private set;&#125; public void SetNext(BaseAuditor nextAuditor) &#123; this._nextAuditor = nextAuditor; &#125; protected void AuditNext(ApplyContext context) &#123; if(this._nextAuditor == null) &#123; context.AuditResult = false; context.AuditRemark = &quot;Denied!&quot;; &#125; else &#123; this._nextAuditor.Audit(context); &#125; &#125; public string Name &#123;get;set;&#125; public abstract void Audit(ApplyContext context);&#125;public class PM : BaseAuditor&#123; public override void Audit(ApplyContext context) &#123; context.AuditRemark += &quot;PM process...&quot;; if(context.Hour &lt;= 8) &#123; context.AuditResult = true; context.AuditRemark = &quot;Enjoy!&quot;; &#125; else &#123; base.AuditNext(context); &#125; &#125;&#125;public class AuditManager&#123; private static BaseAuditor AuditProcess = null; static AuditorManager() &#123; //甚至这一部分都可以改成简单工厂，用配置文件构建链表结构 PM pm = new PM() &#123; Name = &quot;aa&quot; &#125;; Charge charge = new Charge() &#123; Name = &quot;bb&quot; &#125;; Manager manager = new Manager() &#123; Name = &quot;cc&quot; &#125;; pm.SetNext(charge); charge.SetNext(manager); AuditProcess = pm; &#125; public static BaseAuditor GetAuditor() &#123; return AuditProcess; &#125;&#125;//caller&#123; //这一步还可以进一步封装，用一个类专门来返回process PM pm = new PM() &#123; Name = &quot;aa&quot; &#125;; Charge charge = new Charge() &#123; Name = &quot;bb&quot; &#125;; Manager manager = new Manager() &#123; Name = &quot;cc&quot; &#125;; pm.SetNext(charge); charge.SetNext(manager); pm.Audit(context); //用专门的类来初始化，将对对象的依赖降到最低 BaseAuditor auditor = AuditorManager.GetAuditor(); auditor.Audit(context);&#125;]]></content>
      <tags>
        <tag>concept</tag>
        <tag>.NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[net-thread]]></title>
    <url>%2F2018%2F07%2F22%2Fnet-thread%2F</url>
    <content type="text"><![CDATA[Thread (.NET 1.0) Basic1， 前台线程thread.Start();进程退出后还会继续执行，直到执行结束。且前台线程只有这种形式，后面的ThreadPool,Async都是后台线程2， 后台线程thread.IsBackground=true;进程退出后还会继续执行，直到执行结束。 1234567891011121314151617private void btnThreads_Click(object sender, EventArgs e)&#123; Console.WriteLine($&quot;*************btnThreads_Click Start &#123;Thread.CurrentThread.ManagedThreadId.ToString(&quot;00&quot;)&#125;&quot;); ThreadStart threadStart = new ThreadStart(()=&gt; &#123; Thread.Sleep(5000); this.DoSomething(&quot;btnThreads_Click&quot;); &#125;); Thread thread = new Thread(threadStart); thread.IsBackground=true;//这样就会改成后台线程，这样进程退出后，线程也会一起推出 thread.Start();//默认是前台线程，进程退出后还会继续执行，直到执行结束。 //thread.Join();//做等待用的，执行thread的这个线程会等待thread线程&#125; 用Thread实现回调且不卡界面等同于BeginInvoke的回调1234567891011private void ThreadWithCallBack(ThreadStart threadStart, Action act)&#123; ThreadStart startNew = new ThreadStart( ()=&gt;&#123; threadStart.Invoke(); act.Invoke(); &#125; ); Thread thread = new Thread(startNew); thread.Start();&#125; Thread实现带返回值的且不卡界面123456789101112131415161718private void ThreadWithReturn&lt;T&gt;(Func&lt;T&gt; funcT)&#123; T t = default(T); ThreadStart startNew = new ThreadStart( () = &gt; &#123; t = funcT.Invoke(); &#125;); Thread thread = new Thread(startNew); thread.Start(); //因为只有在计算委托的时候才会线程等待，所以返回的时候要包一个委托 return new Func&lt;T&gt;(()=&gt; &#123; thread.Join(); return t; &#125;);&#125; ThreadPool(.NET 2.0)ThreadPool的特点：1，减少了线程创建/销毁的工作2，可以限制线程的数量 带回调的ThreadPool1234567891011ThreadPool.QueueUserWorkItem( o =&gt; &#123; new Action( ()=&gt;&#123; Thread.Sleep(5000); this.DoSomethingLong(&quot;btnThreads_Click&quot;); &#125;).Invoke(); //Callback Console.WriteLine(&quot;This is a callback func.&quot;); &#125;); 线程等待Notice!没有需求，就不要等待，容易阻塞线程123456789101112131415//这个就是用作标志，如果这个标志是false，那么主线程就会一直等待,除非在子线程里面设置mre.Set()ManualResetEvent mre = new ManualResetEvent(false);//false代表关闭ThreadPool.QueueUserWorkItem( o =&gt; &#123; Thread.Sleep(5000); this.DoSomethingLong(&quot;btnThreads_Click&quot;); Console.WriteLine(o.ToString()); mre.Set();//打开 &#125;,&quot;backbone&quot;);Console.WriteLine(&quot;before WaitOne&quot;);mre.WaitOne();//这个是做真正的Wait操作，但是这里等待的是一个信号量，其不管是谁执行的，只有把mre.Set()我就立刻执行，这是与thread.Join()的区别Console.WriteLine(&quot;after WaitOne&quot;);mre.Reset();//关闭 Task(.NET 3.0)Task的优势：1，使用的是线程池的线程，全部是后台线程2，API十分强大 123456TaskFactory taskFactory = Task.Factory;&#123; taskFactory.StartNew(()=&gt;&#123;this.DoSomethingLong(&quot;btnTask_Click001&quot;);&#125;); taskFactory.StartNew(()=&gt;&#123;this.DoSomethingLong(&quot;btnTask_Click002&quot;);&#125;); taskFactory.StartNew(()=&gt;&#123;this.DoSomethingLong(&quot;btnTask_Click003&quot;);&#125;);&#125; 需要多线程加快速度，但是又要求全部/某些完成后才能返回这种写法会卡界面1234567891011121314TaskFactory taskFactory = Task.Factory;&#123; List&lt;Task&gt; taskList = new List&lt;Task&gt;(); taskList.Add(taskFactory.StartNew(()=&gt;this.DoSomethingLong(&quot;btnTask_Click001&quot;))); taskList.Add(taskFactory.StartNew(()=&gt;this.DoSomethingLong(&quot;btnTask_Click002&quot;))); taskList.Add(taskFactory.StartNew(()=&gt;this.DoSomethingLong(&quot;btnTask_Click003&quot;))); //这个一定会卡界面，因为是主线程在等待 Task.WaitAll(taskList.ToArray()); //需要某个完成之后返回,只要其中有任何一个完成，就打印下一句，然后其他的子线程再陆续自行完成 Task.WaitAny(taskList.ToArray()); Console.WriteLine(&quot;全部任务都完成才能走到这里&quot;)&#125; 不卡界面的写法/回调1234567891011121314TaskFactory taskFactory = Task.Factory;List&lt;Task&gt; taskList = new List&lt;Task&gt;();taskList.Add(taskFactory.StartNew(()=&gt;this.DoSomethingLong(&quot;btnTask_Click001&quot;)));taskList.Add(taskFactory.StartNew(()=&gt;this.DoSomethingLong(&quot;btnTask_Click002&quot;)));taskList.Add(taskFactory.StartNew(()=&gt;this.DoSomethingLong(&quot;btnTask_Click003&quot;)));taskFactory.ContinueWhenAny(taskList.ToArray(),t=&gt;Console.WriteLine($&quot;This is ContinueWhenAny &#123;Thread.CurrentThread.ManagedThreadId.ToString()&#125;&quot;));taskFactory.ContinueWhenAll(taskList.ToArray(), tList =&gt; Console.WriteLine($&quot;This is ContinueWhenAll callback &#123;Thread.CurrentThread.ManagedThreadId.ToString()&#125;&quot;))Task.WaitAny(taskList.ToArray());Console.WriteLine(&quot;某个任务完成，才会执行&quot;);Task.WaitAll(taskList.ToArray());Console.WriteLine(&quot;全部任务都完成，才会执行&quot;); 这里注意了，一般ContinueWhenXX都是在Task.WaitXX之后执行的，因为Task.WaitXX是主线程，它只需要听从一个信号量就可以，但是ContinueWhenXX是需要重新起一个线程，所以会比较慢 那么如何知道到底是哪个线程任务完成了呢？可以在taskFactory.StartNew的时候定义一个state12Task task = taskFactory.StartNew(()=&gt;this.DoSomethingLong(&quot;btnTask_Click001&quot;),&quot;It&apos;s A NAME&quot;);//task.AsyncState里面就会保存“It&apos;s A NAME” 取返回值12Task&lt;int&gt; intTask = taskFactory.StartNew(()=&gt;123);int iResult = intTask.Result; 如果只想某一个线程里面做回调12Task task = taskFactory.StartNew(()=&gt;this.DoSomethingLong(&quot;btnTask_Click001&quot;),&quot;It&apos;s A NAME&quot;) .ContinueWith(t=&gt;Console.WriteLine(&quot;这里是It&apos;s A Name的回调&quot;)); Parallel1，相当于Task+WaitAll2，主线程也参与计算，节约了一个线程，所以计算的时候卡界面 1234Parallel.Invoke(()=&gt; this.DoSomethingLong(&quot;btnParallel_Click_001&quot;), ()=&gt; this.DoSomethingLong(&quot;btnParallel_Click002&quot;), ()=&gt; this.DoSomethingLong(&quot;btnParallel_Click003&quot;), ()=&gt; this.DoSomethingLong(&quot;btnParallel_Click004&quot;)); 也可以写成这种形式12345678910111213141516171819Parallel.For(0,5,t=&gt;&#123; this.DoSomethingLong($&quot;btnParallel_Click_00&#123;t&#125;&quot;); &#125;);Parallel.ForEach(new int[]&#123;0,1,2,3,4&#125;,t=&gt;&#123; this.DoSomethingLong($&quot;btnParallel_Click_00&#123;t&#125;&quot;); &#125;);//也可以控制最大线程数量,比方说最大能用3个线程ParallelOptions options = new ParallelOptions()&#123; MaxDegreeOfParallelism = 3;&#125;Parallel.ForEach(new int[]&#123;0,1,2,3,4&#125;,options,(t,state)=&gt;&#123; this.DoSomethingLong($&quot;btnParallel_Click_00&#123;t&#125;&quot;); state.Stop();//结束全部的 state.Break();//停止当前的 &#125;); Thread的异常1，多线程里面的异常是会被吞掉的，外层是Catch不到线程里面的异常的2，除非让主线程WaitAll才能拿到这个线程3，建议多线程里面的异常自己在Action里面处理好，比方说加try catch 12345678910111213141516171819202122232425262728293031323334353637383940TaskFactory taskFactory = new TaskFactory();List&lt;Task&gt; taskList = new List&lt;Task&gt;();try&#123; for(int i=0; i&lt; 20; i++) &#123; string name = string.Format($&quot;btnThreadCore_Click_&#123;i&#125;&quot;); Action&lt;object&gt; act = t =&gt;&#123; try &#123; Thread.Sleep(2000); if(t.ToString().Equals(&quot;btnThreadCore_Click_11&quot;)) &#123; throw new Exception(string.Format($&quot;&#123;t&#125;执行失败&quot;)); &#125; Console.WriteLine(&quot;&#123;0&#125;执行成功&quot;,t); &#125; //如果这一段的catch拿掉，外层是catch不到线程里面的异常的 //catch(Exception ex) //&#123; // Console.WriteLine(ex.Message); //&#125; &#125;; taskList.Add(taskFactory.StartNew(act,name)); &#125; //要抓到里面的异常需要这么做： Task.WaitAll(taskList.ToArray());&#125;catch(AggregateException aex)&#123; foreach(var item in aex.InnerExceptions) &#123; Console.WriteLine(item.Message); &#125;&#125;catch(Exception ex)&#123; Console.WriteLine(ex.Message);&#125; 线程取消1，线程取消不是操作线程，而是操作共享变量（多个线程都能访问到的东西，变量/数据库的数据/标识）2，每个线程在执行的过程中，要经常去查看一下这个信号量，然后自己结束自己3，线程不能被别人终止，只能自己干掉自己4，延迟是少不了的5，CancellationTokenSource可以在cancel之后，取消没有启动的任务1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253TaskFactory taskFactory = new TaskFactory();List&lt;Task&gt; taskList = new List&lt;Task&gt;();CancellationTokenSource cts = new CancellationTokenSource();try&#123; for(int i =0; i&lt;40; i++) &#123; string name = string.Format(&quot;btnThreadCore_Click&#123;0&#125;&quot;,i); Action&lt;object&gt; act = t =&gt; &#123; try &#123; Thread.Sleep(2000); if(t.ToString().Equals(&quot;btnThreadCore_Click_11&quot;)) &#123; throw new Exception($&quot;&#123;t&#125;执行失败&quot;); &#125; //检查信号量，初始化的实会是false if(cts.IsCancellationRequested) &#123; Console.WriteLine(&quot;&#123;0&#125; 放弃执行&quot;,t); &#125; else &#123; Console.WriteLine(&quot;&#123;0&#125; 执行成功&quot;,t); &#125; &#125; //在线程内部执行try catch的检查 catch(Exception ex) &#123; //只要cts.Cancel发出来了，还没有执行的线程就不会再执行了，这是. NET框架帮忙做的 cts.Cancel(); Console.WriteLine(ex.Message); &#125; &#125;; taskList.Add(taskFactory.StartNew(act, name, cts.Token)); &#125;&#125;catch(AggregateException aex)&#123; foreach(var item in aex.InnerExceptions) &#123; Console.WriteLine(item.Message); &#125;&#125;catch(exception ex)&#123; Console.WriteLine(ex.Message);&#125;Task.WaitAll(taskList.ToArray()); 多线程临时变量如果只是这样写，出来的结果会是5个5为什么呢？因为BeginInvoke不占用主线程，在它loop的时候主线程已经执行到下面的代码去了，再启动子线程的时候，i已经遍历到5了12345678for(int i = 1; i&lt; 5; i++)&#123; new Action(() =&gt; &#123; Thread.Sleep(100); Console.WriteLine(i); &#125;).BeginInvoke(null,null);&#125; 但是如果你加一个变量每次启动子线程的时候，k都是独立不同的123456789for(int i = 1; i&lt; 5; i++)&#123; int k = i; new Action(() =&gt; &#123; Thread.Sleep(100); Console.WriteLine(k); &#125;).BeginInvoke(null,null);&#125; 线程安全问题 lock注意！！只要用了多线程，还有for循环，最好就是在for里面定义一个新的变量与i对应，防止线程变量问题 多个线程操作同一个变量，都有可能发生线程不安全问题线程内部不佛念故乡的东西是安全的CancellationToken, ManualResetEvent这类的都是安全的123456789101112131415int TotalCount;var IntList = new List&lt;int&gt;();for(int i=0; i&lt;10000;i++)&#123; int newI = i; //要注意，这里并不是说起10000个线程，因为用taskFactory其实用的还是线程池里面的，不会起这么多线程的 taskList.Add(taskFactory.StartNew(()=&gt; &#123; this.TotalCount += 1;//多个线程同时操作，有些操作可能会被覆盖，所以有可能是10000，也可能&lt;10000 IntList.Add(newI); &#125;));&#125;Task.WaitAll(taskList.ToArray());Console.WriteLine(this.TotalCount);Console.WriteLine(IntList.Count()); 结果却是如图： 为什么呢？对于这个this.TotalCount,会有多个线程对它同时加1，所以有时候操作被覆盖了;IntList集合也是不安全，引用类型，同时多个线程对它访问，也会有可能被覆盖的; 怎么样让其正确？方法一，lock，用变量来保证，但是lock的方法块里面是单线程的,所以一定要保证不需要lock的逻辑放在lock之外 如果每个实例想要单独的锁定，那么就用一个private object，这样只有实例了你这个类的才能用 1，不要用lock(this),因为只要有一个人锁定了，别的地方想要用这个变量，就会都被锁定2，不要用lock(“12345”),这种是享元模式的内存分配，如果有另外一个变量string b = “12345”，那么会锁定这个变量b3，如果需要全局唯一的锁，那么推荐的做法是private static readonly object XX_Lock=new object();,private保证不让别人访问，只能内部访问，static保证全局只有一个，readonly保证不会在lock内部被更改4，如果想要实例唯一，用private object YY_Lock = new object(); 1234567891011121314151617private static readonly object btnThreadCore_Click_Lock = new object();for(int i=0; i&lt;10000;i++)&#123; int newI = i; //要注意，这里并不是说起10000个线程，因为用taskFactory其实用的还是线程池里面的，不会起这么多线程的 taskList.Add(taskFactory.StartNew(()=&gt; &#123; //线程看到这会先检查有没有别的变量在用这个名为btnThreadCore_Click_Lock锁定，如果锁定了就会等待 //这样就保证唯一时刻只有一个线程在访问 lock(btnThreadCore_Click_Lock) &#123; this.TotalCount += 1; IntList.Add(newI); &#125; &#125;));&#125; 方法二，让其没有冲突，从数据上隔离开，比方说这个线程访问前100个，另一个线程访问后面200个 Await/Async1，await和async要成对使用才有效果2，await后面就是Task的回调 123456789101112131415161718192021private static async void NoReturn()&#123; //主线程执行 Console.WriteLine($&quot;NoReturn before await, ThreadId=&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;); TaskFactory taskFactory = new TaskFactory(); Task task = taskFactory.StartNew(()=&gt; &#123; Console.WriteLine($&quot;NoReturn task before sleep, ThreadId=&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;); Thread.Sleep(3000); Console.WriteLine($&quot;NoReturn task after sleep, ThreadId=&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;); &#125;); //主线程到此就返回了，下面都是子线程来执行 await task; //相当于await后面的都是回调！！！ //加入await之后，这一段就被封装成一个委托，在task之后形成回调，相当于task.ContinueWith() //但是这个回调的线程是不确定的，有可能是主线程，也有可能是子线程，也有可能是其他线程！ Console.WriteLine($&quot;NoReturn after await, ThreadId=&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;)&#125; 带返回值的await/async1，注意，虽然函数是返回Task,但是return的却是一个long类型 12345678910111213141516171819202122232425262728private static async Task&lt;long&gt; SumAsync()&#123; Console.WriteLine($&quot;SumAsync Start, ManagedThreadId=&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;); long result=0; await Task.Run(()=&gt; &#123; for(int k=0; k&lt;10;k++) &#123; Console.WriteLine($&quot;SumAsync &#123;k&#125; await Task.Run ManagedThreadId=&#123;Thr ead.CurrentThread.ManagedThreadId&#125;&quot;); Thread.Sleep(1000); &#125; for(long i=0; i &lt; 999999999; i++) &#123; result += i; &#125; &#125;); Console.WriteLine($&quot;SumAsync end ManagedThreadId=&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;); return result;&#125;//Caller&#123; Tasl&lt;int&gt; t = SumAsync(); Console.WriteLine($&quot;Main Thread Task SumAsync, ManagedThreadId=&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;); long lResult = t.Result; t.Wait();//与long lResult = t.Result是相同的，都会线程等待&#125; 上面的这种写法与下面相同12345678910111213private static Task&lt;int&gt; SumFactory()&#123; Console.WriteLine($&quot;SumFactory Start, ManagedThreadId=&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;); TaskFactory taskFactory = new TaskFactory(); Task&lt;int&gt; iResult = taskFactory.StartNew&lt;int&gt;(()=&gt; &#123; Thread.Sleep(3000); Console.WriteLine($&quot;SumFactory ManagedThreadId=&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;); return 123; &#125;); Console.WriteLine($&quot;SumFactory end ManagedThreadId=&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;); return iResult;&#125; 如果是有多个await，碰到第一个await,主线程返回，然后子线程A会把下面的所有当成回调，所以子线程A碰到第二个await，会返回，第三个await由子线程B来执行，知道返回return。 子线程来更改主线程的UI如果这样写，会报错12345678910111213141516if(c is lable)&#123; Label lbl = (Lable)c; if(lbl.Name.Contains(&quot;Blue&quot;)) &#123; taskFactory.StartNew(()=&gt;&#123; this.ProcessLableBlue(lbl);&#125;); &#125;&#125;private void ProcessLableBlue(Lable lbl)&#123; int index = new RandomHelper().GetNumber(0,15); //InvalidOperationException! lbl.Text = this.BlueNums[index];&#125; 子线程修改UI的方法123456789101112131415private void UpdateLbl(Lable lbl, string text)&#123; //线程安全的考虑 if(lbl.InvokeRequired) &#123; //Invoke方法代表把这个Action交给UI线程来执行 this.Invoke(new Action(() =&gt; &#123; lbl.Text = text; &#125;)); &#125;else &#123; lbl.Text = text; &#125;&#125; 如果有多个子线程同时工作，且要求每个子线程的结果不能相同1，注意了，虽然这里在lock里面又递归调用了ProcessLable方法，但是并不会死锁，因为这个锁有一个作用域的概念，你递归的时候还是在同一个作用域里面，所以并不会死锁 123456789101112131415161718192021222324private static object UpdateLblLock = new object();private void ProcessLable(Lable lbl)&#123; if(lbl.Name.Contains(&quot;Blue&quot;)) &#123; int index = new RandomHelper().GetNumber(0,15); string text = this.BlueNums[index]; this.UpdateLbl(lbl,text); &#125; else &#123; int index = new RandomHelper.GetNumber(0,33); string text = this.RedNums[index]; lock(UpdateLblLock) &#123; List&lt;string&gt; numberUsedList = this.GetUsedNums(); if(numberUsedList.Contains(text)) &#123; return; &#125; this.UpdateLbl(lbl,text); &#125; &#125;&#125; 要求点击Stop之后，MessageBox Show结果如果写在btnStop_Click中就会死掉，为什么呢？1，当IsGoOn=false的时候，就会等待ProcessLable结束2，ProcessLable是怎么结束的呢？调用Invoke，而这个Invoke是主线程在调用的3，但是这个时候主线程在Task.WaitAll()4，所以死掉12345678910111213141516171819202122private bool IsGoOn = true;//caller&#123; taskList.Add(taskFactory.StartNew(()=&gt; &#123; while(IsGoOn) &#123; this.ProcessLable(lbl); &#125; &#125;));&#125;//btnStop_Click&#123; this.IsGoOn = false; this.btnStart.Enabled = true; this.btnStop.Enabled = false; //死掉了，主线程等着任务执行完，但是任务还在找主线程去干活 Task.WaitAll(this.taskList.ToArray()); this.MessageShow();&#125; 那么该怎么做？通过回调的形式结束！12345678910111213141516171819//caller &#123; foreach(Control c in this.gbo.Controls) &#123; if(c is Label) &#123; Label lbl = (Lable)c; taskList.Add(taskFactory.StartNew(()=&gt; &#123; while(IsGoOn) &#123; this.ProcessLable(lbl); &#125; &#125;)); &#125; &#125; this.btnStop.Enabled = true; taskFactory.ContinueWhenAll(taskList.ToArray(), tList=&gt;this.MessageShow());&#125;]]></content>
      <tags>
        <tag>concept</tag>
        <tag>.NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[net-async]]></title>
    <url>%2F2018%2F07%2F17%2Fnet-async%2F</url>
    <content type="text"><![CDATA[Basic异步多线程：多线程是说的CLR线程，异步是说IO线程要用异步多线程必须要用Delegate委托12345678910111213141516171819202122private void btnAsync_Click(object sender, EventArgs e)&#123; //同步调用，必须DoSomethingLong结束后才会走下一步 Action&lt;string&gt; act = new Action&lt;string&gt;(this.DoSomethingLong); act.Invoke(&quot;this.DoSomethingLong&quot;); //异步调用，会启动一个线程；现象是直接进入下一行，不会等待 act.BeginInvoke(&quot;this.DoSomethingLong&quot;,null,null);&#125;private void DoSomethingLong(string name)&#123; Console.WriteLine($&quot;********DoSomethingLong Start &#123;Thread.CurrentThread.ManagedThreadId.ToString(&quot;00&quot;)&#125;&quot;); long lResult = 0; for(int i=0; i&lt;1000000;i++) &#123; lResult += i; &#125; Thread.Sleep(2000); Console.WriteLine($&quot;********DoSomethingLong End &#123;Thread.CurrentThread.ManagedThreadId.ToString(&quot;00&quot;)&#125;&quot;);&#125; 异步多线程如何控制顺序回调，这种方法十分稳定，一定会在委托执行完后再执行1234567891011private void btnAsync_Click(object sender, EventArgs e)&#123; Console.WriteLine($&quot;***********btnAsync_Click Startc &#123;Thread.CurrentThread.ManagedThreadId.ToString(&quot;00&quot;)&#125;&quot;); Action&lt;string&gt; act = this.DoSomethingLong; //回调方法，一定会在DoSomethingLong之后调用 AsyncCallback callback=ar =&gt; Console.WriteLine($&quot;这里是BeginInvoke调用完成之后才执行的&#123;Thread.CurrentThread.ManagedThreadId.ToString(&quot;00&quot;)&#125;&quot;); //para asyncState会被保存在iAsyncResult的asyncState参数中 IAsyncResult iAsyncResult = act.BeginInvoke(&quot;btnAsync_Click&quot;,callback,&quot;asyncState&quot;);&#125; 等待1, while这里是主线程来做的，所以会卡界面2, EndInvoke可以拿到之前委托的结果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void btnAsync_Click(object sender, EventArgs e)&#123; Console.WriteLine($&quot;***********btnAsync_Click Startc &#123;Thread.CurrentThread.ManagedThreadId.ToString(&quot;00&quot;)&#125;&quot;); Action&lt;string&gt; act = this.DoSomethingLong; //para asyncState会被保存在iAsyncResult的asyncSta te参数中 IAsyncResult iAsyncResult = act.BeginInvoke(&quot;btnAsync_Click&quot;,null,null); int i=1; //1 卡界面，主线程会等待 //2 边等待边做事 //3 有误差，会等待200毫秒 while(!iAsyncResult.IsCompleted) &#123; if(i &lt; 10) &#123; Console.WriteLine(&quot;文件上传&#123;0&#125;%...请等待&quot;,i++ * 10); &#125; else &#123; Console.WriteLine(&quot;马上结束&quot;); &#125; Thread.Sleep(200); Console.WriteLine(&quot;这里是BeginInvoke调用完成之后才执行的&quot;); &#125; //另外一种方式可以让异步变同步,不会有误差的，一直等待任务完成，这种方式不能在等待的过程中做别的事情 iAsyncResult.AsyncWaitHandle.WaitOne(); //最多等待1000毫秒，可以做超时控制 iAsyncResult.AsyncWaitHandle.WaitOne(1000); &#123; Func&lt;int,string&gt; func = i =&gt; i.ToString(); iAsyncResult iAsyncResult = func.BeginInvoke(DateTime.Now.Year, ar=&gt;&#123; //这个就是传入的“Lalala” Console.WriteLine(ar.AsyncState); &#125;,&quot;Lalala&quot;); //这个result就是func的返回值 string result = func.EndInvoke(iAsyncResult); &#125; //对于每个异步调用，只能有一个EndInvoke &#123; Func&lt;int,string&gt; func = i =&gt; i.ToString(); iAsyncResult iAsyncResult = func.BeginInvoke(DateTime.Now.Year, ar=&gt;&#123; string resultIn = func.EndInvoke(ar); //这个就是传入的“Lalala” Console.WriteLine($&quot;This is &#123;ar.AsyncState&#125; 的异步调用结果 &#123;resultIn&#125;&quot;); &#125;,&quot;Lalala&quot;); //这个result就是func的返回值 &#125;&#125;]]></content>
      <tags>
        <tag>concept</tag>
        <tag>.NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lxd-ubuntu]]></title>
    <url>%2F2018%2F07%2F02%2Flxd-ubuntu%2F</url>
    <content type="text"><![CDATA[ENV: UBUNTU Add a non root user123456adduser lxduserusermod -aG sudo lxduser##disable password authenticationsudo nano /etc/ssh/sshd_configPasswordAuthentication nosudo systemctl reload sshd Configure LXD12345678910111213sudo usermod --append --groups lxd lxdusersudo apt-get updatesudo apt-get install zfsutils-linuxsudo lxd initDo you want to configure a new storage pool (yes/no) [default=yes]? yesName of the storage backend to use (dir or zfs) [default=zfs]: zfsCreate a new ZFS pool (yes/no) [default=yes]? yesName of the new ZFS pool [default=lxd]: lxdWould you like to use an existing block device (yes/no) [default=no]?Would you like to use an existing block device (yes/no) [default=no]? noSize in GB of the new loop device (1GB minimum) [default=15]: 15Would you like LXD to be available over the network (yes/no) [default=no]? noDo you want to configure the LXD bridge (yes/no) [default=yes]? yes Create Container123456789101112lxc listGenerating a client certificate. This may take a minute...If this is your first time using LXD, you should also run: sudo lxd initTo start your first container, try: lxc launch ubuntu:16.04+------+-------+------+------+------+-----------+| NAME | STATE | IPV4 | IPV6 | TYPE | SNAPSHOTS |+------+-------+------+------+------+-----------+lxc launch ubuntu:x webserver##The x in ubuntu:x is a shortcut for the first letter of Xenial, the codename of Ubuntu 16.04. ubuntu: is the identifier for the preconfigured repository of LXD images. You could also use ubuntu:16.04 for the image name. Configure Container1lxc exec webserver -- sudo --login --user ubuntu Ubuntu Nginx AutoStart[https://community.rackspace.com/products/f/public-cloud-forum/6747/ubuntu-and-debian---adding-an-nginx-init-script] 1sudo nano /etc/init.d/nginx Add those, spotted: ADD YOUR NGINX INSTALLATION PATH INTO $PATH12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#! /bin/sh ### BEGIN INIT INFO# Provides: nginx# Required-Start: $all# Required-Stop: $all# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: starts the nginx web server# Description: starts nginx using start-stop-daemon### END INIT INFO PATH=/usr/local/nginx/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/binDAEMON=/usr/local/nginx/sbinNAME=nginxDESC=nginx test -x $DAEMON || exit 0 # Include nginx defaults if availableif [ -f /etc/default/nginx ] ; then . /etc/default/nginxfi set -e . /lib/lsb/init-functions case "$1" in start) echo -n "Starting $DESC: " start-stop-daemon --start --quiet --pidfile /usr/local/nginx/logs/$NAME.pid \ --exec $DAEMON -- $DAEMON_OPTS || true echo "$NAME." ;; stop) echo -n "Stopping $DESC: " start-stop-daemon --stop --quiet --pidfile /usr/local/nginx/logs/$NAME.pid \ --exec $DAEMON || true echo "$NAME." ;; restart|force-reload) echo -n "Restarting $DESC: " start-stop-daemon --stop --quiet --pidfile \ /usr/local/nginx/logs/$NAME.pid --exec $DAEMON || true sleep 1 start-stop-daemon --start --quiet --pidfile \ /usr/local/nginx/logs/$NAME.pid --exec $DAEMON -- $DAEMON_OPTS || true echo "$NAME." ;; reload) echo -n "Reloading $DESC configuration: " start-stop-daemon --stop --signal HUP --quiet --pidfile /usr/local/nginx/logs/$NAME.pid \ --exec $DAEMON || true echo "$NAME." ;; status) status_of_proc -p /usr/local/nginx/logs/$NAME.pid "$DAEMON" nginx &amp;&amp; exit 0 || exit $? ;; *) N=/etc/init.d/$NAME echo "Usage: $N &#123;start|stop|restart|reload|force-reload|status&#125;" &gt;&amp;2 exit 1 ;;esac exit 0 12sudo chmod +x /etc/init.d/nginxsudo /usr/sbin/update-rc.d -f nginx defaults The output will be similar to this:123456789Adding system startup for /etc/init.d/nginx ... Adding system startup for /etc/init.d/nginx ... /etc/rc0.d/K20nginx -&gt; ../init.d/nginx /etc/rc1.d/K20nginx -&gt; ../init.d/nginx /etc/rc6.d/K20nginx -&gt; ../init.d/nginx /etc/rc2.d/S20nginx -&gt; ../init.d/nginx /etc/rc3.d/S20nginx -&gt; ../init.d/nginx /etc/rc4.d/S20nginx -&gt; ../init.d/nginx /etc/rc5.d/S20nginx -&gt; ../init.d/nginx Then start/stop/restart12345sudo /etc/init.d/nginx start...sudo /etc/init.d/nginx stop...sudo /etc/init.d/nginx restart Reset timezone1sudo dpkg-reconfigure tzdata Rename Container1, Login to the container 123456sudo -shostname newNameecho newName &gt; /etc/hostnamebashrebootexit 2, Return to the host 12345sudo -slxc stop oldNamelxc move oldName newNamelxc start newNamelxc list Copy Container12lxc copy old1 new1lxc start new1 Add Swap Space[https://www.digitalocean.com/community/tutorials/how-to-add-swap-space-on-ubuntu-16-04] Check system for swap information1sudo swapon --show If you don’t get back any output, this means your system does not have swap space available currently. You can verify that there is no active swap using the free utility:1free -h 1234Output total used free shared buff/cache availableMem: 488M 36M 104M 652K 348M 426MSwap: 0B 0B 0B Check Available Space on the Hard Drive PartitionThe most common way of allocating space for swap is to use a separate partition devoted to the task. However, altering the partitioning scheme is not always possible. We can just as easily create a swap file that resides on an existing partition. Before we do this, we should check the current disk usage by typing: 1df -h 123456789OutputFilesystem Size Used Avail Use% Mounted onudev 238M 0 238M 0% /devtmpfs 49M 624K 49M 2% /run/dev/vda1 20G 1.1G 18G 6% /tmpfs 245M 0 245M 0% /dev/shmtmpfs 5.0M 0 5.0M 0% /run/locktmpfs 245M 0 245M 0% /sys/fs/cgrouptmpfs 49M 0 49M 0% /run/user/1001 Create a Swap FileNow that we know our available hard drive space, we can go about creating a swap file within our filesystem. We will create a file of the swap size that we want called swapfile in our root (/) directory. The best way of creating a swap file is with the fallocate program. This command creates a file of a preallocated size instantly. Since the server in our example has 512MB of RAM, we will create a 1 Gigabyte file in this guide. Adjust this to meet the needs of your own server:1sudo fallocate -l 1G /swapfile We can verify that the correct amount of space was reserved by typing:1ls -lh /swapfile 1-rw-r--r-- 1 root root 1.0G Apr 25 11:14 /swapfile Enabling the Swap FileNow that we have a file of the correct size available, we need to actually turn this into swap space. First, we need to lock down the permissions of the file so that only the users with root privileges can read the contents. This prevents normal users from being able to access the file, which would have significant security implications. Make the file only accessible to root by typing:1sudo chmod 600 /swapfile We can now mark the file as swap space by typing:1sudo mkswap /swapfile 12Setting up swapspace version 1, size = 1024 MiB (1073737728 bytes)no label, UUID=6e965805-2ab9-450f-aed6-577e74089dbf After marking the file, we can enable the swap file, allowing our system to start utilizing it:1sudo swapon /swapfile We can verify that the swap is available by typing:1sudo swapon --show 123OutputNAME TYPE SIZE USED PRIO/swapfile file 1024M 0B -1 Make the swap file permanantOur recent changes have enabled the swap file for the current session. However, if we reboot, the server will not retain the swap settings automatically. We can change this by adding the swap file to our /etc/fstabfile. 12sudo cp /etc/fstab /etc/fstab.bakecho '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab Adjusting the Swappiness PropertyThe swappiness parameter configures how often your system swaps data out of RAM to the swap space. This is a value between 0 and 100 that represents a percentage. With values close to zero, the kernel will not swap data to the disk unless absolutely necessary. Remember, interactions with the swap file are “expensive” in that they take a lot longer than interactions with RAM and they can cause a significant reduction in performance. Telling the system not to rely on the swap much will generally make your system faster. Values that are closer to 100 will try to put more data into swap in an effort to keep more RAM space free. Depending on your applications’ memory profile or what you are using your server for, this might be better in some cases. 1cat /proc/sys/vm/swappiness 12Output60 For a Desktop, a swappiness setting of 60 is not a bad value. For a server, you might want to move it closer to 0. We can set the swappiness to a different value by using the sysctl command. For instance, to set the swappiness to 10, we could type:1sudo sysctl vm.swappiness=10 12Outputvm.swappiness = 10 This setting will persist until the next reboot. We can set this value automatically at restart by adding the line to our /etc/sysctl.conf file:1sudo nano /etc/sysctl.conf At the bottom, you can add:1vm.swappiness=10 Adjusting the Cache Pressure SettingAnother related value that you might want to modify is the vfs_cache_pressure. This setting configures how much the system will choose to cache inode and dentry information over other data. Basically, this is access data about the filesystem. This is generally very costly to look up and very frequently requested, so it’s an excellent thing for your system to cache. You can see the current value by querying the proc filesystem again:1cat /proc/sys/vm/vfs_cache_pressure 12Output100 As it is currently configured, our system removes inode information from the cache too quickly. We can set this to a more conservative setting like 50 by typing:1sudo sysctl vm.vfs_cache_pressure=50 Again, this is only valid for our current session. We can change that by adding it to our configuration file like we did with our swappiness setting:12sudo nano /etc/sysctl.confvm.vfs_cache_pressure=50 Bash Script to launch lxdREF:[https://gist.github.com/CalebEverett/aef682acf6988bbc44d9d8196f222355] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148#!/bin/bash# variablesCONTAINER=mycontainerIMAGE=ubuntu-daily:xenialPORT=8080PROFILES=defaultFOLDER=appREPO=https://github.com/CalebEverett/hello-lxd.gitRUN_USER=appRUN_USER_UID=1444CONTAINER_ROOT_UID=$(cat /etc/subgid | grep lxd | cut -d : -f 2)function wait_bar () &#123; for i in &#123;1..10&#125; do printf '= %.0s' &#123;1..$i&#125; sleep $1s done&#125;# create the container if it doesn't existif [ ! -e /var/lib/lxd/containers/$CONTAINER ] then lxc launch --verbose $IMAGE $CONTAINER wait_bar 0.5 echo container $CONTAINER started else echo container $CONTAINER already createdfi# apply profileslxc profile apply $CONTAINER $PROFILES# delete ubuntu userif [ ! -z $(lxc exec $CONTAINER -- getent passwd | grep ubuntu) ]then lxc exec $CONTAINER -- userdel -r ubuntufi# create running userif [ -z $(lxc exec $CONTAINER -- getent passwd | grep $RUN_USER) ]then lxc exec $CONTAINER -- useradd -u $RUN_USER_UID -s /usr/sbin/nologin $RUN_USERfi#install nodeif [ -z $(lxc exec $CONTAINER -- which node) ]then printf "\n\n*** Installing node ***" lxc exec $CONTAINER -- /bin/bash -c 'curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash -' lxc exec $CONTAINER -- apt-get install -y nodejs echo Node $(lxc exec $CONTAINER -- node -v) installedelse echo Node $(lxc exec $CONTAINER -- node -v) already installedfi#install gitif [ -z $(lxc exec $CONTAINER -- which git) ]then printf "\n\n*** Installing git ***" lxc exec $CONTAINER -- apt-get install -y git echo $(lxc exec $CONTAINER -- git --version) installedelse echo $(lxc exec $CONTAINER -- git --version) already installedfi# redirect 80 to $PORTif [[ -z $(lxc exec $CONTAINER -- cat /etc/ufw/before.rules | grep PREROUTING) ]]then lxc exec $CONTAINER -- /bin/bash -c "sed -i '/# ufw-before-forward/ a\#\n\# redirect 80 to $PORT\n\*nat\n\:PREROUTING ACCEPT [0:0]\n\-A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port $PORT\n\COMMIT' /etc/ufw/before.rules" lxc exec $CONTAINER -- ufw enable lxc exec $CONTAINER -- ufw allow $PORT/tcpfi#mount $FOLDER directory if developingif [[ $FOLDER &amp;&amp; $PROFILES == *"default"* ]]then printf "\n\n*** Mounting shared folder ***\n" if [ ! -d ./$FOLDER ]; then mkdir ./$FOLDER; fi if [[ -z $(lxc config device list $CONTAINER | grep $FOLDER) ]] then lxc config device add $CONTAINER $FOLDER disk path=/usr/src/$FOLDER source=$(pwd)/$FOLDER sudo chown -R $((CONTAINER_ROOT_UID + RUN_USER_UID)):$((CONTAINER_ROOT_UID + $RUN_USER_UID)) ./$FOLDER sudo setfacl -R -m d:u:$USER:xwr,u:$USER:xwr,d:g:$USER:xwr,g:$USER:xwr ./$FOLDER sudo chown -R $((CONTAINER_ROOT_UID + RUN_USER_UID)):$((CONTAINER_ROOT_UID + $RUN_USER_UID)) ./$FOLDER echo $(pwd)/$FOLDER mounted at /usr/src/$FOLDER else echo Directory $(pwd)/$FOLDER already mounted fifi#clone repo and install modulesif [ $REPO ] then if [[ -z $(lxc exec $CONTAINER -- cat /usr/src/$FOLDER/package.json) ]] then lxc exec $CONTAINER -- git clone -q $REPO /usr/src/$FOLDER lxc exec $CONTAINER --env HOME=/usr/src/$FOLDER -- npm install lxc exec $CONTAINER -- chown -R $RUN_USER:$RUN_USER /usr/src/$FOLDER/node_modules fifi# build and run as a service if productionif [[ $PROFILES == *"pro"* ]]then if [[ $(lxc exec $CONTAINER -- /bin/bash -c 'if [ ! -f /etc/systemd/system/$CONTAINER.service ]; then echo 0; fi') ]] then printf "\n\n*** Creating service file ***" lxc exec $CONTAINER -- /bin/bash -c "cat &lt;&lt;-EOF &gt; /etc/systemd/system/$CONTAINER.service [Unit] Description=$CONTAINER [Service] WorkingDirectory=/usr/src/$FOLDER ExecStart=/usr/bin/node /usr/src/$FOLDER/index.js Restart=always RestartSec=10 StandardOutput=syslog StandardError=syslog SyslogIdentifier=$CONTAINER User=$RUN_USER Environment=HOME=/usr/src/$FOLDER Environment=NODE_ENV=production Environment=PORT=$PORT [Install] WantedBy=multi-user.targetEOF" lxc exec $CONTAINER -- systemctl enable $CONTAINER.service sleep 3.0s lxc exec $CONTAINER -- systemctl start $CONTAINER.service fifiprintf "\n" &amp;&amp; lxc list $CONTAINER# start app for devif [[ $PROFILES == *"default"* &amp;&amp; -z $(lxc exec $CONTAINER -- ps aux | grep /usr/src/$FOLDER/index.js) ]]then google-chrome $(lxc exec $CONTAINER -- bash -c "ifconfig | grep -o '[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;' | head -n 1") lxc exec $CONTAINER --env HOME=/usr/src/$FOLDER --env PORT=$PORT -- node index.jsfi]]></content>
      <tags>
        <tag>practice</tag>
        <tag>LXD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[net-expression]]></title>
    <url>%2F2018%2F06%2F28%2Fnet-expression%2F</url>
    <content type="text"><![CDATA[表达式目录树Expression编译之后不是生成的方法，不是一个委托 12345Func&lt;int,int,int&gt; func = (m,n) =&gt; m*n+2;Expression&lt;Func&lt;int,int,int&gt;&gt; exp = (m,n)=&gt; m*n+2;int iResult1 = func.Invoke(12,23);int iResult2 = exp.Compile().Invoke(12,23);]]></content>
      <tags>
        <tag>concept</tag>
        <tag>net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[net-linq]]></title>
    <url>%2F2018%2F06%2F28%2Fnet-linq%2F</url>
    <content type="text"><![CDATA[linq to Object, 是翻译成object，在内存里面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//分页的功能var list = studentList.Where(s=&gt;s.Age&lt;30) .Select(s =&gt; new &#123; Id = s.Id, ClassId = s.ClassId, IdName = s.Id + s.Name, ClassName = s.ClassId == 2? &quot;Advanced&quot;:&quot;Other&quot; &#125;) .OrderBy(s=&gt;s.Id) .OrderByDescending(s=&gt;s.ClassId) .Skip(2) //跳过几条 .Take(3); //获取几条//group&#123; var list = from s in studentList where s.Age &lt; 30 group s by s.ClassId into sg select new &#123; key = sg.Key, //sg.Key就是s.ClassId maxAge = sg.Max(t=&gt;t.Age) &#125;; //groupby new &#123;s.ClassId,s.Age&#125;&#125;//inner join&#123; var list = from s in studentList join c in classList on s.ClassId equals c.Id select new &#123; Name = s.Name, ClassName = c.ClassName &#125;;&#125;//left join&#123; var list = from s in studentList join c in classList on s.ClassId equals c.Id into scList from sc in scList.DefaultIfEmpty() select new &#123; Name = s.Name, ClassName = sc==null?&quot;无班级&quot;:sc.ClassName &#125;&#125;//left Join&#123; var list = studentList.Join(classList, s=&gt;s.ClassId, c=&gt;c.Id, (s,c)=&gt;new&#123; Name = s.Name, ClassName = c.ClassName &#125;).DefaultIfEmpty();&#125;]]></content>
      <tags>
        <tag>concept</tag>
        <tag>net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[net-yield]]></title>
    <url>%2F2018%2F06%2F28%2Fnet-yield%2F</url>
    <content type="text"><![CDATA[迭代器注意！yield是写在while里面的，且返回的是result!不是results! yield 是一个状态机，只有在真正调用的时候才会进到方法里面调用1234567891011121314151617181920212223242526272829303132333435363738394041//一次性把所有数据都计算好public IEnumerable&lt;int&gt; CommonMethod()&#123; List&lt;int&gt; results = new List&lt;int&gt;(); int counter = 0; int result = 1; while(counter++ &lt; 10) &#123; Thread.Sleep(1000); Console.WriteLine($&quot;获取&#123;counter&#125;次数据&quot;); result = result * 2; results.Add(result); &#125; return results;&#125;//按需获取 public IEnumerable&lt;int&gt; YieldMethod()&#123; int counter = 0; int result = 1; while(counter++ &lt; 10) &#123; Thread.Sleep(1000); Console.WriteLine($&quot;获取&#123;counter&#125;次数据&quot;); result = result * 2; yield return results; &#125;&#125;//callerIEnumerable&lt;int&gt; intListCommon = show.CommonMethod();//返回的是最终的结果IEnumerable&lt;int&gt; intListYield = show.YieldMethod();//这个时候返回的是一个状态机，不是最终的结果//只有在调用item的时候，才会真正走进去，且每次循环后是从while开始的！foreach(var item in intListYield)&#123;&#125; linq.NET里面linq其实也是用的yield方式实现的，只有在真正使用的时候才会去执行逻辑代码 比方说1var itemList = studentList.Where(x=&gt;x.Age &lt; 30); 但是如果用了ToList()，就会之u姐去执行逻辑代码1var itemList2 = studentList.Where(x=&gt;x.Age&gt;30).ToList();]]></content>
      <tags>
        <tag>concept</tag>
        <tag>net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zookeeper-basics]]></title>
    <url>%2F2018%2F06%2F27%2Fzookeeper-basics%2F</url>
    <content type="text"><![CDATA[概念zookeeper是一个分布式协调服务提供的服务涵盖：主从协调、服务器节点动态上下线、统一配置管理、分布式共享锁、统一名称服务… zookeeper可靠性很高，本身内部就是个集群，只要集群里面有半数以上的结点存活就可以提供服务 本质上zookeeper就只有两个功能：1，管理（存储，读取）用户提交的数据；2，并为用户程序提供数据节点监听服务； 安装tar -zxvf zookeeper.XXX.tar.gznano conf/zoo.cfgaddbin/zkServer.sh start]]></content>
      <tags>
        <tag>linux</tag>
        <tag>zookeeper</tag>
        <tag>pratice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[auto-deploy-scripts]]></title>
    <url>%2F2018%2F06%2F26%2Fauto-deploy-scripts%2F</url>
    <content type="text"><![CDATA[自己建yum源【centos系统】1，启一个httpd web service，不需要装tomcat这类，只需要一个静态的服务器即可2，检查httpd service service httpd status3，在/var/www/html下面创建一个目录挂载cdrom4，挂载目录指令为 mount -t iso9660 -o ro /dev/cdrom /mnt/cdrom41，如果iso盘中没有repodata,即没有dependecy link文件，需要手动创建 createrepo /mnt/cdromlocal42， 创建完repodata后，需要再生成一个iso文件 mkisofs -o /mnt/example.iso /mnt/cdromlocal/5，设置重启自动挂载 vi /etc/fstab 在文件尾部追加 /dev/cdrom /mnt/cdrom iso9660 defaults 0 06，在httpd html文件夹下面新建一个文件夹比方说叫centos，软链接指向这个mnt目录即可，假设mnt目录为/mnt/cdrom ln -s /mnt/cdrom /var/www/html/centos7，更改centos repo.d文件，指向这个yum源 vi /etc/yum.repos.d/xxx.repo 123456[base]name=CentOS-Localbaseurl=http://192.168.X.X/centosgpgcheck=1enabled=1 #很重要，1才启用gpgkey=file:///mnt/cdrom/rpm-gpg/RPM-GPG-KEY-CentOS-6 8，常用yum命令 yum clean all 清除所有缓冲数据 yum repolist 列出可用的yum源 yum deplist httpd 列出一个包所依赖的包 yum remove httpd 删除一个包 准备一个boot.sh脚本ssh-keygen -f 查看pem对应的private key ssh登陆所用的key pair存在.ssh/authorized_keys文件中，如果不小心删掉了，可以把private key的内容copy到authorized_keys文件，然后+空格+pem的名称，比如ssh-rsa XXXXXX linuxAAAA,之后再更改文件权限chmod 600 .ssh/authorized_keys ssh-keygen -f publickey.pem &gt;&gt; authorized.keys或者可以用这个命令写进去前半段key的内容 ssh-keygen -R hostname 删除known_hosts sudo yum install expect 模拟用户输入密码，yes等信息 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/bin/bashSERVERS="node-3.itcast.cn node-4.itcast.cn"PASSWORD=123456BASE_SERVER=172.16.203.100#auto_ssh_copy_id() &#123;# expect -c "set timeout -1;# spawn ssh-copy-id $1;# expect &#123;# *(yes/no)* &#123;send -- #yes\r;exp_continue;&#125;# *assword:* &#123;send -- $2\r;exp_continue;&#125;# eof &#123;exit 0;&#125;# &#125;";#&#125;##ssh_copy_id_to_all() &#123;# for SERVER in $SERVERS# do# auto_ssh_copy_id $SERVER $PASSWORD# done#&#125;#auto_ssh_login() &#123; expect -c "set timeout -1; spawn ssh -i /home/ec2-user/linuxSS.pem ec2-user@$1; expect &#123; *(yes/no)* &#123;send -- yes\r;exp_continue;&#125; eof &#123;exit 0;&#125; &#125;";&#125;ssh_login_to_all() &#123; for SERVER in $SERVERS do auto_ssh_login $SERVER done&#125;ssh_login_to_allfor SERVER in $SERVERSdo scp -i linuxSS.pem install.sh ec2-user@$SERVER:/home/ec2-user ssh -i linuxSS.pem ec2-user@$SERVER "sudo chmod u+x /home/ec2-user/install.sh;echo lalalal &gt;&gt; /home/ec2-use$done Install.sh如果用echo来写入到/etc/profile中，换行符不好弄&lt;&lt;类似于文件的重定向，就是写个文件进去，EOF就是文件的标志，末尾也要写个EOF进去，就相当于追加一个文件到/etc/profile的末尾 12345678910#!/bin/bashBASE_SERVER=172.16.203.100yum install -y wgetwget $BASE_SERVER/soft/jdk-XXXX.tar.gztar -zxvf jdk-XXXX.tar.gz -C /usr/localcat &gt;&gt; /etc/profile &lt;&lt; EOFexport JAVA_HOME=/usr/local/jdkXXXexport PATH=\$PATH:\$JAVA_HOME/binEOF]]></content>
      <tags>
        <tag>linux</tag>
        <tag>practice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-yum-web-package-storage]]></title>
    <url>%2F2018%2F06%2F25%2Flinux-yum-web-package-storage%2F</url>
    <content type="text"></content>
      <tags>
        <tag>linux</tag>
        <tag>practice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublimetext-usage]]></title>
    <url>%2F2018%2F06%2F25%2Fsublimetext-usage%2F</url>
    <content type="text"><![CDATA[Allow Alt+Drag in windowsI created a file “C:\Users\XX\AppData\Roaming\Sublime Text 3\Packages\User\Default (Windows).sublime-mousemap”, and put this in it: 1234567[ &#123; "button": "button1","modifiers": ["alt"], "press_command": "drag_select", "press_args": &#123;"by": "columns"&#125; &#125;,] restart Sublime]]></content>
      <tags>
        <tag>sublime</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[net-EventIOSerialize]]></title>
    <url>%2F2018%2F06%2F25%2Fnet-EventIOSerialize%2F</url>
    <content type="text"><![CDATA[EVENT假如现在有一个猫类型，它叫一声会引发一连串反应，诸如12345678910public class Cat&#123; public void Miao() &#123; new Neighbor().Awake(); new Dog().Bark(); new Mouse().Run(); new Baby().Cry(); &#125;&#125; 这样的写法会导致耦合性高，不易扩展，增加，减少或者调整顺序都会变得比较困难，最好是猫叫一声-&gt;触发一系列的动作 用委托的方法实现 1234567891011121314151617181920212223242526272829303132333435//这个MiaoEventHandler来指定一堆动作//委托MiaoEventHandler来定义动作，Cat就不管了，Cat就不依赖于里面的动作了public class Cat&#123; public Action MiaoEventHandler; public void MiaoAction() &#123; if(this.MiaoEventHandler != null) &#123; this.MiaoEventHandler.Invoke(); &#125; &#125;&#125;//callerstatic void Main(string[] args)&#123; &#123; //Event Cat cat = new Cat(); cat.Miao(); //委托的时候只能加方法名，而不是调用，所以不是Awake() //带有参数的方法的调用，就可以用lambda来完成 //这就是多播委托的一种使用，注意，多播委托是不适用于带返回值的委托的，因为到最后只会取最后一个委托的返回值！ cat.MiaoEventHandler += () =&gt; new Neighbor().Awake(123); cat.MiaoEventHandler += new Dog().Bark; cat.MiaoEventHandler += new Mouse().Run; cat.MiaoEventHandler += new Baby().Cry; cat.MiaoAction(); &#125;&#125; 用事件的方法实现 Event就是Action委托前面加event关键字，防止外部直接invoke和赋值，子类都没有办法Invoke 事件和委托的区别联系：事件是委托的实例，委托是一个类型，而事件是一个实例，委托类型的实例例：Student是一个类型，而Dashan是Student类型的一个实例 12345678public event Action MiaoEventHandlerEvent;public void MiaoActionEvent()&#123; if(this.MiaoEventHandlerEvent != null) &#123; this.MiaoEventHandlerEvent.Invoke(); &#125;&#125; 为什么要有event?就是为了这个MiaoEventHandler不能在外部被调用被赋值 在上面的那个例子，MiaoEventHandler是可以在中间被invoke和赋值的，比方说123456789cat.MiaoEventHandler += () =&gt; new Neighbor().Awake(123);cat.MiaoEventHandler += new Dog().Bark;//这样是可以的cat.MiaoEventHandler.Invoke();cat.MiaoEventHandler = null;cat.MiaoEventHandler += new Mouse().Run;cat.MiaoEventHandler += new Baby().Cry; 但是如果用了Event，就不可以在中间被赋值，只能在Cat类的MiaoActionEvent里面去调用 EVENT的应用事件的应用一定会有1，事件的发布者，在这里用来Invoke事件2，事件的订阅用户3，事件的注册 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586//这个是事件的发布者，只有事件的发布者才能Invoke这个事件public class iPhone8&#123; //EventHandler&lt;PriceChangeEventArgs&gt;是事件的委托类型， PriceChange是事件名称 public event EventHandler&lt;PriceChangeEventArgs&gt; PriceChange; protected virtual void OnPriceChanged(PriceChangeEventArgs e) &#123; if (this.PriceChange != null) &#123; this.PriceChange.Invoke(this, e); &#125; &#125; private decimal price; public decimal Price &#123; get &#123;return price;&#125; set &#123; if(price == value) return; decimal oldPrice = price; price = value; if(this.PriceChange != null) this.OnPriceChanged(new PriceChangeEventArgs(oldPrice, price)); &#125; &#125; &#125;//EventHandler是框架帮我们定义的，专门用来作事件用//sender是事件的触发者, e的类型是泛型，也就是TEventArgs类型，一般这个类型在定义的时候必须继承于EventArgspublic delegate void EventHandler&lt;TEventArgs&gt;(object sender, TEventArgs e);//EventArgs其实就是个空壳,但是你可以继承它之后自己自定义一些属性public class EventArgs&#123; public static readonly EventArgs Empty; public EventArgs();&#125;//PriceChangeEventArgspublic class PriceChangeEventArgs: EventArgs&#123; public int Id &#123;get;set;&#125; public readonly decimal OldPrice; public readonly decimal NewPrice; public PriceChangeEventArgs(decimal oldPrice, decimal newPrice) &#123; OldPrice = oldPrice; NewPrice = newPrice; &#125;&#125;//事件订阅者public class Businessman&#123; public void Iphone8_PriceChange(object sender, PriceChangeEventArgs e) &#123; Console.WriteLine(&quot;年终大促,iphone只卖&quot; + e.NewPrice + &quot;元！&quot;); &#125;&#125;//事件的注册public class EventRegister&#123; private iPhone8 _iphone = null; public void Init() &#123; this._iphone = new iPhone8(); Businessman businessman = new Businessman(); this._iphone.PriceChange += businessman.Iphone8_PriceChange; &#125; public void SetPrice(decimal price) &#123; this._iphone.Price = price; &#125;&#125; IO Serialize123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111//检查文件夹是否存在if(!Directory.Exists(LogPath))&#123; //一次性创建全部的子路径 DirectoryInfo directoryInfo = Directory.CreateDirectory(LogPath); //原文件夹会没有 Directory.Move(LogPath, LogMovePath); Directory.Delete(LogMovePath);&#125;//不能用这个检查文件夹是否存在Directory directory = new DirectoryInfo(LogPath);FileInfo fileInfo = new FileInfo(Path.Combine(LogPath,&quot;info.txt&quot;));if(!File.Exists(Path.Combine(LogPath, &quot;info.txt&quot;)))&#123; Directory.CreateDirectory(LogPath); //打开文件流（创建文件并写入） using(FileStream fileStream = File.Create(fileName)) &#123; string name = &quot;111&quot;; byte[] bytes = Encoding.Default.GetBytes(name); fileStream.Write(bytes, 0 , bytes.Length); fileStream.Flush(); &#125; //打开文件流（创建文件并写入）,这个File.Create会把之前的文件删掉，重新写 using(FileStream fileStream = File.Create(fileName)) &#123; StreamWriter sw = new StreamWriter(fileStream); sw.Write(&quot;123&quot;); sw.Flush(); &#125; //流写入器（创建/打开文件并写入） using(StreamWriter sw = File.AppendText(fileName)) &#123; string msg = &quot;Today is a good day.&quot;; sw.WriteLine(msg); sw.Flush(); &#125; //流写入器(创建/打开文件并写入) using(StreamWriter sw = File.AppendText(fileName)) &#123; string name = &quot;12312&quot;; byte[] bytes = Encoding.Default.GetBytes(name); sw.BaseStream.Write(bytes,0,bytes.Length); sw.Flush(); &#125; //读取, //一次性读所有的数据，不推荐 foreach(var result in File.ReadAllLines(fileName)) &#123; Console.WriteLine(result); &#125; string sResult = File.ReadAllText(fileName); Byte[] byteContent = File.ReadALlBytes(fileName); string sResultByte = System.Text.Encoding.UTF8.GetString(byteContent); //分批读取，比较好 using(FileStream stream = File.OpenRead(fileName)) &#123; int length = 5; int result = 0; do &#123; byte[] bytes = new byte[length]; result = stream.Read(bytes,0,5); for(int i=0; i&lt; result; i++) &#123; Console.WriteLine(bytes[i].TOString()); &#125; &#125; while(length == result); &#125;&#125;//写日志public static void Log(string msg)&#123; StreamWriter sw = null; try &#123; string fileName = &quot;log.txt&quot;; string totalPath = Path.Combine(LogPath, fileName); if(!Directory.Exists(LogPath)) &#123; Directory.Create(LogPath); &#125; sw = File.AppendText(totalPath); sw.WriteLine(string.Format(&quot;&#123;0&#125;:&#123;1&#125;&quot;,DateTime.Now,msg)); sw.WriteLine(&quot;**************************************&quot;)； &#125; catch(Exception ex) &#123; Console.WriteLine(ex.Message); &#125; finally &#123; if(sw != null) &#123; sw.Flush(); sw.Close(); sw.Dispose(); &#125; &#125;&#125; 画验证码123456789101112131415161718192021222324252627282930public static void Drawing()&#123; Bitmap bitmapobj = new Bitmap(100, 100); //在Bitmap上面创建一个新的Graphics对象 Graphics g = Graphics.FromImage(bitmapobj); //创建绘画对象，如Pen,Brush等等 Pen redPen = new Pen(Color.Red,8); g.Clear(Color.White); //绘制图形 g.DrawLine(redPen,50,20,500,20); //画椭圆 g.DrawEllipse(Pens.Black, new Rectangle(0,0,200,100)); //画弧线 g.DrawArc(Pens.Black,new Rectangle(0,0,100,100),60,180); //画直线 g.DrawLine(Pens.Black,10,10,100,100); //画矩形 g.DrawRectangle(Pens.Black,new Rectangle(0,0,100,200)); //画字符串 g.DrawString(&quot;I love coding&quot;,new Font(&quot;Arial&quot;,12),new SolidBrush(Color.Red),new PointF(10,10)); If(!Directory.Exists(ImagePath)) &#123; Directory.CreateDirectory(ImagePath); &#125; bitmapobj.Save(ImagePath+&quot;pic1.jpg&quot;,ImageFormat.Jpeg); bitmapobj.Dispose();//释放所有对象 g.Dispose();&#125;]]></content>
      <tags>
        <tag>concept</tag>
        <tag>.NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[net-delegate]]></title>
    <url>%2F2018%2F06%2F22%2Fnet-delegate%2F</url>
    <content type="text"><![CDATA[声明public delegate string WithReturnWithPara(int x, int y);没有方法体的方法声明+delegate 委托其实就是MulticastDelegate的一个子类，是一个类！ 1234567891011121314151617181920212223242526272829303132333435363738394041public delegate void NoReturnNoPara();public delegate void NoReturnWithPara(int x, int y);public delegate int WithReturnNoPara();public delegate void GenericDelegate(T x); //泛型委托public void Show()&#123; &#123; //2. 实例化委托，要求传入的签名一致的方法 NoReturnNoPara method = new NoReturnNoPara(this.DoNothing); //3. 委托实例的调用，参数和委托声明的时候参数一致 method.Invoke(); //4. 与上面的Invoke效果是一样的 method(); &#125; &#123; NoReturnWithPara method = new NoReturnWithPara(this.DoNothingWithPara); method.Invoke(1,2); &#125; &#123; WithReturnNoPara method = new WithReturnNoPara(this.GetNothing); int iResult = method.Invoke(); &#125;&#125;private void DoNothing()&#123; Console.WriteLine(&quot;This is DoNothing&quot;);&#125;private void DoNothingWithPara(int x, int y)&#123;&#125;private int GetNothing()&#123; return 1;&#125; ##.NET自带的一些委托类型 ####Action -&gt; 无返回值的委托12Action act = new Action(this.DoNothing);Action&lt;int,string,int,string&gt; act2 = null; ####Func -&gt; 带返回值的泛型委托，注意，最后一个泛型类型代表返回类型12Func&lt;int&gt; fun1 = new Func&lt;int&gt;(this.GetNothing);//返回一个int类型Func&lt;int,string&gt; fun2 = null; //接受一个int类型的参数，返回类型为string ####多播委托 -&gt;+=表示向一个委托实例里面添加多个方法，形成方法链，invoke的时候按添加顺序执行-=表示向一个委托实例里面移除方法，从方法链尾部开始匹配，遇到第一个完全吻合的，移除且只移除一个；没有匹配的不报错 如果是用lambda表达式来定义方法，那么永远都无法-=，因为编译器碰到lambda表达式，会自动生成一个委托，都是不同的实例 多播委托不适用于带返回值的委托&gt;带返回值的委托，因为到后面只会拿最后一个委托的返回值 1234567891011121314Action act = new Action(this.DoNothing);act += this.DoNothing;act += this.DoNothingStatic;act += new OtherClass().DoNothing;//act.BeginInvoke(null, null);//不能调用，因为不知道里面这么多实例应该按照什么顺序去执行foreach(Action item in act.GetInvocationList())&#123; item.BeginInvoke(null,null);&#125;act -= this.DoNothing;act -= this.DoNothingStatic;act -= new OtherClass().DoNothing; //你会发现这个方法没有被移除，原因是上面的act += new OtherClass()与这个是两个实例，不是同一个，所以没有移除 ##委托的使用12345678910111213141516171819private static List&lt;Student&gt; Where(List&lt;Student&gt; studentList, Func&lt;Student, bool&gt; func)&#123; list&lt;Student&gt; resultList = new List&lt;Student&gt;(); foreach(var student in studentList) &#123; if(func.invoke(student)) &#123; resultList.Add(student); &#125; &#125;&#125;//callerprivate static bool Equals(Student)&#123; return student.ClassId == 1;&#125; Func&lt;Student,bool&gt; func = new Func&lt;Student,bool&gt;(Equals);var list = Where(studentList, func);]]></content>
      <tags>
        <tag>concept</tag>
        <tag>.NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[net-oo]]></title>
    <url>%2F2018%2F06%2F22%2Fnet-oo%2F</url>
    <content type="text"><![CDATA[##封装就是写类 封装的好处: 保护属性，通过访问修饰符(public, private(只能自己访问，子类都不行),internal(只能这个程序集里面访问),protected(只能自己和子类访问)) 接口不变，可以随便扩展 代码重用，任何只要用了这个类都可以调用这个方法 ##继承，就是可以用父类的 ##多态：同一个东东运行的时候会展现不同的形态 继承多态： 12345//编译器编译的时候认为这三个都是People类型//但在运行的时候people, student, teacher是三种不同的类型People people = new People();People student = new Student();People teacher = new Teacher(); 编译时多态: 声明，接口 方法的重载(overload)也是多态 普通方法的调用 注意：`Parent ins = new Child(); ins.Method();`会调用的是父类方法，因为这是编译时确定的！！！ 运行时多态 抽象方法与虚方法的区别： 虚方法本身是一个普通方法，但是加了一个virtual，子类继承的时候可以覆写也可以不覆写 抽象方法没有方法体，必须在一个抽象类里面定义，子类继承后，必须显性的override掉这个抽象类 在override之前加sealed代表不想让它的子类再覆写 new这种写法尽量不要用！改成虚方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public abstract class ParentClass&#123; public int age = 70; public void CommonMethod() &#123; Console.WriteLine(&quot;ParentClass CommonMethod&quot;); &#125; //虚方法本身是一个普通方法，但是加了一个virtual //子类继承的时候可以覆写也可以不覆写 public virtual void VirtualMethod() &#123; Console.WriteLine(&quot;ParentClass VirtualMethod&quot;); &#125; public virtual void VirtualMethod(string name) &#123; Console.WriteLine(&quot;ParentClass VirtualMethod with string name&quot;); &#125; //抽象方法没有方法体，必须在一个抽象类里面定义 //子类继承后，必须显性的override掉这个抽象类 public abstract void AbstractMethod();&#125;public class ChildClass: ParentClass&#123; public int age = 18; //这里隐藏父类的CommonMethod,并没有覆盖掉 public new void CommonMethod() &#123; Console.WriteLine(&quot;ChildClass CommonMethod&quot;); &#125; public override void VirtualMethod() &#123; Console.WriteLine(&quot;ChildClass VirtualMethod&quot;); base.VirtualMethod(); &#125; public override void AbstractMethod() &#123; Console.WriteLine(&quot;ChildClass AbstractMethod&quot;); &#125;&#125;//callerpublic static void Test()&#123; ParentClass instance = new ChildClass(); //父类，age=70 Console.WriteLint(instance.age); //父类,编译的时候决定了普通方法的调用，只根据等号左边来看，ChildClass里面的new一点用都没有 instance.CommonMethod(); //子类，虽然最终调用的是父类，运行的时候决定了虚方法的调用 instance.VirtualMethod(); //子类,运行时决定了抽象方法的调用 instance.AbstractMethod();&#125; ##接口抽象类 什么方法适用于虚方法： 大家都有默认实现，只有少部分不同，建议采用虚方法其他用abstract方法： 抽象方法就是约束一下，但是不提供实现，子类必须override，且必须在抽象类里面 **抽象类是不能实例化的**，只能这么用 123456BasePhone iphone = new iPhone();public abstract class BasePhone&#123;&#125; 除了可以用抽象类来约束，也可以用接口来约束,接口方法默认都是public，且不能放字段（可以放属性）12345678910public interface IExtend&#123; void Online(); string Remark&#123;get;set;&#125; event Action DoNothingHandle; //索引器 string this[int index]&#123;get;set;&#125; //string description; 不能 //delegate xxx;不能&#125; 抽象类和接口区别，想约束东西的时候是用抽象类还是接口？ 抽象类可以包含一些已经实现的东西，然后可以再加上约束的功能，其主要是类，加上一点约束的功能，表明的主要是is a what 接口更灵活，一个类可以继承多个接口，纯粹的约束功能。只能表明can do what,不局限于是哪个类 工作中大部分用的都是接口，除非有些代码需要重用会要用抽象类]]></content>
      <tags>
        <tag>.NET</tag>
        <tag>concet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[net-attribute]]></title>
    <url>%2F2018%2F06%2F21%2Fnet-attribute%2F</url>
    <content type="text"><![CDATA[概念Attribute其实是为了生成MetaData的Attribute就是一个继承于Attribute的类 12345678910111213141516171819202122public class CustomAttribute: Attribute&#123; public CustomAttribute()&#123; Console.WriteLine(&quot;This is constructor of CustomAttribute&quot;); &#125; public CustomAttribute(string remark)&#123; &#125; public string Remark&#123;get;set;&#125; public string Description&#123;get;set;&#125; public void Show()&#123; Console.Writeline($&quot;This is &#123;this.GetType().Name&#125;&quot;); &#125;&#125;//也可以间接继承于Attributepublic class CustomChildAttribute: CustomAttribute&#123;&#125; Attribute默认情况下不能重复修饰 Attribute可以放在类，方法，属性，字段等很多地方，在[AttributeUsage(AttributeTargets.All, AllowMultiple=False)]中设置 [Custom] = [Custom()],代表默认用无参构造函数[Custom(&quot;This is a student&quot;, Remark=&quot;123&quot;, Description=&quot;567&quot;)] 构造函数的时候顺便把属性都赋值 使用特性在你不显式调用的时候，一点用都没有特性是通过反射来使用的12345678910111213141516171819202122232425262728293031323334353637383940///特性编译后是metadata，只有反射才能使用///public class PeopleManager&#123; public static void Manage(Student student)&#123; Type type = student.GetType(); //type.GetCustomAttributes会实例化这个特性 if(type.IsDefined(typeof(CustomAttribute),true))&#123; object item = type.GetCustomAttributes(typeof(CustomAttribute),true)[0]; CustomAttribute attribute = item as CustomAttribute; attribute.Show(); &#125; foreach(var item in type.GetConstructors())&#123; if(item.IsDefined(typeof(CustomAttribute),true))&#123; object ii = item.GetCustomAttributes(typeof(CustomAttribute),true)[0]; &#125; &#125; MethodInfo method = type.GetMethod(&quot;Answer&quot;); if(method.IsDefined(typeof(CustomAttribute),true))&#123; object item = method.GetCustomAttributes(typeof(CustomAttribute),true)[0]; &#125; foreach(var item in method.GetParameters())&#123; &#125; if(method.ReturnParameter.IsDefined(typeof(CustomAttribute),true))&#123; &#125; student.Study(); student.Answer(&quot;SS&quot;); &#125;&#125; 实战12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Student&#123; [AuthoritytAttribute(Remark=&quot;Answer Questions&quot;)] [Custom] [return: Custom] public string Answer([Custom]string name)&#123; return $&quot;This is &#123;name&#125;&quot; &#125;&#125;public class AuthoritytAttribute:Attribute&#123; public string Remark &#123;get;set;&#125; public bool IsLogin()&#123; return new Random().Next(100,200) &gt; new Random().Next(100,199); &#125;&#125;public class PeopleManager&#123; public static void Manage(Student student)&#123; //Attribute可以增加功能，也可以多一点信息（Remark) Type type = typeof(Student); MethodInfo method = method.GetMethod(&quot;Answer&quot;); if(method.IsDefined(typeof(AuthoritytAttribute),true))&#123; object item = type.GetCustomAttributes(typeof(AuthoritytAttribute),true)[0]; AuthoritytAttribute attribute = item as AuthoritytAttribute; Console.WriteLine(attribute.Remark); // if(DateTime.Now &gt; DateTime.Now.AddDaus(1))//实际上可以使用HttpContext.Current.Cookie/Session来检查用户登陆信息 // &#123; // throw new Exception(&quot;Not authorized&quot;); //redirect to login page // &#125; //将权限认证放到了attribute中 if(!attribute.IsLogin())&#123; throw new Exception(&quot;Not authorized&quot;); &#125; &#125; student.Answer(&quot;SS&quot;); &#125; &#125;//Callerclass Program&#123; static void Main(string[] args)&#123; Student studnet = new Student(); //这个方法调用是不会call AuthorityAttribute的 student.Answer(&quot;SS&quot;); //这样写才会支持AuthorityAttribute PeopleManager.Manage(student); &#125;&#125; 实例12345678910111213141516171819202122232425262728293031323334353637383940414243[AttributeUsage(AttributeTargets.Enum | AttributeTargets.Field)]public class RemarkAttribute: Attribute&#123; public RemarkAttribute(string remark) &#123; this.Remark = remark; &#125; public string Remark&#123;get;set;&#125;&#125;[Remark(&quot;用户状态&quot;)]public enum UserState&#123; [Remark(&quot;正常&quot;)] Normal = 0, [Remark(&quot;冻结&quot;)] Forzen = 1, [Remark(&quot;删除&quot;)] Deleted = 2&#125;public class RemarkExtend&#123; //扩展方法 public static string GetRemark(this Enum enumValue)&#123; Type type = enumValue.GetType(); FieldInfo field = type.GetField(enumValue.ToString()); if(field.IsDefined(typeof(RemarkAttribute),true))&#123; RemarkAttribute remarkAttribute = (RemarkAttribute)field.GetCustomAttribute(typeof(RemarkAttribute)); return remarkAttribute.Remark; &#125;else&#123; return enumValue.ToString(); &#125; &#125;&#125;//callerpublic void Main(string[] args)&#123; UserState.Deleted.GetRemark();&#125;]]></content>
      <tags>
        <tag>concept</tag>
        <tag>.NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文本处理sed,awk,cut,sort]]></title>
    <url>%2F2018%2F06%2F20%2Flinux-file-processing-commands%2F</url>
    <content type="text"><![CDATA[CUTCUT命令可以从一个文本文件或者文本流中提取文本echo $PATH | cut -d &#39;:&#39; -f 2,3将PATH变量取出，返回第二，第三个路径echo $PATH | cut -d &#39;:&#39; -f 1-3,5取1~3和第五个 SORT对FILE参数制定的文件中的行排序，并将结果写到标准输出1234567891011121314151617181920212223242526272829303132333435363738394041[root@ip-172-31-7-202 ec2-user]# cat /etc/passwdroot:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologinsync:x:5:0:sync:/sbin:/bin/sync[root@ip-172-31-7-202 ec2-user]# cat /etc/passwd | sortadm:x:3:4:adm:/var/adm:/sbin/nologinbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologindbus:x:81:81:System message bus:/:/sbin/nologinec2-user:x:500:500:EC2 Default User:/home/ec2-user:/bin/bash[root@ip-172-31-7-202 ec2-user]# cat /etc/passwd | sort -t ':' -k 3 //以：为分隔符，以第三列字符串模式为排序标准root:x:0:0:root:/root:/bin/bashuucp:x:10:14:uucp:/var/spool/uucp:/sbin/nologinoperator:x:11:0:operator:/root:/sbin/nologinbin:x:1:1:bin:/bin:/sbin/nologin[root@ip-172-31-7-202 ec2-user]# cat /etc/passwd | sort -t ':' -k 3n //以第三列数字模式排序root:x:0:0:root:/root:/bin/bashbin:x:1:1:bin:/bin:/sbin/nologindaemon:x:2:2:daemon:/sbin:/sbin/nologinadm:x:3:4:adm:/var/adm:/sbin/nologinlp:x:4:7:lp:/var/spool/lpd:/sbin/nologin[root@ip-172-31-7-202 ec2-user]# cat /etc/passwd | sort -t ':' -k 3nr //倒序排列nfsnobody:x:65534:65534:Anonymous NFS User:/var/lib/nfs:/sbin/nologinec2-user:x:500:500:EC2 Default User:/home/ec2-user:/bin/bashsaslauth:x:499:76:"Saslauthd user":/var/empty/saslauth:/sbin/nologinnobody:x:99:99:Nobody:/:/sbin/nologin[root@ip-172-31-7-202 ec2-user]# cat /etc/passwd | sort -t ':' -k 7 -u //去重root:x:0:0:root:/root:/bin/bashsync:x:5:0:sync:/sbin:/bin/synchalt:x:7:0:halt:/sbin:/sbin/haltbin:x:1:1:bin:/bin:/sbin/nologinshutdown:x:6:0:shutdown:/sbin:/sbin/shutdown uniquniq只能去重排序过的文件1234cat testfile | sort | uniq -c //-c显示重复次数1 friend3 hello2 world 取出处于ESTABLISHED状态的端口号1netstat -an | grep ':4001\|:4002\|:4003\|:4004' | grep ESTABLISHED | awk &#123;'print $4'&#125; | uniq | cut -d ':' -f 2 sed删除：d命令sed -i &#39;2d&#39; example 删除example文件的第二行并写会原文件，不建议刚开始就用-i写回文件，调试完了以后再加-ised &#39;2,$d&#39; example 删除example文件的第二行到末尾所有行，正则中$表示末尾，^表示开头sed &#39;$d&#39; example 删除example文件的最后一行sed &#39;/test/&#39;d example 删除example文件所有包含test的行,//代表模式 替换：s命令sed &#39;s/test/mytest/g&#39; example 在整行范围内把test替换成mytest，如果没有g标记，则只有每行第一个匹配的test会被替换成mytestsed -n &#39;s/^test/mytest/p&#39; example (-n)选项和p标志一起使用表示只打印那些发生替换的行。也就是说如果某一行开头的test被替换成mytest，就打印它。sed &#39;s/^192.168.0.1/&amp;localhost/&#39; example &amp;符号表示替换字符串被找到的部分再加上新的。所有以192.168.0.1开头的行都会被替换成它自己加localhost，即192.168.0.1localhost。sed -n &#39;s/\(love\)able/\1rs/p&#39; example love被标记为1，所有loveable会被替换成lovers，且替换的行会被打印出来，\1代表第一组 awklast -n 5 | awk &#39;{print $1}&#39; 打印出第一列的登录人名awk工作流程：读入有’\n’换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，$0表示所有域，$1表示第一个域，$n表示第n个域。默认域分隔符是”空白键”或者”[tab]键”,所以$1表示登录用户，$3表示登录用户ip,以此类推 cat /etc/passwd | awk -F &#39;:&#39; &#39;{print $1&quot;\t&quot;$7}&#39;指定分隔符,且账户与shell之间以tab键分割 cat /etc/passwd | awk -F &#39;:&#39; &#39;BEGIN {print &quot;name,shell&quot;} {print $1&quot;,&quot;$7} END {print &quot;endtest,/bin/bash&quot;}&#39;awk还可以分Begin 中间 End三个部分 lxc list | awk &#39;NR &gt; 2 { print $6}&#39;去除首行，拿取第6列 1234567891011121314151617181920212223242526272829[root@ip-172-31-7-202 ec2-user]# cat /etc/passwd | awk -F ':' 'BEGIN &#123;print "name,shell"&#125; &#123;print $1","$7&#125; END &#123;print "endtest,/bin/bash"&#125;'name,shellroot,/bin/bashbin,/sbin/nologindaemon,/sbin/nologinadm,/sbin/nologinlp,/sbin/nologinsync,/bin/syncshutdown,/sbin/shutdownhalt,/sbin/haltmail,/sbin/nologinuucp,/sbin/nologinoperator,/sbin/nologingames,/sbin/nologingopher,/sbin/nologinftp,/sbin/nologinnobody,/sbin/nologinrpc,/sbin/nologinntp,/sbin/nologinsaslauth,/sbin/nologinmailnull,/sbin/nologinsmmsp,/sbin/nologinrpcuser,/sbin/nologinnfsnobody,/sbin/nologinsshd,/sbin/nologindbus,/sbin/nologinec2-user,/bin/bashmysql,/bin/bashendtest,/bin/bash]]></content>
      <tags>
        <tag>concept</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell 基本语法]]></title>
    <url>%2F2018%2F06%2F20%2Fshell-basic%2F</url>
    <content type="text"><![CDATA[. ./test.sh 两个点的含义12#!/bin/bashaa = "hello" 如果echo $aa是没有东西的，为什么？ 当只运行一个 ./test.sh 的时候,其实是test.sh是在别的进程里面跑的，所以你在当前进程里跑的时候是不会输出东西的所以用. ./test.sh是说在我现在这个进程里面来跑这个脚本 变量定义1，系统变量：$HOME、$PWD、$SHELL(现在用的是哪种解释器)、$USER(当前用户)等 2，查看所有变量:`set` 3，定义变量：VAR=value，&lt;span style=&quot;color:red;&quot;&gt;等号两侧不能有空格&lt;/span&gt;，变量名称一般为大写 4，双引号与单引号的区别：双引号仅将空格脱意，单引号会将所有特殊字符脱意(单引号里面用变量引用没有用) 1234567891011X=helloecho $X -&gt; helloX="hello world"echo $X -&gt; hello worldX='hello\nworld'echo $X -&gt; hello\nworldY=abcX='hello $Y'echo $X -&gt; hello $YX="hello $Y"echo $X -&gt; hello abc 5，撤销变量：unset X 6，export：可以把变量提升为全局环境变量，所有连上去的BASH都能访问，否则只在当前的bash能用 7，&lt;span style=&quot;color:red;&quot;&gt;把当前command的结果赋予另一个变量&lt;/span&gt; 1，用A=`ls -la`反引号的形式 2，用A=$(ls -la)，等价于上面的方式 1234X="Hello;World;SS"echo $X | cut -d ";" -f2 //拿到以；为分隔符切分的第二个元素Y=`echo $X | cut -d ";" -f2`echo $Y -&gt; World 8，Shell中的特殊变量 1，$? 上一个命令执行的状态，类似与方法的返回值，通常情况下返回值为0代表成功，非0代表不正常 12345678trueecho $? -&gt; 0falseecho $? -&gt; 1llecho $? -&gt; 0lsssecho $? -&gt; 127 2，$$ 表示当前进程号 3，$0 表示当前脚本名称 4，$N 表示N位置的输入参数 12345678#!/bin/bashaa="hello"echo "第一个参数="$1echo "第二个参数="$2./test.sh hello world第一个参数=hello第二个参数=world 5，$# 表示参数的个数，常用于循环 6，$*和$@都表示参数列表 &quot;$*&quot;会将所有的参数作为一个整体，以&quot;$S1$S2...$Sn&quot;的形式输出 &quot;$@&quot;会将各个参数分开，以&quot;$S1&quot;&quot;$S2&quot;...&quot;$Sn&quot;的形式输出 123456789101112#!/bin/bashecho $*echo $@for N in "$*"doecho $Ndonefor N in "$@"doecho $Ndone 运算符格式：expr m+n 或者 $((m+n)) 注意expr运算符间要有空格例如（2+3）*41S=`expr 2+3`\*4 或者 $(((2+3)*4)),最外层的$()代表取其值 for循环12345678910for N in 1 2 3do echo $Ndone或者 for N in &#123;1..3&#125;;do echo $N;done或者for ((i=0;i&lt;=5;i++)) //必须要是两层括号do echo "welcome $i times"done while循环1234567891011while expressiondo commanddone或者int=1while ((int&lt;=3))do echo $int let int++done case语句12345678910case $1 instart) echo "starting" ;;stop) echo "stoping" ;;*) echo "Usage:&#123;start|stop&#125;"esac read命令1234read -p "please enter a number: " numbplease enter a number: 1echo $numb1 if123456789if [ $NAME=root ]then echo "hello $&#123;NAME&#125;"elif [ $NAME=itcast ] then echo "hello $&#123;NAME&#125;"else echo "OUT"fi [ condition ]一定要前后有空格，空[ ]则返回1，即false 判断语句[ condition ] &amp;&amp; echo OK || echo notok= 字符串比较-lt 小于-le 小于等于-eq 等于-gt 大于-ge 大于等于-ne 不等于-r 有读的权限-w 有写权限-f 文件存在并且是一个常规的文件-s 文件存在且不为空-d 文件存在并且为一个目录-b 文件存在并且是一个块设备-L 文件存在并且是一个链接 Shell 自定义函数12345678910111213141516171819202122[ function ] funname [()]&#123; action; [return int;]&#125;例如可以这样定义function start() / function start/ start()函数只能返回int类型如果要传入参数，需要在外面定义!#/bin/bashfunction fSum()&#123; echo $1,$2; return $(($1+$2));&#125;fSum 3 2;total=$?;fSum 5 7;total=$?;echo $total, $?; 脚本调试sh -vx helloWorld.sh 只会展现所有的执行状态，不会停 模拟用户输入123456789101112131415161718auto_ssh_copy_id() &#123; expect -c "set timeout -1; spawn ssh-copy-id $1; expect &#123; *(yes/no)* &#123;send -- yes\r;exp_continue;&#125; *assword:* &#123;send -- $2\r;exp_continue;&#125; eof &#123;exit 0;&#125; &#125; ";&#125;ssy_copy_id_to_all() &#123; for SERVER in $SERVERS do auto_ssh_copy_id $SERVER $PASSWORD done &#125;]]></content>
      <tags>
        <tag>concept</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css-basic]]></title>
    <url>%2F2018%2F06%2F16%2Fcss-basic%2F</url>
    <content type="text"><![CDATA[布局(传统display+position+float)Display1, block占一行 默认block的元素有： div p ul ol li h1 h2 h3 h4 h5 h62, inline只占其content的尺寸，如果没有content，就不会显示3， inline-block是inline的布局，就是都挤在一行（对外的表现），对内表现为block,就是可以像block元素一样设置宽高等（盒模型数据） Position1, static 就是默认的元素定位2, relative 相对于自己原本的位置,比方说几次方这个东西，就可以用relative来做 如果你不给Relative设置top left bottom right, 就相当于什么也没发生过，它就是默认的位置 另外如果你设置了它为relative，就相当于给予了它z-index的能力 12345.square &#123; position: relative; top : -1px; left : 1px;&#125; 3, absolute 完全绝对定位，一样可以设置top left bottom right,但是这些值是以其找到的最近的非static父元素为基准。 如果没有这样的父元素， 它就会以&lt;html&gt;为父元素. 关于absolute与relative: 4, fixed 基于window的绝对定位，不随页面滚动发生改变 Margin缩写三种：123margin: top right bottom leftmargin: (top/bottom) (right/left)margin: top (right/left) bottom Float &amp; Clearfloat元素只占自己元素的大小，如果只让一边float会发现原本应该另起一行的div会浮动到其左边 如果第二个元素也变为float，父元素会消失 Clear property specifies what elements can float beside the cleared element and on which side. * none - Allows floating elements on both sides(default) * left/right - No floating elements allowed on the left/right side * inherit - Inherits the clear value of its parent 如果一个元素float left，然后你定义clear to the left. Floated元素会集序float, 但是cleared 元素会显示在下方。 如果一个floated元素比它的父节点要高,它就会overflow出去，如下： 这个时候就要用clearfix 来撑起父元素的高度 12345.clearfix::after&#123; content:""; clear:both; display:block;&#125; Pseudo-elements(selector::pseudo-element)可以被用作 * Style the first letter, or line, of an element * Insert content before, or after, the **content** of an element ::before/::after can be used to insert some content before/after the content of an element. 123h1::before&#123; content:url(smiley.gif);&#125; 居中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt; Container &lt;/title&gt; &lt;style type="text/css"&gt; body &#123; margin: 0px; font-family: 'Open Sans', sans-serif; &#125; .bg &#123; position: absolute; height: 100%; width:100%; &#125; .centered &#123; position: fixed; width: 100%; top: 40%; &#125; .centered div a div &#123; display: block; width: 120px; text-align: center; font-size: 12px; &#125; .centered a &#123; text-decoration: none; &#125; .in &#123; display: inline-block; text-align: center; margin: 0px 10px 0px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="bg"&gt; &lt;div class="centered in"&gt; &lt;div class="in"&gt; &lt;a href="" target="_blank"&gt; &lt;img src="https://omni.annalect.com/static/i/ico/lg/digital-inventory.png"&gt; &lt;div&gt; Campaign Reporting &lt;/div&gt; &lt;/img&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class="in"&gt; &lt;a href="" target="_blank"&gt; &lt;img src="https://omni.annalect.com/static/i/ico/lg/digital-inventory.png"&gt; &lt;div&gt; Campaign Reporting &lt;/div&gt; &lt;/img&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class="in"&gt; &lt;a href="" target="_blank"&gt; &lt;img src="https://omni.annalect.com/static/i/ico/lg/digital-inventory.png"&gt; &lt;div&gt; Campaign Reporting &lt;/div&gt; &lt;/img&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; Flex布局[Ref:http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html] Flex是Flexible Box的缩写，意思为“弹性布局”，为盒模型提供了很大的灵活性任何一个容器都可以指定为Flex布局设为Flex布局以后，子元素的float,clear和vertical-align属性将失效 flex基本概念container: 采用flex布局的元素，称为flex容器flex-item: container里面所有的子元素自动成为容器成员main axis: 水平主轴。主轴的开始位置（与边框的交叉点）称为main start,结束位置为main endcross axis: 垂直交叉轴。开始位置为cross start,结束位置为cross end container属性flex-direction决定主轴的方向，就是项目的排列方向123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; * row(默认值)：主轴为水平方向，起点在左端 * row-reverse：主轴为水平方向，起点在右端 * column：主轴为垂直方向，起点在上沿 * column-reverse：主轴为垂直方向，起点在下沿 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; * nowrap(默认)：不换行 {%asset_img flex-nowrap.png%} * wrap:换行，第一行在上方 {%asset_img flex-wrap.jpg%} * wrap-reverse:换行，第一行在下方 {%asset_img flex-wrap-reverse.jpg%} flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; justify-content属性justify-content属性定义了项目在主轴上的对齐方式。123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; * flex-start（默认值）：左对齐 * flex-end：右对齐 * center： 居中 * space-between：两端对齐，项目之间的间隔都相等。 * space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性align-items属性定义项目在交叉轴上如何对齐。 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; * flex-start：交叉轴的起点对齐。 * flex-end：交叉轴的终点对齐。 * center：交叉轴的中点对齐。 * baseline: 项目的第一行文字的基线对齐。 * stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; * flex-start：与交叉轴的起点对齐。 * flex-end：与交叉轴的终点对齐。 * center：与交叉轴的中点对齐。 * space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 * space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 * stretch（默认值）：轴线占满整个交叉轴。 ##item属性 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。123.item &#123; order: &lt;integer&gt;;&#125; flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; flex-basic属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。1234.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; ##例子，用flex来垂直居中12345&lt;div class="parent"&gt; &lt;div&gt;Hello!&lt;/div&gt; &lt;div&gt;&lt;p&gt;Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Vestibulum tortor quam, feugiat vitae, ultricies eget, tempor sit amet, ante. Donec eu libero sit amet quam egestas semper. Aenean ultricies mi vitae est. Mauris placerat eleifend leo. Quisque sit amet est et sapien ullamcorper pharetra.&lt;/p&gt;&lt;/div&gt; &lt;div&gt;&lt;img src="https://davidwalsh.name/wp-content/themes/punky/images/logo.png" style="display: inline;"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213.parent &#123; height:100vh;//very important! display: flex; justify-content:center; align-items: center;&#125;div&gt;p&#123; padding:1em; box-sizing:border-box; display:flex; border:solid; margin:10px;&#125; CSS UnitsAbsolute Lengths Units Description cm centimeters mm milimeters in inches (1in = 96px = 2.54cm) px * pixels (1px = 1/96th of 1in) pt points (1pt = 1/72 of 1in) pc picas (1pc = 12 pt) Relative Lengths Unit Description em Relative to the font-size of the element (2em means 2 times the size of the current font) ex Relative to the x-height of the current font (rarely used) ch Relative to width of the “0” (zero) rem Relative to font-size of the root element vw Relative to 1% of the width of the viewport* vh Relative to 1% of the height of the viewport* vmin Relative to 1% of viewport’s* smaller dimension vmax Relative to 1% of viewport’s* larger dimension % Relative to the parent element Selector12345678&lt;div id="container"&gt; &lt;p&gt;First&lt;/p&gt; &lt;div&gt; &lt;p&gt;Child Paragraph&lt;/p&gt; &lt;/div&gt; &lt;p&gt;Second&lt;/p&gt; &lt;p&gt;Third&lt;/p&gt; &lt;/div&gt; SpaceDescendant selector.Target all p tags within container div.例123div#container p&#123; font-weight:bold;&#125; ‘&gt;’SignTarget elements which are DIRECT children of a particular element. 123div#container &gt; p &#123; border: 1px solid black;&#125; This will target all P element within container div, but not children of child div ‘+’ SignThis is adjacent sibling combinator. It combines two sequences of simple selectors having the same parent and the second one must come IMMEDIATELY after the first. 只会影响到第二个simbling 123div + p &#123; color: green; &#125; 只会选择div后面紧连着的第一个p，且这个div和p是同级的（共享同一个父亲），也就是说包着Child Paragraph的div，和second的p是同级的 ‘~’SignSimilar to ‘+’ but the difference is that the second selector does NOT have to immediately follow the first one. It will select all elements that is preceded by the former selector. 123div ~ p&#123; background-color:blue;&#125;]]></content>
      <tags>
        <tag>concept</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-basic]]></title>
    <url>%2F2018%2F06%2F14%2Flinux-basic%2F</url>
    <content type="text"><![CDATA[VMWARE NAT 虚拟网络的配置介绍NAT是借助NAT（网络地址转换）通过物理机器的网络访问外网。其实这里的NAT就相当于路由器，它把虚拟机发到虚拟网卡的包进行地址转换后再发到实际的网络上。这个时候虚拟网段就可以和物理网段不一样。 VMWARE会自己生成一个虚拟的路由器，这个路由器的IP地址一般就是子网的网关地址和DNS地址。DNS地址也可以设置成一些知名的DNS服务器地址，例如google的8.8.8.8 VMWARE在windows上面也会虚拟出一个VMWARE用的网卡，例如vmnet8,如果想让windows可以与虚拟机子连接，就设置成同一个子网的IP即可 桥接模式Bridge桥接模式一个重要的特点就是虚拟网卡和物理网卡是处于同一个网段的，比方说你物理网卡的网段是10.22.0.0/16，那么你的虚拟网卡也是10.22.0.0/16，由于物理机与虚拟机处于同一个子网，可以被子网内其他机器感知到，且这个时候物理网卡会接受包括自己的数据包和虚拟网卡的数据包。物理网卡收到数据再将数据转发至虚拟网卡内部。 网桥类似于Hub任何机子连上来都属于同一网段，共用同一个IP段，虚拟机可以跟物理机相互ping通，所以物理机如果使用了这个IP，虚拟机不能再使用这个IP，没有隔离 所有的网络请求都要经过网桥（包括windows内部的请求），网桥然后连接物理网卡再跟真正的网络相连 如果路由器的物理IP变了，就要所有IP的都手动改变，所以这种模式不太推荐 首先需要在虚拟机的Machine Settings里面更改网络配置为桥接模式 常用命令[centos 6.7]网络方面 netstat -nltplist all listening programs and their port setup进入图形界面更改配置 vi /etc/sysconfig/network修改主机名 12NETWORKING=yesHOSTNAME=server1.itcast.cn vi /etc/sysconfig/network-scripts/ifcfg-eth0修改IP地址 1234567DEVICE = "eth0"TYPE = "Ethernet"ONBOOT = "yes" #是否网卡开机启用BOOTPROTO = "static"IPADDR = "192.168.11.200"NETMASK = "255.255.255.0"GATEWAY = "192.168.11.2" service network restart vi /etc/hosts修改ip地址和主机名的映射关系 如果设置完以后仍无法上网[https://blog.csdn.net/love666666shen/article/details/78087862]：1, VMWare Edit -&gt; Virtual Network Editor 2, Delete VMnet8/Vmnet0, recreate those two network with same settings as you set in the linux. 记得保存之前的子网IP和掩码信息3, Check Windows Services -&gt; VMware DHCP Service/VMware NAT Service/VMware Workstation Server重新开启运行一下，并重启虚拟机 4, 在Windows中进入Vmnet8-&gt; IPV4 Settings -&gt;自动获取IP地址和DNS地址 5, 重启虚拟机，如果还是无法连接，在linux系统里面重新建一个Wired Connetion,然后来回切换一下网络 添加iptables, open port 1234service iptables statusservice iptables startservice iptables status iptables -nL --line-numbers iptables -I INPUT -p tcp --dport 8080 -j ACCEPT删除第八行rule：iptables -D INPUT 8 日常操作命令pwd 查看当前所在目录date 查看当前系统时间who 查看当前有谁在线，登陆了服务器last 查看最近的登陆历史记录ls -al 查看隐藏文件以及更详细的信息，以列表形式显示mkdir -p aaa/bbb 如果子目录没有，一并创建touch filename 创建文件vi 编辑 A 在该行的最后插入 a 在该行最前面插入 gg 直接跳到文件的首行 G 直接跳到文件的末行 dd 删除行，如果8dd，则一次性删除8行 yy 复制当前行，3yy复制3行 p 粘贴 /YOU 查找文件中出现的YOU并定位到第一个找到的地方 #####文件权限的操作drwxr-xr-x（也可以用二进制表示111 101 101，即十进制755） d: 标识节点类型（d:文件夹 -：文件 l:链接）r:可读w:可写（删除文件并不代表你修改了这个文件，所以即使对这个文件没有写权限，也是可以删除的，删除其实是改变了父目录的内容，只要它上层directory有写权限，你就是可以删除的）x:可执行（可不可以当一个程序来运行）第一组rwx： 表示拥有者对它的权限第二组rwx: 表示所属组对它的权限第三组rwx： 上面用户之外的用户对它的权限 chmod o-rw xx.file让其他人没有read write的权限也可以用二进制的方法来写：chmod -R 700 xxxDirectorychown -R angela:angela aaa/更改所有者，必须用root才能改 修改文件名rename .repo .repo.bak * 对当前目录下所有以.repo结尾的文件，改为以.repo.bak结尾的文件 基本用户管理useradd angela 添加用户passwd angela 设置密码vi /etc/sudoers -&gt; 将用户加入到sudoers中 12root ALL=(ALL) ALLnewuser ALL=(ALL) ALL su angela 切换到angelaexit 退出angela getent group admin 查看所有admin group下面的用户groups ming.ming 查看mingming属于哪些group /etc/group文件包含所有组,格式如下：group_name:passwd:GID:user_list/etc/shadow和/etc/passwd系统存在的所有用户名 系统命令hostname 查看主机名 hostname hadoop 修改主机名，重启后无效 vi /etc/sysconfig/network 修改主机名，重启后永久生效 ifconfig eth0 192.168.11.22 修改IP，重启后无效 vi /etc/sysconfig/network-scripts/ifcfg-eth0 修改IP，重启后永久生效 uname -a uname -r 查看系统信息/内核版本 date +%Y-%m-%d 日期 mount -t iso9660 -o ro /dev/cdrom /mnt/cdrom 挂载外部存储设备到文件系统中，其中这个存储type为iso，让其readonly，光驱设备名称 /dev/cdrom 挂载到/mnt/cdrom这个目录 unmount /mnt/cdrom 弹出 du -sh /mnt/cdrom 统计文件夹的大小df -h 查看分区 halt 关机 mkisofs -o /home/linuxlookup/example.iso /source/directory/ 生成iso文件 createrepo /var/www/html/repo 生成repodata链接文件，否则本地yum无法安装 开机挂载光盘12vi /etc/fstab/dev/cdrom /mnt/cdrom iso9660 defaults 0 0 ln -s /mnt/cdrom ./centos 生成软链接 ssh免密登陆ssh-keygen 生成密钥对 ssh-copy-id 192.168.11.222 就会自动把公钥copy到192.168.11.222这个机子的.ssh/authorized_keys文件夹中 查看文件tail -10 install.log 查看文件尾部的10行tail -f install.log 实时输出文件尾部内容，小f跟踪文件的唯一inode号，就算文件改名后，还是跟踪原来这个inode表示的文件tail -F install.log 大F按照文件名跟踪 后台服务service --status-all 系统中现在所有的后台服务service network stop/start/restartchkconfig 查看所有服务自启配置chkconfig iptables off 关掉指定服务的自动启动 上传文件到服务器在secureCRT中使用sftp工具:alt+p调出后用put命令上传put xxx要上传的文件 上传到服务器当前目录lcd 指定下载到本地的目标路径get xxx要下载的文件 下载 解压打包文件gzip xxxfile 压缩文件成为.gz格式gzip -d 解压gz文件 tar -cvf myfirstpackage.tar directory/ 将directory目录打包到myfirstpackage.tar文件中-c create -v show detail -f file tar -xvf myfirstpackage.tar 解包文件 一次性完成打包&amp;压缩tar -zcvf my.tar.gz directory/tar -zxvf my.tar.gz -C d2/ 解压到指定目录下 安装文件0, 更改Mirror到清华 yum [https://mirror.tuna.tsinghua.edu.cn/help/centos/]： 首先备份CentOS-Base.repo sudo mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak 然后vi /etc/yum.repos.d/CentOS-Base.repo 将下面的写到文件中(CentOS6): 12345678910111213141516171819202122232425262728293031323334353637383940414243# CentOS-Base.repo## The mirror system uses the connecting IP address of the client and the# update status of each mirror to pick mirrors that are updated to and# geographically close to the client. You should use this for CentOS updates# unless you are manually picking other mirrors.## If the mirrorlist= does not work for you, as a fall back you can try the# remarked out baseurl= line instead.##[ base]name=CentOS-$releasever - Basebaseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/os/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=osgpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7#released updates[updates]name=CentOS-$releasever - Updatesbaseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/updates/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=updatesgpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7#additional packages that may be useful[extras]name=CentOS-$releasever - Extrasbaseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/extras/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=extrasgpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7#additional packages that extend functionality of existing packages[centosplus]name=CentOS-$releasever - Plusbaseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/centosplus/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=$releasever&amp;arch=$basearch&amp;repo=centosplusgpgcheck=1enabled=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 然后更新软件包缓存 sudo yum makecache 1, 在安装jdk的时候如果出现/lib/ld-linux.so.2: bad ELF interpreter: No such file or directory 123yum -y install glibc.i686apt-get updateapt-get install ia32-libs 2, 更改环境变量 1234567vi /etc/profile:$ # to the end of the fileo # append another line and goes into insert modeexport PATH = /root/apps/jdkXXXexport PATH=$PATH:$JAVA_HOME/bin:wq!source /etc/profile 3, yum安装 yum list | grep XX 列出所有可用的package和package组 yum clean all 清除所有缓冲数据 yum deplist httpd 列出一个包所有依赖的包 yum remove httpd 删除httpd yum repolist 看一下现在的repo有哪些 4-0，yum安装MySQL 1234567sudo yum install mysql-serversudo /sbin/chkconfig --levels 235 mysqld onsudo service mysqld startsudo mysql_secure_installation//登陆mysql -u root -pXXX 4-1，手动安装MySQL rpm包 0，查询rpm包 `rpm -qa` 1，上传MySQL-server-5.5.48-1.linux2.6.x86_64.rpm、MySQL-client-5.5.48-1.linux2.6.x86_64.rpm到Linux上 2，使用rpm命令安装MySQL-server-5.5.48-1.linux2.6.x86_64.rpm，缺少perl依赖 `rpm -ivh MySQL-server-5.5.48-1.linux2.6.x86_64.rpm ` 3，安装perl依赖，上传6个perl相关的rpm包 `rpm -ivh perl-*` 4，再安装MySQL-server，rpm包冲突 `rpm -ivh MySQL-server-5.5.48-1.linux2.6.x86_64.rpm` 5，卸载冲突的rpm包 `rpm -e mysql-libs-5.1.73-5.el6_6.x86_64 --nodeps` 6，再安装MySQL-client和MySQL-server 12rpm -ivh MySQL-client-5.5.48-1.linux2.6.x86_64.rpmrpm -ivh MySQL-server-5.5.48-1.linux2.6.x86_64.rpm 7，启动MySQL服务，然后初始化MySQL 12service mysqld start/usr/bin/mysql_secure_installation 8，测试MySQL 1mysql -u root -pXXXX 5，安装tomcat tar -zxvf apacheXXXXX cd apacheXXX/bin ./startup.sh 6，安装httpd服务器 如果只是做简单的静态web服务器，不需要装tomcat,nginx这种，只要使用httpd就可以了 123sudo yum install httpdcd /var/www/htmltouch hello.html 然后访问的时候直接ip:port/hello.html就可以访问了]]></content>
      <tags>
        <tag>concept</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[net-reflection]]></title>
    <url>%2F2018%2F06%2F07%2Fnet-reflection%2F</url>
    <content type="text"><![CDATA[代码编译成机器码的过程注意在变成exe/dll之后还会有一层CLR/JIT，才会编译成机器码 为什么要有二次编译：兼容性，不同的平台。32位64位/linux,windows在不同环境下编译的方法不同 想用同一种高级语言通用于所有的平台 反射调用带参数的构造函数：1234Assembly assemly = Assembly.Load(&quot;Test.DB.SqlServer&quot;); //以前需要依靠一个类，现在相当于只依赖于一串字符串Type testType = assemly.GetType(&quot;Test.DB.SqlServer.ReflectionTest&quot;); //注意传的时候需要加上前方的namespaceobject oTest1 = Activator.CreateInstance(testType);//默认调用无参构造函数object oTest2 = Activator.CreateInstance(testType,new object[]&#123;895,&quot;霉霉&quot;&#125;);//调用参数第一个是int类型，第二个是string类型的构造函数 反射调用Generic类型:1234567891011121314151617//Generic Classnamespace Test.DB.SqlServer&#123; public class GenericClass&lt;T,W,X&gt; &#123; public void Show(T t, W w, X x) &#123; Console.WriteLine(&quot;t.type=&#123;0&#125;,w.type=&#123;1&#125;,x.type=&#123;2&#125;&quot;, t.GetType().Name,w.GetType().Name,x.GetType().Name); &#125; &#125;&#125;Assembly assemly = Assembly.Load(&quot;Test.DB.SqlServer&quot;); Type genericType = assemly.GetType(&quot;Test.DB.SqlServer.GenericClass`3&quot;);//因为泛型有占位符，所以要写占位符Type realGenericType = genericType.MakeGeneric(typeof(int),typeof(string),typeof(Program)); //用genericType是无法生成实例的，因为这个时候还没有参数类型，必须要定义好才能用，所以要调用MakeGeneric方法，用realGenericType生成占位符object oGeneric = Activator.CreateInstance(realGenericType); 反射调用Singleton单例单力模式的意思就是保证程序运行的时候只会对这个类实例化一次 构造函数种类及执行顺序 默认构造函数，如果没有为类指定任何构造函数，编译器会自动为类创建一个无参构造函数 静态构造函数，不能访问实例成员，只能用来初始化一些静态字段或者属性，仅在第一次调用类的任何成员时自动执行，不带反问修饰符，不带任何参数，且每个类只能有一个静态构造函数 私有构造函数，将构造函数声明为私有，则不能通过new()在外部代码中实例话，可以这样实例： 12345678public class Demo&#123; private Demo()&#123;&#125; public static Demo NewDemo() &#123; return new Demo(); &#125;&#125; 构造函数的执行顺序 子类静态构造 -&gt; 父类静态构造 -&gt; 父类构造 -&gt; 子类构造 单例模式通常使用的情况是不能在外面调用单例模式的私有构造函数的但是通过反射的方法是可以调用单例模式的私有构造函数! 12345678910111213141516171819202122232425262728293031323334namespace Test.DB.SqlServer&#123; public sealed class Singleton &#123; private static Singleton _Singleton = null; //构造函数首先要私有化，别人不能调用它，只能它自己调用 private Singleton() &#123; Console.WriteLine(&quot;Singleton被构造&quot;); &#125; //静态构造函数首先会被调用，这个时候会调用私有构造函数 //由于静态构造函数只会被调用一次，所以这个类也就只会被实例化一次 static Singleton() &#123; _Singleton = new Singleton(); &#125; public stati Singleton GetInstance() &#123; return _Singleton; &#125; &#125;&#125;Type singletonType = assemly.GetType(&quot;Test.DB.SqlServer.Singleton&quot;);//反射是可以直接去访问单例模式的私有构造函数，下面这个方法会调用单例模式的私有构造函数//并且还可以实例化多个单例object oSingleton1 = Activator.CreateInstance(singletonType, true);object oSingleton2 = Activator.CreateInstance(singletonType, true); 反射不强制转换也能调用方法， Reflection + Method -&gt; MVC12345678910111213141516171819202122232425262728293031323334Assembly assemly = Assembly.Load(&quot;Test.DB.SqlServer&quot;);Type testType = assemly.GetType(&quot;Test.DB.SqlServer.ReflectionTest&quot;);object oTest1 = Activator.CreateInstance(testType);MethodInfo method = testType.GetMethod(&quot;Show1&quot;); //以前写的具体方法也都换成了字符串method.Invoke(oTest1,new object[]&#123;1332&#125;); //调用含参数的方法&#123; method.Invoke(null,null);//调用无参数的静态方法，也可以写成method.Invoke(oTest1,null); &#125;&#123; MethodInfo method = testType.GetMethod(&quot;Show3&quot;,new Type[]&#123;&#125;); //重载方法没有参数的&#125;&#123; MethodInfo method = testType.GetMethod(&quot;Show3&quot;, new Type[]&#123;typeof(int)&#125;); //重载方法有一个int类型的参数&#125;&#123; MethodInfo method = testType.GetMethod(&quot;Show4&quot;,BindingFlags.Instance | BindingFlags.NonPublic); //调用私有方法&#125;public class GenericMethod&#123; public void Show&lt;T,W,X&gt;(T t, W w, X x) &#123; Console.WriteLine(&quot;XXX&quot;); &#125;&#125;&#123; Type genericType = assemly.GetType(&quot;Test.DB.SqlServer.GenericMethod&quot;); object oGeneric = Activator.CreateInstance(genericType); // 因为GenericMethod只是个普通类型，不是泛型类型 MethodInfo method = genericType.GetMethod(&quot;Show&quot;); //泛型方法不需要使用占位符 MethodInfo methodNew = method.MakeGeneric(typeof(int),typeof(string),typeof(int)); //记得这里要重新生成一个MethodInfo methodNew.Invoke(oGeneric, new object[]&#123;10,&quot;test&quot;,10&#125;);&#125; 反射调用属性和字段 Reflection + Property -&gt; O/RM1234567891011Type type = typeof(People);object oPeople = Activator.CreateInstance(type);foreach(var item in type.GetProperties())&#123; // 反射可以动态给对象属性赋值/获取值 Console.WriteLine(item.Name); Console.WriteLine(item.GetValue(oPeople)); if(item.Name.Equals(&quot;Id&quot;)) item.SetValue(oPeople,1234); else if(item.Name.Equals(&quot;Name&quot;)) item.SetValue(oPeople,&quot;ttt&quot;); Console.WriteLine(item.GetValue(oPeople))&#125;]]></content>
      <tags>
        <tag>concept</tag>
        <tag>.NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.net-generic]]></title>
    <url>%2F2018%2F06%2F05%2Fnet-generic%2F</url>
    <content type="text"><![CDATA[泛型约束现在有类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public interface ISports &#123; void Pingpang(); &#125; public interface IWork &#123; void Work(); &#125; public class People &#123; public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125; public void Hi() &#123; &#125; &#125; public class Chinese : People, ISports, IWork &#123; public void Tradition() &#123; Console.WriteLine(&quot;仁义礼智信，温良恭俭让&quot;); &#125; public void SayHi() &#123; Console.WriteLine(&quot;吃了么？&quot;); &#125; public void Pingpang() &#123; Console.WriteLine(&quot;打乒乓球...&quot;); &#125; public void Work() &#123; throw new NotImplementedException(); &#125; &#125; public class Hubei : Chinese &#123; public Hubei(int id) &#123; &#125; public string Changjiang &#123; get; set; &#125; public void Majiang() &#123; Console.WriteLine(&quot;打麻将啦。。&quot;); &#125; &#125; public class Japanese : ISports &#123; public int Id &#123; get; set; &#125; public string Name &#123; get; set; &#125; public void Pingpang() &#123; Console.WriteLine(&quot;打乒乓球...&quot;); &#125; public void Hi() &#123; &#125; &#125; 如果你现在有一个Generic Method:12345678910111213public class GenericMethod&lt;T&gt;&#123; public static void Show&lt;T&gt;(T instance)&#123; People pInstance = (People) instance; Console.WriteLine(pInstance.Id); //不会报错，但是这样做一点意义就没有了 Console.WriteLine(instance.Id); //会报错，没有Id Console.WriteLint(instance.Name); //会报错，没有Name &#125;&#125; 约束类型如果现在有一个基类约束 基类约束，可以使用基类里面的属性和方法 基类约束，要求类型参数必须是基类或者其子类，所以如果你调用GenericMethod.Show(japanese)就会报错，因为它不属于People类 基类约束，如果where后面跟多个类型，这些类型属于and关系，必须同时满足才行 You can only put one class name and several interfaces to one ‘where’ constraint!1where T1: Supplier, IConstractor, IComparable, new() 约束 说明 T:struct 类型参数必须是值类型。可以指定处Nullable以外的任何值类型 T:class 类型参数必须是引用类型，包括任何类、接口、委托或数组类型 T:new() 类型参数必须具有无参数的公共构造函数。当与其他约束一起使用时，new()约束必须最后指定。 T:&lt;基类名&gt; 类型参数必须是指定的基类或派生自指定的基类 T:&lt;接口名称&gt; 类型参数必须是指定的接口或实现指定的接口。可以指定多个接口约束。约束接口也可以是泛型的。 T:U 为T提供的类型参数必须是为U提供的参数或派生自为U提供的参数。这称为裸类型参数。 123456public staic void Show&lt;T&gt;(T instance)where T: People&#123; Console.WriteLine(instance.Id); //不会报错，因为告诉了T是属于什么类型 Console.WriteLine(instance.Name);&#125; 类型约束12345678910111213public static T DoNothing&lt;T&gt;(T tParameter)//where T: ISpotrs //接口类型约束//where T: class // 引用类型约束//where T: struct // 值类型约束where T: new() //无参数构造函数约束&#123; //return default(T);//会根据T的类型，产生一个默认值，可以应用于值类型约束的返回 //return null; //引用类型约束 T t = new T(); return t; //无参数构造函数返回&#125; 显示声明出来类型和用约束的区别 用约束来写更加灵活，比方说其可以运用ISports或者new()的写法 如果显式声明出来，就只能用People里面的方法 123456789public static void Show&lt;T&gt;(T instance) where T: People, ISports, new() // and关系&#123; Console.WriteLine(instance.Id); Console.WriteLine(instance.Name); instance.Hi(); instance.Pingpang(); T t = new T();&#125; 1234567public static void ShowPeople(People instance)&#123; Console.WriteLine(instance.Id); Console.WriteLine(instance.Name); instance.Hi(); instance.Pingpang();//报错&#125; 无参数构造函数约束Hubei就不能使用，因为Hubei这个类里面没有定义无参构造函数12Hubei hb = new Hubei(1);GenericMethod.Show(hb);//报错 Covariant协变与Contravariant逆变out -&gt; Covariantin -&gt; Contravariant 只能放在接口或者委托的泛型参数前面，类和方法是不能用的，这个跟之前定义函数的in, out是两个概念 协变与逆变只对引用类型有效，因为值类型没有什么父子关系 123456public class Bird&#123; public int Id &#123;get;set;&#125;&#125;public class Sparrow: Bird&#123; public string Name&#123;get;set;&#125;&#125; 背景12345678910Bird bird1 = new Bird();Bird bird2 = new Sparrow(); //左边是父类，右边是子类Sparrow sparrow1 = new Sparrow();//Sparrow sparrow2 = new Bird();//错，不是所有的鸟都是麻雀List&lt;Bird&gt; birdList1 = new List&lt;Bird&gt;();List&lt;Bird&gt; birdList2 = new List&lt;Sparrow&gt;(); //错！！！！！！！！！一群麻雀是一群鸟这个竟然是错的，因为List&lt;T&gt;是一个泛型概念，List&lt;Sparrow&gt;与List&lt;Bird&gt;并没有父子关系//只能像下面这样写，把每一个Sparrow转换成Bird才可以，有点不和谐了对不对List&lt;Bird&gt; birdList3 = new List&lt;Sparrow&gt;().Select(c=&gt;(Bird)c).ToList(); 协变 告诉编译器实例化的类型就是out T中T的子类 先看下IEnumerable的定义，这里面用了协变1234public interface IEnumerable&lt;out T&gt;: IEnumerable&#123; ...&#125; 12IEnumerable&lt;Bird&gt; birdList1 = new List&lt;Bird&gt;();IEnumerable&lt;Bird&gt; birdList2 = new List&lt;Sparrow&gt;(); //这个就没问题，协变的意思就是说告诉编译器，如果我实例化的类型是我out的子类，就没问题 协变只能是返回结果12345678910111213public interface ICustomerListOut&lt;out T&gt;&#123; T Get(); //void Show(T t);//报错，如果用了协变，只能作为返回结果，不能作为参数类型&#125;public class CustomerListOut&lt;T&gt;: ICustomerListOut&lt;T&gt;&#123; public T Get() &#123; return default(T); &#125;&#125; 逆变 Constravariant 只能修饰传入参数123456789101112public interface ICustomerListIn&lt;in T&gt;&#123; //T Get(); //报错，只能坐参数，不能作返回值 void Show(T t);&#125;public class CustomerListIn&lt;T&gt;: ICustomerListIn&lt;T&gt;&#123; public void Show(T t)&#123; &#125;&#125; 定义了逆变以后，我可以实现左边子类，右边父类的情况 12345ICustomerListIn&lt;Sparrow&gt; customerList1 = new CustomerListIn&lt;Sparrow&gt;();ICustomerListIn&lt;Sparrow&gt; customerList2 = new CustomerListIn&lt;Bird&gt;(); //右边可以是父类！！！！！//因为定义的时候已经定义了customerList2一定是Sparrow类型，在show的时候已经要求了必须传入Sparrow类型customerList2.Show(new Sparrow());//Show这里要求必须传入的是Sparrow类型 泛型类中的静态字段泛型：jit编译的时候指定具体类型，同一个泛型类，不同的参数类型，其实会变成不同的类型 静态字段/静态构造函数：一个类型只会初始化一次，就在第一次调用的时候初始化，之后就常驻内存 那么！！！！泛型+静态会怎么样？ 泛型类的静态字段，是独立的它会根据不同类型，产生不同的类，只有在不同类型第一次声明的时候会初始化，但是相同类型第二次用的时候就不会初始化！ 123456Console.WriteLine(GenericCache&lt;int&gt;.GetCache());Thread.Sleep(10);Console.WriteLine(GenericCache&lt;long&gt;.GetCache());//第一次进long的时候，仍然会初始化Thread.Sleep(10);Console.WriteLine(GenericCache&lt;int&gt;.GetCache());//这个时候就不会在初始化了，因为int类型的已经初始化过了 这里就牵扯到了泛型静态缓存泛型缓存的效率非常高，是直接在内存中缓存，CPU直接拿值但是这个缓存没有办法清除，比字典寻址方法要快很多]]></content>
      <tags>
        <tag>concept</tag>
        <tag>.NET</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Openresty Auto Start Script]]></title>
    <url>%2F2018%2F06%2F01%2Fopenresy-auto-start-script%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#!/bin/sh## chkconfig: 2345 55 25# Description: Nginx init.d script, put in /etc/init.d, chmod +x /etc/init.d/nginx# For Debian, run: update-rc.d -f nginx defaults# For CentOS, run: chkconfig --add nginx#### BEGIN INIT INFO# Provides: nginx# Required-Start: $all# Required-Stop: $all# Default-Start: 2 3 4 5# Default-Stop: 0 1 6# Short-Description: nginx init.d script# Description: OpenResty (aka. ngx_openresty) is a full-fledged web application server by bundling the standard Nginx core, lots of 3rd-party Nginx modules, as well as most of their external dependencies.### END INIT INFO#PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/binDESC="Nginx Daemon"NAME=nginxPREFIX=/usr/local/openresty/nginxDAEMON=$PREFIX/sbin/$NAMECONF=$PREFIX/conf/$NAME.confPID=$PREFIX/logs/$NAME.pidSCRIPT=/etc/init.d/$NAMEif [ ! -x "$DAEMON" ] || [ ! -f "$CONF" ]; then echo -e "\033[33m $DAEMON has no permission to run. \033[0m" echo -e "\033[33m Or $CONF doesn't exist. \033[0m" sleep 1 exit 1fido_start() &#123; if [ -f $PID ]; then echo -e "\033[33m $PID already exists. \033[0m" echo -e "\033[33m $DESC is already running or crashed. \033[0m" echo -e "\033[32m $DESC Reopening $CONF ... \033[0m" $DAEMON -s reopen -c $CONF sleep 1 echo -e "\033[36m $DESC reopened. \033[0m" else echo -e "\033[32m $DESC Starting $CONF ... \033[0m" $DAEMON -c $CONF sleep 1 echo -e "\033[36m $DESC started. \033[0m" fi&#125;do_stop() &#123; if [ ! -f $PID ]; then echo -e "\033[33m $PID doesn't exist. \033[0m" echo -e "\033[33m $DESC isn't running. \033[0m" else echo -e "\033[32m $DESC Stopping $CONF ... \033[0m" $DAEMON -s stop -c $CONF sleep 1 echo -e "\033[36m $DESC stopped. \033[0m" fi&#125;do_reload() &#123; if [ ! -f $PID ]; then echo -e "\033[33m $PID doesn't exist. \033[0m" echo -e "\033[33m $DESC isn't running. \033[0m" echo -e "\033[32m $DESC Starting $CONF ... \033[0m" $DAEMON -c $CONF sleep 1 echo -e "\033[36m $DESC started. \033[0m" else echo -e "\033[32m $DESC Reloading $CONF ... \033[0m" $DAEMON -s reload -c $CONF sleep 1 echo -e "\033[36m $DESC reloaded. \033[0m" fi&#125;do_quit() &#123; if [ ! -f $PID ]; then echo -e "\033[33m $PID doesn't exist. \033[0m" echo -e "\033[33m $DESC isn't running. \033[0m" else echo -e "\033[32m $DESC Quitting $CONF ... \033[0m" $DAEMON -s quit -c $CONF sleep 1 echo -e "\033[36m $DESC quitted. \033[0m" fi&#125;do_test() &#123; echo -e "\033[32m $DESC Testing $CONF ... \033[0m" $DAEMON -t -c $CONF&#125;do_info() &#123; $DAEMON -V&#125;case "$1" in start) do_start ;; stop) do_stop ;; reload) do_reload ;; restart) do_stop do_start ;; quit) do_quit ;; test) do_test ;; info) do_info ;; *) echo "Usage: $SCRIPT &#123;start|stop|reload|restart|quit|test|info&#125;" exit 2 ;;esacexit 0]]></content>
      <tags>
        <tag>linux</tag>
        <tag>practice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[法律法规]]></title>
    <url>%2F2018%2F06%2F01%2Finformation-law%2F</url>
    <content type="text"><![CDATA[主要考的分类为 招投标法 政府采购法 合同法 著作权法 专利法 招标投标法 必须招标：国家型，外国资金型，社会公共利益型 招投标法和政府采购法关于时间的总结： 发标二零改一五，售标前后至少五，报府备案要十五 售标前后至少五，签约退保也得五 三个30得牢记，定标、签约、“保证期” 政府采购法 分为集中采购和分散采购 集中采购的范围由省级以上人民政府公布的集中采购目录确定 中央预算的政府采购项目，集中采购目录由国务院确定公布 地方预算的政府采购项目，目录由省、自治区、直辖市人民政府或者其授权的机构确定公布 不必采购本国的货物： 无法在境内获取或无法以合理商业条件获取 在中国境外使用而进行采购的 其他法律、行政法规另有规定的 集中采购机构必须是非营利性 事业法人 政府采购采用以下方式： 公开招标 邀请招标 具有特殊性，只能从有限范围供应商采购的 采用公开招标方式的费用占政府采购项目总价值的比例过大的 竞争性谈判 招标后没有供应商投标或者没有合格标的或者重新招标未能成立的 技术复杂或者性质特殊，不能确定详细规格或者具体要求的 采用招标所需时间不能满足用户紧急需要的 不能事先计算出价格总额的 单一来源采购 只能从唯一供应商采购的 发生了不可预见的紧急情况不能从其他供应商处采购 必须保证原有采购项目一致性或者服务配套的要求，需要继续从原供应商处添购且添购的资金总额不超过原合同采购金额10% 询价 采购的货物规格、标准统一、现货货源充足且价格变化幅度小的政府采购项目 国务院政府采购监督管理部门认定的其他采购方式 合同法 要约与要约邀请的区别：内容很明确的为要约：商业广告如果符合要约规定的，可以视为要约内容不明确要补充的为要约邀请：如价目表、拍卖公告、招标公告、招股说明书、商业广告 要约的定义：是一方当事人以缔结合同为目的，向对方当事人提出合同条件，希望对方当事人接受的意思表示 有下列情形之一的要约不得撤销 要约人确定了承诺期限或者以其他形式明示要约不可撤销 受要约人有理由认为要约不可撤销的，并已经为履行合同作了准备工作 承诺的定义：受要约人同意要约的意思表示 要约没有确定承诺期限的，承诺应当依照下列的规定到达： 要约以对话方式作出的，应当即时作出承诺，但当事人另有约定的除外 要约以非对话方式作出的，承诺应当在合理期限内到达]]></content>
      <tags>
        <tag>信息系统管理师</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-HttpRequestException]]></title>
    <url>%2F2018%2F06%2F01%2Fhexo-HttpRequestException%2F</url>
    <content type="text"><![CDATA[Hexo Error: HttpRequestException123456789101112131415161718warning: LF will be replaced by CRLF in tags/concept/index.html.The file will have its original line endings in your working directory.Fatal: HttpRequestException encountered.bash: /dev/tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for 'https://github.com': Invalid argumentFATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: Fatal: HttpRequestException encountered.bash: /dev/tty: No such device or addresserror: failed to execute prompt script (exit code 1)fatal: could not read Username for 'https://github.com': Invalid argument at ChildProcess.&lt;anonymous&gt; (D:\learning\node_modules\hexo-util\lib\spawn.js:37:17) at emitTwo (events.js:126:13) at ChildProcess.emit (events.js:214:7) at ChildProcess.cp.emit (D:\learning\node_modules\cross-spawn\lib\enoent.js:40:29) at maybeClose (internal/child_process.js:925:16) at Process.ChildProcess._handle.onexit (internal/child_process.js:209:5) 使用： 123git config --global credential.helper wincredhexo clean]]></content>
      <tags>
        <tag>practice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-thread-run-start]]></title>
    <url>%2F2018%2F05%2F30%2Fpython-thread-run-start%2F</url>
    <content type="text"><![CDATA[start() Start the thread’s activity. It must be called at most once per thread object. It arranges for the object’s run() method to be invoked in a separate thread of control. This method will raise a RuntimeError if called more than once on the same thread object. 它安排对象在另一个单独的线程中调用run()方法，而不是当前所出的线程 run() Method representing the thread’s activity. You may override this method in a subclass. The standard run() method invokes the callable object passed to the object’s constructor as the target argument.]]></content>
      <tags>
        <tag>concept</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[process-thread]]></title>
    <url>%2F2018%2F05%2F30%2Fprocess-thread%2F</url>
    <content type="text"><![CDATA[Process进程进程是一个具有一定独立功能的程序，在一个数据集上的一次动态执行过程是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体 好比工厂车间，代表CPU所能处理的单个任务任一时刻CPU总是运行一个进程，其他进程处于非运行状态 Thread线程早期任务调度采用的是时间片轮转的抢占式调用方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。后来由于对CPU的要求越来越高，进程之间的切换开销较大，于是发明了线程。线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元。 线程好比车间的工人，即一个车间可以允许由多个工人协同完成一个任务 进程与线程进程就是包含上下文切换成程序执行时间总和 = CPU加载上下文 + CPU执行 + CPU保存上下文 但是进程的颗粒度太大，一个进程可能有好多分支和程序段，比方说进程A分为a,b,c等多个块组合而成，那么CPU的具体执行行为可能就变为： A得到CPU -&gt; CPU加载上下文，开始执行程序A的a小段， 然后执行程序A的b小段， 然后再执行程序A的c小段，最后CPU保存A的上下文 这里a, b, c共享了A的上下文，CPU在执行的时候没有进行上下文切换。这里的a,b,c就是线程，也就是线程共享了进程的上下文环境，被分为更为小的CPU时间段 高并发与多线程高并发只是一个语义相关的概念，就是让服务器能够接受多用户请求多线程只是为了达到高并发目的（首先要有多线程接收处理多任务，才有高并发发生）。在某个细节点上，为实现某并发功能而采用的一种具体的实现方法，这种功能也可以由多进程实现。 高并发其实是一种目的，多线程只是某种手段。]]></content>
      <tags>
        <tag>concept</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[conda-packages-install]]></title>
    <url>%2F2018%2F05%2F29%2Fconda-packages-install%2F</url>
    <content type="text"><![CDATA[如何查看一个包所在的地址 12import numpyprint numpy.__file__ 123import osimport numpypath = os.path.dirname(numpy.__file__)]]></content>
      <tags>
        <tag>practice</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论文]]></title>
    <url>%2F2018%2F05%2F28%2Finformation-test%2F</url>
    <content type="text"><![CDATA[论文写作 四大领域：进度 成本 质量 范围 辅助人力 沟通 风险 采购 干系人 论文不及格的几种类型： 虚构情节，千万不要写什么教育方面的系统 没有项目开发的实际经验，正片都是浅层次纯理论的论文 所讨论的内容与方法过于陈旧，也千万别用云计算等改卷老师都不知道的技术（？？？？） 一定不能写你既是项目经理、又是技术人员 乙方角度，一定不能写在签订合同前的事情 如果题目里面没有提到“大项目”，纵使项目再大，也不要写“大项目”；如果题目里面提到了“大项目”，纵使项目再小，也要写成“大项目”，写大项目就要突出大项目的特点、需要写间接管理 论文素材建议投资在一百万以上统一设定成乙方的项目项目可以通过政府采购网站上查找招标书，比方说XX市政府采购网/或搜索信息系统方案书，投标书/或再加上十二金中一金为关键词，比方说金盾 方案书/选定项目之后，再搜索详细功能介绍，比方说相关项目怒的博士/硕士论文 项目必须是已经完工的项目，且最好是最近几年的 论文格式分摘要和正文摘要要求字数300字左右，330字一下正文要求2000字以上不要在论文中书画图形正文又可分为 背景， 建议2段左右完成， 字数控制在500字左右，写完后写150字左右的过渡段 正文实践部分，一般3~6个论点，一个论点1~2段，整体字数在1400左右 收尾，一般1~2段，画龙点睛，写总结经验和教训，表决心，字数在300字左右为佳 大项目的论文写作 要在摘要和背景里面体现项目大，需要写明投资和工期，比方说投资纯软件300万+，软件+硬件1200万+，工期1年左右 摘要里面最后总结对大项目你管理的心得体会 体现简介管理，分级分工管理，比如我带领了/我指导了XXX做了什么工作 如果题目没有要求写大项目，建议不要写大项目 摘要的写法一定要规范，（时间、项目、投资金额、周期、项目目标、本文导论的内容（哪个管理的描述、管理的几个过程的介绍、管理中的问题、解决措施）、项目是否完工、是否达到目标） 举例： 1232016年3月，我作为项目经理参与了XX市XX项目，整个项目总投资7--余万元，建设工期为1年。某市力图通过XX项目的建设，实现XX的目的。该项目于2017年3月，通过了业主方的验收，赢得了用户的好评。本文以XX项目为例，结合作者实践，探讨了在项目XX管理中遇到的问题及解决方法。包括XX、XX、XX。（或者讨论了信息系统项目过程中的XX管理，主要从如下几个方面进行论述：XX-结合自己的论点去写，可以是过程，可以是解决方法，但是需要和论点对应）最后，针对存在的不足之处，提出了今后的改进思路 正文背景写法背景基本上就是摘要的扩充 甲方立项的目的，即项目将要解决什么问题 公开招标，乙方赢得该项目，项目投资额、项目工期 项目详细的功能介绍 项目技术选择 项目组织形式以及项目团队构成以上500字左右 XX管理的重要性 过渡到论述的论点以上150字左右 例： 123452017年2月， 我参与了XX市区域卫生信息集成平台建设项目，担任项目经理职位。该项目由该市卫生局贯彻“十二五”期间关于深化医药卫生体制改革规划而催生，共投资人民币980万元，工期15个月。通过该项目的建设，实现了该市人人享有基本医疗卫生服务，提高全民健康水平的总体目标。该项目将该市卫生局下属7家二级以上医院，以及23家乡镇卫生院各类医疗信息进行整合，建立区域内患者医疗信息集中存储、分布调阅、资源整合、互联互通、资源共享，减少患者跨院就诊重复检查，从而以推进公共卫生、医疗、医保、药品、财务监管信息化建设为着力点，加快信息标准化和公共卫生服务信息平台建设。该集成平台涵盖了区域市民健康系统、区域医院信息系统（简称HIS）、区域电子病历系统（EMR）、基层医疗卫生信息系统、绩效考核系统、药品监督系统等6大子系统。由于系统应用于各乡镇各医疗机构，考虑使用者的地域性，所以该集成平台使用基于.net平台的B/S三层架构，所有服务器集中存放在卫生局的中心机房，各医疗机构通过专网连接。该集成平台应用系统采用C#+MVC+ExtJS架构开发，服务器使用IBM Power 720小型机，应用服务器操作系统为Windows Server 2008,数据库采用Oracle 11g,数据库服务器操作系统为AIX 5L。同时使用vs2013自带的团队管理器TFS作为项目配置管理工具。【515字，一般到这里就结束了】该项目建设具有如下特征：1. 项目周期长，历时长达15个月之久。2. 项目规模大，目标构成复杂。3. 项目干系人构成复杂，包括市卫生局、社保中心、医院卫生院以及各子系统的项目成员等。 4. 综合性强。然而面对如此复杂的应用，我面临更多“间接管理”的挑战，日常职责更集中于管理职责。由于本系统涉及业务考核，因此在本项目中，质量管理尤为重要。在本项目中，我作为项目经理，除了对其他管理领域进行恪尽职守的管理外，主要从质量规划、质量保证和质量控制等方面进行质量管理。下面结合本人实际经验，简要介绍该项目的质量管理过程和方法，望各位批评指正。【这一段一般市大项目的写法，一般项目不用谢】 正文中的万能模板需求管理 1从事多年项目管理的我深知，需求是龙头，是做项目管理的基础，没有需求，项目就无从谈起；因此在项目开始实施后，我带领我的项目团队深入甲方现场，通过用户访谈方式获得了用户需求，为后期项目管理奠定了基础；【建议在实践的开头部分写】 变更管理 1在项目实施过程中，变更不可避免的可能会由于用户的需求发生了变化、政策导向的改变或者由于一些新金属的出现等等。在本项目中我严格遵照变更控制流程进行管理，比如变更申请-评估-决策-实施-验证-沟通存档，我通过严格管理变更，没有导致项目的延期【建议在时间的偏后写】 收尾的万能模板 1由于在实际项目中我们对XX管理的高度重视，采取了···（方法和措施），取得了良好的收效，我们的项目按期完成，项目组也赢得了公司的好评，项目基本上取得了成功。但通过总结认为，该项目··管理中····（哪些方面）仍存在一些不足，主要是由于····（原因）造成了····（不良后果），所以在后续的学习和工作中，我将不断充电学习，同时进行业务交流，提升自己的业务和管理水平，力争为我国信息化建设做出自己的努力]]></content>
      <tags>
        <tag>信息系统管理师</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构简概]]></title>
    <url>%2F2018%2F05%2F28%2Fdata-structure%2F</url>
    <content type="text"><![CDATA[学习萧大神笔记： 时间复杂度 O(1)常数复杂度，例如取数组第1000000个元素字典和集合的存取都是O(1)数组的存取是O(1) O(1)与O(n)的区别：O(1)的时间是确定的，O(n)是随着时间增大而增大O(1)是随着数据规模的增长而增长 O(lgN)对数复杂度例如一个有序数组，二分法查找 O(n)线性复杂度例如有一个数组，以遍历方式在其中查找元素 O(nlgN)例如求两个数组的交集，其中A是有序数组，B不是有序数组A数组每一个元素都要在B数组中进行查找因为每次查找用二分法的复杂度是lgN，那么n个数据就是nLgN O(n^2)平方复杂度求两个无序数组的交集 常用数据结构 数组连续的一块内存存取元素的时间是O(1),因为是连续的内存，只要计算出内存地址就可以迅速拿到数据，这里的存取是指替换掉原来的元素插入、删除是O(n)，因为插入之后的元素都要往后挪 链表手拉手的盒子，一个盒子只能访问左右手的盒子以下标方式读取元素的时间是O(n)，因为要一个个搜过去插入、删除是O(1)，只要更改链表的指向就可栈和队列是链表的改良队列 先进先出栈 先进后出 字典(哈希表 对象 关联数组 Map 都是字典)想要像数组一样可以拿取数据都是O(1),但是数组都是用数字来取数据，想要也能用字符串来取数据把字符串转为数字作为下标存储在数组中字符串转化为数字的算法是O(1)所有字典的存取操作也都是O(1)除非对数据有顺序要求，否则字典永远都是最佳选择字符串转化为数字的算法： 确定数据规模，这样可以确定容器数组的大小 = Size 把字符当作N进制数字得到结果： ‘gua’ = g 1+u 10+1 * 100 = n n % Size作为字符串在数组中的下标 通常Size会选一个素数，素数也叫做质数，指在大于1的整数中只能被1和它本身整除的数，比如2、3、5、7、11、43、109 如果下标冲突（即碰撞）的时候，有标准解决碰撞的方法，比方说用HashTable 它的原理是我在数组中存的不是数据，而是一个链表 当Hash值相同的时候，就放在这个链表里面 搜索树用于作搜索用，比方说二叉搜索树，左边的节点总是小于中间的节点，右边的节点总是大于中间的节点这样搜索最小的 ，只要搜索最左边那一条线就可以了时间复杂度跟二叉搜索一样，都取决于你这棵树的高度O(lgN) 平衡树的意思就是当树的高度差超过1的时候，会重新定义根节点，把原来的树进行旋转 图 Python List存取是O(1)插入删除也是O(1) 当它最初申请的数组空间用完了以后，它会申请一个更大的数组空间，然后把原来的数组空间copy到新申请的大数组空间中 所以有时候看会有时间断层 Python list有两个部件： 数组 存储数据在链表中的地址 链表 实际存储数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879# HashTable Data Structureclass HashTable(object): def __init__(self): self.table_size = 11 self.table = [0]*self.table_size # 这个魔法方法来实现in/not in语法 def __contains__(self, item): return self.has_key(item) def has_key(self, key): index = self._index(key) v = self.table[index] if isinstance(v, list): for kv in v: if kv[0] == key: return True return False def _index(self, key): return self._hash(key) % self.table_size def _hash(self, s): n = 0 f = 1 for i in s: n += ord(i) * f f *= 10 return n def add(self, key, value): index = self._index(key) self._insert_at_index(index, key, value) def _insert_at_index(self, index, key, value): v = self.table[index] data = [key, value] if isinstance(v, int): self.table[index] = [data] else: self.table[index].append(data) def get(self, key, default_value = None): index = self._index(key) v = self.table[index] if isinstance(v, list): for kv in v: if kv[0] == key: return kv[1] return default_valuedef test(): import uuid names = [ 'ss', 'drill', 'name', 'python', 'web', 'Banana', 'Apple', 'Computer', 'Android', 'Mobile' ] ht = HashTable() for key in names: value = uuid.uuid4() ht.add(key, value) print('add 元素', key, value) for key in names: v = ht.get(key) print('get 元素', key, v)if __name__ == '__main__': test() 如果这个素数设置的够小，你就能看到有些item存的是一个list]]></content>
      <tags>
        <tag>concept</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session Cookie]]></title>
    <url>%2F2018%2F05%2F22%2Fsession-cookie%2F</url>
    <content type="text"><![CDATA[Session 和 Cookie的出现都是为了保存状态， 因为浏览器是无状态的 Cookie 是保存在客户端的，如果服务器的response里面有set_cookie,则客户端的服务器就会存这个值Cookie里面不能直接存敏感的值，所以有了Session, 服务器维护Session和Cookie的Mapping关系，但是Session也是可以存在客户端的 比方说12345678910@main.route("/login", methods=['POST'])def login(): form = request.form u = User.validate_login(form) if u is None: return redirect(url_for('.index')) else: # session 中写入 user_id session['user_id'] = u.id return redirect(url_for('.profile')) 不过比较好的方法是放在服务器中防止客户端丢失数据，比方说存储在服务的mongodb]]></content>
      <tags>
        <tag>concept</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 服务器中文编码]]></title>
    <url>%2F2018%2F05%2F22%2Flinux-server-chinese-encoding%2F</url>
    <content type="text"><![CDATA[123nano /etc/environmentLC_CTYPE="en_US.UTF-8"LC_ALL="en_US.UTF-8"]]></content>
      <tags>
        <tag>linux</tag>
        <tag>practice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu EC2 install Oh My Zsh]]></title>
    <url>%2F2018%2F05%2F22%2Flinux-install-zsh%2F</url>
    <content type="text"><![CDATA[sudo apt-get install zsh wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh sudo chsh -s /bin/zsh Check whether your bash is correct: $ cat /etc/passwd You should have root and ubuntu set as: 12root:x:0:0:root:/root:/bin/zshubuntu:x:1000:1000:Ubuntu,,,:/home/ubuntu:/bin/zsh If not, manually change for ubuntu user: 12sudo -schsh -s /bin/zsh ubuntu If you change the theme, be sure to install the theme first]]></content>
      <tags>
        <tag>linux</tag>
        <tag>practice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pypi apt-get 更换镜像]]></title>
    <url>%2F2018%2F05%2F22%2Fpypi-apt-change-mirror%2F</url>
    <content type="text"><![CDATA[Pypi 临时使用 1pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package 设默认 没有的话就创建一个以下文件，把 index-url改成tuna,例如 * Linux: `~/.config/pip/pip.conf` * Windows 10: `%APPDATA%\pip\pip.ini` * Mac OS: `$HOME/Library/Application Support/pip/pip.conf` 12[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple 如果pip和pip3并存，只需要修改~/.pip/pip.conf Apt-getUbuntu的软件源配置文件为/etc/apt/sources.list 给系统的list备份 整个修改sources.list的文件为下文档： 12345678910111213# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse 修改完毕记得 sudo apt-get update]]></content>
      <tags>
        <tag>linux</tag>
        <tag>practice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask wsgi 套路文件]]></title>
    <url>%2F2018%2F05%2F22%2Fflask-wsgi-default%2F</url>
    <content type="text"><![CDATA[套路文件 1234567891011121314#!/usr/bin/env python3import sysfrom os.path import abspathfrom os.path import dirname# set current directory as working directorysys.path.insert(0, abspath(dirname(__file__)))# import app.py (flask 启动文件)import app# MUST HAVE an applicationapplication = app.app 对于gunicorn+搭配supervisord部署cat /etc/supervisor/conf.d/todo.conf在此文件中更改1234[program:todo]command = /usr/local/bin/gunicorn wsgi --bind 0.0.0.0:80 --pid /tmp/todo.piddirectory = /todoautostart = true 然后1sudo supervisorctl restart todo 或者1sudo service supervisor restart 默认的日志错误文件在1cat /var/log/supervisor/todo-stderr---supervisor-WX7Fbz.log]]></content>
      <tags>
        <tag>practice</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 单下划线，双下划线变量]]></title>
    <url>%2F2018%2F05%2F22%2Fpython-underline%2F</url>
    <content type="text"><![CDATA[单下划线开头 常用于模块中 单下划线开头_xx变量和函数被默认认为内部函数，treated as private by a programmer. 即如果用from module import *时，这部分的变量和函数不会被导入，但是可以通过module._xx来访问 单下划线结尾 通常与Python关键词区分开来，比方说一个Python关键词为cls，我也需要定义一个cls，可以写成cls_ 双下划线开头 This is not a convention. It has a specific meaning to the interpreter. Python Name Mangling spam(2 leading underline and at most one trailing underline) will be replaced with `_classnamespam, whereclassname` is the current class name. If you create a subclass of A, say B then you can’t easily override A&#39;s __method_name &gt;&gt;&gt; class A(object): def _internal_use(self): pass def __method_name(self): pass &gt;&gt;&gt; dir(A()) ['_A__method_name',...,'_internal_use'] 双划线开头，双划线结尾 Python自己的魔术对象, used by Python itself. 比方说init, del, add, getitem 以及全局的file, name等。 不要试图重写他们]]></content>
      <tags>
        <tag>concept</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步、异步、回调、阻塞、非阻塞、线程、进程、协程]]></title>
    <url>%2F2018%2F05%2F14%2Fconcurrent-async-concept%2F</url>
    <content type="text"><![CDATA[作者：Manjusaka链接：https://www.zhihu.com/question/266222348/answer/304632928来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ##同步阻塞： 举一点不严谨的例子吧你现在要买一本《人体艺术导论》，但是奶茶东缺货。最开始你一直刷新页面，等着书到货了，这是同步阻塞。 ##同步非阻塞你觉得这样太浪费时间了。你就去去汤不热看点照片压压惊，然后时不时的去刷一下图书状态是否有货，这是同步非阻塞。 ##异步阻塞好了，你最后成功买到《人体艺术导论》这本书。某一天，你想去再去买一本《知乎撕逼指南》，抱歉你运气很差，还是没货了那么现在你觉得不断的刷是否有货太傻了你现在奶茶东上设置了一下，当有货的时候给你响起 FBI Warning 的闹钟。好了，你现在一直等着闹钟的想起，这叫异步阻塞。 ##异步非阻塞你还是觉得，我怎么能这么傻于是你去干点奇遇事情，等闹钟响起的时候，你就下单。这叫异步非阻塞OK，明白了 前面四个概念么？ 都是在奶茶东买书，基本版的奶茶东，同步，我们只能手动去不断查询书是否有货设置闹钟后的奶茶东，异步，奶茶东可以在有货的时候主动通知我们阻塞，在书籍有货之前，我们都没法干其余的事情非阻塞，在书籍有货之前，我们可以干其余的事情 ##回调好了，现在你觉得自己下单太傻了，你在奶茶东上做了更进一步的设置。当这本书有货的时候，帮我下单。这就是回调 好了，进程，线程，协程你现在要买十本书，每本书都可能没货，现在你觉得这个工作太繁琐了你开了十家公司，每个公司分别帮你购买一本书，公司-&gt;进程你开了一家公司，公司里找了十个人，每个人帮你购买一本书，人-&gt;线程你开了一家公司，找了一个人，用十个手机，每个手机帮你购买一本书，手机-&gt;协程 ##并发并行并发和并行是相对的一个概念并发：交替做不同事的能力并行：同时做不同事的能力 举个例子，回到买书的问题，有个妹子，找你想让你帮忙买四本书，你找了两个人，一个人买两本书，对于买书的人而言，购买两本书的操作交互进行，这是并发。对你而言，你将四本书分别交给两个人同时购买，这是并行。对于妹子而言，你一个人交替购买四本书，这是并发。 事件循环是什么？前面不是说了么你购买书，想收到有货通知，想有货自动下单，但是你自己不知道怎么搞定，你把这个事情交给奶茶东。奶茶东-&gt;事件循环]]></content>
      <tags>
        <tag>concept</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Install R Shiny Server in Ubuntu]]></title>
    <url>%2F2018%2F05%2F09%2Fubuntu-install-shiny-server%2F</url>
    <content type="text"><![CDATA[Install Python 12345678910sudo apt-get updatesudo apt-get -y upgrade#type python3 check if python3 is installedsudo apt-get install -y python3-pipsudo apt-get install -y build-essential libssl-dev libffi-dev python3-devsudo apt-get install -y liblzma-dev libblas-dev gfortrannano ~/.bashrc#type on the top of the filealias python=python3source ~/.bashrc Install Java 123456789101112131415sudo apt-get install -y default-jresudo apt-get install -y default-jdksudo add-apt-repository ppa:webupd8team/javasudo apt-get updatesudo apt-get install oracle-java8-installerorwget http://download.oracle.com/otn-pub/java/jdk/8u171-b11/512cd62ec5174c3487ac17c61aaa89e8/jdk-8u171-linux-x64.tar.gz?AuthParam=1530518840_9e538c86b030b30acb4afc0f47a60454mkdir /apps/tar -zxvf jdk-8u171-linux-x64.tar.gz -C /apps/vi /etc/profileexport JAVA_HOME=/apps/jdk1.8.0_171export PATH=$PATH:$JAVA_HOME/binsource /etc/profile Setting JAVA_HOME 12345sudo update-alternatives --config javasudo nano /etc/environmentJAVA_HOME="/usr/lib/jvm/java-8-oracle"source /etc/environmentecho $JAVA_HOME Install R from source and X11 12345678910sudo apt-get install -y libcurl4-openssl-dev#install x11sudo apt-get install -y xvfb xauth xfonts-base#Xvfb :0 -ac -screen 0 1960x2000x24 &amp;#then set Sys.setenv("DISPLAY"=":0") on top of ui.R#install cairosudo apt-get -y build-dep cairosudo apt-get install -y libcairo2-dev If you choose to use cairo, put options(bitmapType=&#39;cairo&#39;) on top of the server.R or put it in the Rprofile so that all sessions will read this configuration. [https://stackoverflow.com/questions/17243648/cant-display-png]123456789sudo apt-get install libbz2-devwget https://mirrors.tuna.tsinghua.edu.cn/CRAN/src/base/R-3/R-3.5.0.tar.gztar xzvf R-3.5.0.tar.gzcd R-3.5.0sudo -s./configure --with-readline=no --with-libtiff --with-libjpeg --with-libpng --with-x --with-cairomakemake checkmake install Check capabilities:12Rcapabilities() RprofileAt startup, R will source the RProfile.site file.Then look for a .Rprofile file to source in the current working directory.Not found, it will look for on in ~/.Rprofile. [https://www.r-bloggers.com/fun-with-rprofile-and-customizing-r-startup/]1In the absence of any command-line flags being used, when R starts up, it will “source” (run) the site-wide R startup configuration file/script if it exists. In a fresh install of R, this will rarely exist, but if it does, it will usually be in ‘/Library/Frameworks/R.framework/Resources/etc/’ on OS X, ‘C:Program FilesRR-***etc’ on Windows, or ‘/etc/R/’ on Debian. Next, it will check for a .Rprofile hidden file in the current working directory (the directory where R is started on the command-line) to source. Failing that, it will check your home directory for the .Rprofile hidden file. There are two special functions you can put: * **.First()** will run at the start of the R session * **.Last()** will run at the end of the session You can check if you have a site-wide R configuration script by runningCreate RProfile.site under R.home/etc/ 1R.home(component = "home") in the R console and then checking for the presence of Rprofile.site in that directory. The presence of the user-defined R configuration can be checked for in the directory of whichever path1path.expand("~") Sample Rprofile.site file1234567891011121314151617181920212223242526272829# Things you might want to change# options(papersize="a4") # options(editor="notepad") # options(pager="internal")# R interactive prompt # options(prompt="&gt; ")# options(continue="+ ") # to prefer Compiled HTML help options(chmhelp=TRUE) # to prefer HTML help # options(htmlhelp=TRUE) # General options options(tab.width = 2) options(width = 130)options(graphics.record=TRUE) options(bitmapType='cairo')#.First &lt;- function()&#123;# #library(Hmisc)# #library(R2HTML)# cat("\nWelcome at", date(), "\n") #&#125;#.Last &lt;- function()&#123; # cat("\nGoodbye at ", date(), "\n")#&#125; In order to use shinyjs, install V8 1234567cd /usr/local/lib/Rsudo mkdir site-librarysudo chmod o+w site-librarysudo apt-get install -y libv8-3.14-devRchooseCRANmirror(81)install.packges("V8") Install R Packages for Shiny 12345678910111213141516sudo apt-get install -y libxml2-devsudo su - -c "R -e \"install.packages(c('shiny','shinydashboard','shinyjs','quanteda', 'dygraphs', 'rhandsontable','keras','DEoptim','RSQLite','reshape2','mlbench','future','promises','shinyWidgets','devtools','Hmisc','XML','DT','V8','shinyBS'), repos='https://mirrors.tuna.tsinghua.edu.cn/CRAN/')\""install.packages(c('shiny','shinydashboard','shinyjs','quanteda', 'dygraphs', 'rhandsontable','keras','DEoptim','RSQLite','reshape2','mlbench','future','promises','shinyWidgets','devtools','Hmisc','XML','DT','V8','shinyBS'),repos='https://mirrors.tuna.tsinghua.edu.cn/CRAN/')sudo apt-get install unzipRlibrary(devtools)options(unzip="internal")devtools::install_github('madlogos/recharts')install.packages('rredis')sudo su - -c "R -e \"devtools::install_github('lchiffon/REmap')\"" Install keras(h5py),tensorflow 123sudo apt-get install -y python-virtualenvsudo pip3 install tensorflow -i https://pypi.tuna.tsinghua.edu.cn/simplesudo pip3 install keras -i https://pypi.tuna.tsinghua.edu.cn/simple Install Shiny Server, check this page[https://www.rstudio.com/products/shiny/download-server/] for the newest package 123sudo apt-get install gdebi-corewget https://download3.rstudio.org/ubuntu-14.04/x86_64/shiny-server-1.5.7.907-amd64.debsudo gdebi shiny-server-1.5.7.907-amd64.deb Shiny Server Management 12345start shiny-server / sudo systemctl start shiny-server.servicestop shiny-server / sudo systemctl stop shiny-server.servicerestart shiny-server / sudo systemctl restart shiny-server.servicestatus shiny-server / sudo systemctl status shiny-server.servicesudo reload shiny-server /sudo systemctl reload shiny-server.service Shiny config file conf: /etc/shiny-server/shiny-server.conf site: /srv/shiny-server/ log: /var/log/shiny-server.log or /var/log/shiny-server/*.log Deploy App[https://www.linode.com/docs/development/r/how-to-deploy-rshiny-server-on-ubuntu-and-debian/#deploy-your-app] By default, Shiny Server uses /srv/shiny-server/ as its site directory. Any Shiny apps in this directory will be served automatically. Copy the example app directory into /srv/shiny-server/:1sudo cp -r Example/ /srv/shiny-server/ In a web browser, navigate to the app’s address. Replace example.com with your Linode’s public IP address or FQDN:1example.com:3838/Example Create a symbolic link to the actual file systemsudo ln -s /opt/shiny-server/actually_file_location /srv/shiny-server/symbolic_file Configure Shiny ServerShiny Server’s configuration file is stored at /etc/shiny-server/shiny-server.conf: 123456789101112131415161718192021# Instruct Shiny Server to run applications as the user "shiny"run_as shiny;# Define a server that listens on port 3838server &#123; listen 3838; # Define a location at the base URL location / &#123; # Host the directory of Shiny Apps stored in this directory site_dir /srv/shiny-server; # Log all Shiny output to files in this directory log_dir /var/log/shiny-server; # When a user visits the base URL rather than a particular application, # an index of the applications available in this directory will be shown. directory_index on; &#125;&#125;]]></content>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Shiny</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[R Concepts]]></title>
    <url>%2F2018%2F04%2F18%2Fr-concepts%2F</url>
    <content type="text"><![CDATA[apply函数通过apply函数，可以实现对数据的循环、分组、过滤、类型控制等操作。 apply函数可以替代for循环函数。它可以对矩阵、数据框、数组（二维，多维）按行或列进行循环计算，对子元素进行迭代，并把子元素以参数传递的形式给自定义的FUN函数中，并返回计算结果。 apply(X, MARGIN, FUN, ...) X: 数组、矩阵、数据框 MARGIN: 按行计算=1， 按列计算=2 FUN: 自定义调用函数 …: 更多参数 例： 对一个矩阵的每一行求和 123456789&gt; x&lt;-matrix(1:12, ncol=3)&gt; x [,1] [,2] [,3][1,] 1 5 9[2,] 2 6 10[3,] 3 7 11[4,] 4 8 12&gt; apply(x, 1, sum)[1] 15 18 21 24 例： 按行循环，让数据框的x1列+1,并计算x1,x2列的均值 123456789101112131415161718192021&gt; x &lt;- cbind(x1=3, x2=c(4:1,2:5)); x x1 x2[1,] 3 4[2,] 3 3[3,] 3 2[4,] 3 1[5,] 3 2[6,] 3 3[7,] 3 4[8,] 3 5# 自定义函数myFUN, 第一个参数x为数据，第二、第三个参数为自定义参数&gt; myFun &lt;- function(x,c1,c2)&#123; c(sum(x[c1],1), mean(x[c2]))&#125;&gt; apply(x,1,myFUN,c1='x1',c2=('x1','x2')) [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8][1,] 4.0 4 4.0 4 4.0 4 4.0 4[2,] 3.5 3 2.5 2 2.5 3 3.5 4 [,[[,$ accessors[Ref:https://www.r-bloggers.com/r-accessors-explained/] Subset with [ 取Object子集用[]. 取出来的子集与原object类型相同 Extract one item with [[ The double square brackets are used to extract one element from potentially many. For vectors yield vectors with a single value; data frames give a column vector; for list, one element 12letters[[3]]iris[["Petal.Length"]] Remember: You can return only one item. The result is not (necessarily) the same type of the object as the container The dimension will be the dimension of the one item which is not Interact with $ $ is a special case of [[]] in which you access a single item by actual name. The following are equal 12iris$Petal.Lengthiris[["Petal.Length"]] Remember: * You cannot use integer indices * The mane will not be interpolated. * Returns only one item. * If the name contains special characters, the name must be enclosed in **&quot;&quot;**]]></content>
      <tags>
        <tag>concept</tag>
        <tag>R</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rshiny-concept]]></title>
    <url>%2F2018%2F04%2F18%2Frshiny-concept%2F</url>
    <content type="text"><![CDATA[Shiny ScopePer-session objects12345# server.RshinyServer(func = function(input, output)&#123; startTime &lt;- Sys.time() &#125;) func is called each time a web brower is pointed to the Shiny application = is called once for each session. 所有在func里面的东西是每个session单独实例化的。这包括input和output。每个session有自己的input和output,只在func中可见。 每个session也会有自己的startTime。 Objects 所有session可见适用于需要使用大数据，或者不需要input和output的工具函数的情况。只需要把objects定义在shinyServer之外+inside server.R文件即可。 123456789101112# objects visible across all sessionsbigDataSet &lt;- read.csv('bigdata.csv')# objects visible across all sessionsutilityFunc &lt;- function(x)&#123;&#125;shinyServer(function(input,output)&#123;&#125;) 如果要修改共享objects，需要使用&lt;&lt;-运算符，&lt;-只针对本地变量 Global ObjectsObjects defined in global.R. 与所有Session可见Objects相似，但是不同的是，它同时对于ui.R可见。 这是因为他们被加载到了R session的全局环境中。所有的Shiny app的R代码都是运行在这个全局环境或者其子环境中。 实际应用中，这个并不常见。ui.R中的代码只会被执行一次，就是当Shiny app启动时。然后它会生成html 文件，缓存然后传给与其相连的浏览器。 这种所发当设置一些共享配置的时候可能比较有用。]]></content>
      <tags>
        <tag>concept</tag>
        <tag>R</tag>
        <tag>shiny</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask 一些概念]]></title>
    <url>%2F2018%2F04%2F17%2Fflask-concepts%2F</url>
    <content type="text"><![CDATA[URL重定向行文1234567@app.route('/projects/')def projects(): return 'The project page'@app.route('/about')def about(): return 'The about page' 注意`@app.route(‘/projects/‘)最末尾的/`，看起来如同一个文件夹。访问一个没有斜杠结尾的URL时，Flask会自动进行重定向，帮你在尾部加上一个斜杠 但是`@app.route(‘/about’)尾部没有斜杠，如果你在浏览器里面输入了localhost:2000/about/`， 会出现404错误 url_for（）用于生成制定函数的urlurl_for()会为你处理特殊字符的转义以及Unicode数据 123456789101112131415161718192021&gt;&gt;&gt; from flask import Flask, url_for&gt;&gt;&gt; app = Flask(__name__)&gt;&gt;&gt; @app.route('/')... def index(): pass...&gt;&gt;&gt; @app.route('/login')... def login(): pass...&gt;&gt;&gt; @app.route('/user/&lt;username&gt;')... def profile(username): pass...&gt;&gt;&gt; with app.test_request_context():... print url_for('index')... print url_for('login')... print url_for('login', next='/')... print url_for('profile', username='John Doe')...//login/login?next=//user/John%20Doe flask blueprintflask blueprint用于模块化代码， 如果没有蓝图，那么一个blog系统（分前端和后端） 1from flask import Flask, render_template, reque]]></content>
      <tags>
        <tag>concept</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 小概念]]></title>
    <url>%2F2018%2F04%2F17%2Flinux-concepts%2F</url>
    <content type="text"><![CDATA[&amp; 后台执行如果在界面输入 ./test.sh &amp;会 在终端显示进程号2333 test.sh的结果会输出到终端 输入 Ctrl+C, 会发出SIGINT信号，程序会继续运行 但是关掉session之后， 程序会收到SIGHUP信号，程序关闭 nohup如果在界面输入nohup ./test.sh 前台没有出现进程号 有一个“忽略输入，输出到nohup.out”的提示 test.sh里面的结果也没有输出到前台上 输入Ctrl+C,进程关闭 关掉session之后，进程仍然存在 所以一般都是nohup与&amp;共同使用，这样可以让程序同时免疫SIGINT和SIGHUP信号 () 开新的子进程shell执行单独踢到后台&amp;，如果当前命令界面关掉，这个命令界面执行的所有命令都会被关掉开新的子进程就不会 (python3 server.py &gt;&gt; output.txt &amp; ) touchtouch x.txt如果x.txt存在就更新修改时间如果x.txt不存在就创建文件 history/grephistory 查看历史命令grep 查找 history | grep touch 把历史记录里所有的touch拿出来]]></content>
      <tags>
        <tag>concept</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS Install Python3, pip3 and Coexist Python2]]></title>
    <url>%2F2018%2F04%2F16%2Fcentos-install-python3%2F</url>
    <content type="text"><![CDATA[Install Python312345678910111213141516171819$ sudo yum groupinstall &quot;Development Tools&quot;$ sudo yum -y install zlib*$ sudo mkdir /usr/local/python3 # 创建安装目录# 下载 Python 源文件$ wget --no-check-certificate https://www.python.org/ftp/python/3.6.0/Python-3.6.0.tgz# 注意：wget获取https的时候要加上：--no-check-certificate$ tar -xzvf Python-3.6.0.tgz # 解压缩包$ cd Python-3.6.0 # 进入解压目录$ sudo ./configure --prefix=/usr/local/python3 # 指定创建的目录$ sudo make$ sudo make install Python2 Python3 共存创建python3软链接这样可以用python命令使用Python2， python3来使用Python3 1$ sudo ln -s /usr/local/python3/bin/python3 /usr/bin/python3 默认使用Python3先将现有的python备份， 用which python来看： 12345$ which python/usr/bin/python$ cd /usr/bin$ sudo mv python python.bak 然后创建软链接 1$ sudo ln -s /usr/local/python3/bin/python3 /usr/bin/python 这样默认的python版本就替换成Python3了 另外由于yum使用Python2,替换后python3可能无法正常工作，所以修改yum配置文件 1sudo vi /usr/bin/yum 将第一行从 #!/usr/bin/python改为#!/usr/bin/python2.7 Install Pip3123456789# 下载源代码$ wget --no-check-certificate https://github.com/pypa/pip/archive/9.0.1.tar.gz$ tar -zvxf 9.0.1.tar.gz # 解压文件$ cd pip-9.0.1# 使用 Python 3 安装$ python3 setup.py install 创建软链接 1$ sudo ln -s /usr/local/python3/bin/pip /usr/bin/pip3 升级pip 1$ pip install --upgrade pip]]></content>
      <tags>
        <tag>linux</tag>
        <tag>practice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python pip3 fatal error in launcher]]></title>
    <url>%2F2018%2F04%2F16%2Fpython-pip3-install-error%2F</url>
    <content type="text"><![CDATA[While installing pymongo: 1Fatal error in launcher: Unable to create process using '"' Solution: 1python -m pip install --upgrade pip]]></content>
      <tags>
        <tag>issue</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python class]]></title>
    <url>%2F2018%2F04%2F13%2Fpython-class%2F</url>
    <content type="text"><![CDATA[class继承1234567891011class Animal(Object)： def cry(self): print("Animal shouts")class Dog(Animal): def cry(self): print("Wang wang")&gt;&gt;&gt; dog = Dog()&gt;&gt;&gt; dog.cry() //覆盖了父类Animal的cry()方法Wang wang class访问限制私有变量，可以把属性的名称前加上两个下划线__ 1234567class Student(object): def __init__(self, name, score): self.__name = name self.__score = score def get_name(self): return self.__name 但是以__开头__结尾的，是特殊变量, 特殊变量可以直接访问，不是private变量 如果变量名前面只有一个下划线_，这样的实例变量外部可以访问，但是by convention, 虽然可以方位，但请把我视为私有变量，不要随意访问 注意！！！ 12345678&gt;&gt;&gt; bart = Student('Bart Simpson', 59)&gt;&gt;&gt; bart.get_name()'Bart Simpson'&gt;&gt;&gt; bart.__name = 'New Name' # 这里设置__name变量, 是相当于新加了一个__name变量，而真正的变量已经被Python解释器变为_Student__name&gt;&gt;&gt; bart.__name'New Name'&gt;&gt;&gt; bart.get_name() # get_name()内部返回self.__name'Bart Simpson' 获得一个对象的所有属性和方法123456&gt;&gt;&gt; dir('ABC')['__add__', '__class__',..., '__subclasshook__', 'capitalize', 'casefold',..., 'zfill']&gt;&gt;&gt; len('ABC') #内部相当于调用了该对象的__len__()方法3&gt;&gt;&gt; 'ABC'.__len__()3 实例属性和类属性实例绑定属性通过self变量： 123456class Student(object): def __init__(self, name): self.name = names = Student('Bob')s.score = 90 类属性直接在类下面定义,这个属性可以被所有类的实例访问到 12345678910111213141516class Student(object): name = 'Student'&gt;&gt;&gt; s = Student() # 创建实例s&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性Student&gt;&gt;&gt; print(Student.name) # 打印类的name属性Student&gt;&gt;&gt; s.name = 'Michael' # 给实例绑定name属性&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性Michael&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问Student&gt;&gt;&gt; del s.name # 如果删除实例的name属性&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了Student @staticmethod和@classmethod一般是用类方法需要先实例化一个对象再调用方法但是使用了@staticmethod以及@classmethod，可以直接类名.方法名()调用 它们的区别： @classmethod处理仅跟这个类相关的方法，跟instance无关。当@classmethod被调用的时候，是把这个class作为第一个参数传进去，而不是这个类的实例。也就是说你可以直接在这个@classmethod里面用类属性，而非从一个类实例里面使用 @staticmethod，当调用这个方法的时候，我们甚至不用把类传进去，也就是说我们可以把这个方法放到类里面，但是这个方法其实根本不需要这个类或者实例，比方说设置一些环境参数，更改别的类的属性之类的。 1234567891011121314151617181920212223242526272829class Kls(object): def __init__(self, data): self.data = data def printd(self): print(self.data) @staticmethod def smethod(*arg): print('Static:', arg) @classmethod def cmethod(*arg): print('Class:', arg)&gt;&gt;&gt; ik = Kls(23)&gt;&gt;&gt; ik.printd()23&gt;&gt;&gt; ik.smethod()Static: ()&gt;&gt;&gt; ik.cmethod()Class: (&lt;class '__main__.Kls'&gt;,)&gt;&gt;&gt; Kls.printd()TypeError: unbound method printd() must be called with Kls instance as first argument (got nothing instead)&gt;&gt;&gt; Kls.smethod()Static: ()&gt;&gt;&gt; Kls.cmethod()Class: (&lt;class '__main__.Kls'&gt;,)]]></content>
      <tags>
        <tag>concept</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python open() 文件操作]]></title>
    <url>%2F2018%2F04%2F13%2Fpython-open%2F</url>
    <content type="text"><![CDATA[open()打开一个文件并返回一个file对象 1open('log.txt', 'a', encoding='utf-8') 1open(name, mode, buffering=1, encoding=None, errors=None, newline=None, closefd=True, opener=None) name: 要访问的文件名称 mode: 决定打开文件的模式： 模式 | 描述 — | — r | 默认方式， 只读， 文件指针在文件开头 w | 写入，如果文件存在覆盖，不存在创建 a | 打开文件追加，如果文件存在文件指针放在文件结尾，不存在创建 x | exclusive creation, fail if file already exists b | 二进制格式 t | 文本格式(默认) | 打开文件读写 buffering： buffering=0,不会寄存; buffering=1,寄存; buffering&gt;1, 表示寄存区的缓冲大写; buffering&lt;0,寄存区缓冲大小为系统默认]]></content>
      <tags>
        <tag>concept</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python slice iterator generator]]></title>
    <url>%2F2018%2F04%2F12%2Fpython-slice-iterator-generator%2F</url>
    <content type="text"><![CDATA[Slice切片取list/tuple/字符串中的部分元素即切片 list123456789&gt;&gt;&gt; L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']&gt;&gt;&gt; L[0:3] //从索引0的位置开始取，直到索引3，但是不包含索引3，也可以写成L[:3]['Michael', 'Sarah', 'Tracy']&gt;&gt;&gt; L[1:3]['Sarah', 'Tracy']&gt;&gt;&gt; L[-2:] //取倒数两个['Bob', 'Jack']&gt;&gt;&gt; L[-2:-1]['Bob'] tuple12&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3](0, 1, 2) string1234&gt;&gt;&gt; 'ABCDEFG'[:3]'ABC'&gt;&gt;&gt; 'ABCDEFG'[::2]'ACEG' 迭代python中for循环可以作用在所有可以迭代的对象上面，与有没有下标无关 12345678910&gt;&gt;&gt; d = &#123;'a': 1, 'b': 2, 'c': 3&#125;&gt;&gt;&gt; for key in d:... print(key)...acb&gt;&gt;&gt; for value in d.values() //默认情况下dict迭代是的key, 可以用value来迭代&gt;&gt;&gt; for k, v in d.items() 如何判断是否是可迭代的对象： 123&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance('abc', Iterable) # str是否可迭代True 如果在for循环里面同时引用两个变量： 123456&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:... print(x, y)...1 12 43 9 List Comprehensions 列表生成式12&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100] 也可以使用两层循环 12&gt;&gt;&gt; [m + n for m in 'ABC' for n in 'XYZ']['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] Generator 生成器不是一次性生成所有的list,而是一边循环一边计算，从而节省大量的空间 生成器就是把列表生成式从[]to() 12345678910111213141516171819202122&gt;&gt;&gt; L = [x * x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt;&gt;&gt;&gt; next(g) //不常用0&gt;&gt;&gt; g = (x * x for x in range(10)) &gt;&gt;&gt; for n in g: //一般是用这样的形式来拿取生成器里面的值... print(n)... 0149162536496481 也可以是用yield来生成 1234567def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b //如果是print b则不是生成器了 a, b = b, a + b n = n + 1 return 'done' 123456789&gt;&gt;&gt; for n in fib(6):... print(n)...112358 Iterator 迭代器for 除了可以作用于集合类型如： list tuple dict set str还可作用于generator 这些可以直接作用于for循环的对象称为可迭代对象 Iterable 123&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance([], Iterable)True]]></content>
      <tags>
        <tag>concept</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python对象真值]]></title>
    <url>%2F2018%2F04%2F12%2Fpython-true-value%2F</url>
    <content type="text"><![CDATA[对象 值 “spam” True “” False [] False {} False 1 true 0.0 False None False]]></content>
      <tags>
        <tag>concept</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL select top n]]></title>
    <url>%2F2018%2F04%2F11%2Fsql-select-top-n%2F</url>
    <content type="text"><![CDATA[If &gt; SQL 2005, 123456select ExcelMediaPlanId,ChannelCN,rankfrom( select ExcelMediaplanId, ChannelCN,Rank() over (Partition BY ExcelMediaplanId order by UnitRatecard desc) as rank from ExcelAdPosition) rs where rank &lt;=3 or 123456789WITH TOPTEN AS ( SELECT *, ROW_NUMBER() over ( PARTITION BY [group_by_field] order by [prioritise_field] ) AS RowNo FROM [table_name])SELECT * FROM TOPTEN WHERE RowNo &lt;= 10 or12345678910select *from Things twhere t.ThingID in ( select top 10 ThingID from Things tt where tt.Section = t.Section and tt.ThingDate = @Date order by tt.DateEntered desc ) and t.ThingDate = @Dateorder by Section, DateEntered desc In MS Access: 12345678910SELECT StudentID, TestID, TestScore FROM MyTable t WHERE TestID IN( SELECT TOP 3 TestID FROM MyTable WHERE StudentID = t.StudentID ORDER BY TestScore DESC, TestID) ORDER BY StudentID, TestScore DESC, TestID; StudentID TestID Score 1 1 95 1 2 90 1 3 90 1 4 90 2 1 99 2 2 95 2 3 90 2 4 90]]></content>
      <tags>
        <tag>practice</tag>
        <tag>MSSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS Install Java8]]></title>
    <url>%2F2018%2F04%2F02%2Fcentos-install-java8%2F</url>
    <content type="text"><![CDATA[Install1234567891011121314151617181920cd /opt/wget --no-cookies --no-check-certificate --header &quot;Cookie: gpw_e24=http%3A%2F%2Fwww.oracle.com%2F; oraclelicense=accept-securebackup-cookie&quot; &quot;http://download.oracle.com/otn-pub/java/jdk/8u161-b12/2f38c3b165be4555a1fa6e98c45e0808/jdk-8u161-linux-x64.tar.gz&quot;tar xzf jdk-8u161-linux-x64.tar.gzcd /opt/jdk1.8.0_161/alternatives --install /usr/bin/java java /opt/jdk1.8.0_161/bin/java 2alternatives --config javaThere are 3 programs which provide &apos;java&apos;. Selection Command-----------------------------------------------* 1 /opt/jdk1.7.0_71/bin/java + 2 /opt/jdk1.8.0_45/bin/java 3 /opt/jdk1.8.0_144/bin/java 4 /opt/jdk1.8.0_161/bin/javaEnter to keep the current selection[+], or type selection number: 4 Setup javac and jar commands path using alternatives1234alternatives --install /usr/bin/jar jar /opt/jdk1.8.0_161/bin/jar 2alternatives --install /usr/bin/javac javac /opt/jdk1.8.0_161/bin/javac 2alternatives --set jar /opt/jdk1.8.0_161/bin/jaralternatives --set javac /opt/jdk1.8.0_161/bin/javac Check installed java version1234java -versionjava version &quot;1.8.0_161&quot;Java(TM) SE Runtime Environment (build 1.8.0_161-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode) Setup Java Environment Variables123export JAVA_HOME=/opt/jdk1.8.0_161export JRE_HOME=/opt/jdk1.8.0_161/jreexport PATH=$PATH:/opt/jdk1.8.0_161/bin:/opt/jdk1.8.0_161/jre/bin]]></content>
      <tags>
        <tag>linux</tag>
        <tag>practice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-process-to-backend]]></title>
    <url>%2F2018%2F03%2F28%2Flinux-process-to-backend%2F</url>
    <content type="text"><![CDATA[Ref: Linux 技巧：让进程在后台可靠运行的几种方法 如果SSH登陆了远程Linux服务器，经常为Connection Timeout, 这样会自动kill掉正在运行的任务。如何让命令提交后不受本地关闭终端窗口/网络断开连接的干扰？ nohup/setsid/&amp;当用户注销logout或者网络断开时终端会收到HUP(hangup) 信号从而关闭所有子进程。因此为解决这个问题：要么让进程忽略HUP信号要么让进程运行在新的会话里从而成为不属于此终端的子进程 nohup， 让进程忽略HUP信号 nohup，标准输出和标准错误缺省会被重定向到nohup.out文件中。一般我们可在结尾加上&amp;来将命令同时放入后台运行 1234567[root@pvcent107 ~]# nohup ping www.ibm.com &amp;[1] 3059nohup: appending output to `nohup.out'[root@pvcent107 ~]# ps -ef |grep 3059root 3059 984 0 21:06 pts/3 00:00:00 ping www.ibm.comroot 3067 984 0 21:06 pts/3 00:00:00 grep 3059[root@pvcent107 ~]# setsid 如果进程不属于接受HUP信号的终端的子进程，就要用setsid. 12345[root@pvcent107 ~]# setsid ping www.ibm.com[root@pvcent107 ~]# ps -ef |grep www.ibm.comroot 31094 1 0 07:28 ? 00:00:00 ping www.ibm.comroot 31102 29217 0 07:29 pts/4 00:00:00 grep www.ibm.com[root@pvcent107 ~]# 注意的是我们的进程31094其父进程为1（即为init进程ID），并不是当前终端的进程ID &amp; 将&amp;也放入(),所提交的作业不会出现在作业列表中，就是无法通过jobs来查看。subshell示例: 12345[root@pvcent107 ~]# (ping www.ibm.com &amp;)[root@pvcent107 ~]# ps -ef |grep www.ibm.comroot 16270 1 0 14:13 pts/4 00:00:00 ping www.ibm.comroot 16278 15362 0 14:13 pts/4 00:00:00 grep www.ibm.com[root@pvcent107 ~]# 新提交的进程父ID为1（init进程ID）]]></content>
      <tags>
        <tag>concept</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSIS Cannot Import Package]]></title>
    <url>%2F2018%2F03%2F26%2FSSIS-CanNotImportPackage%2F</url>
    <content type="text"><![CDATA[Error: 123The SQL Server instance specified in SSIS service configuration is not present or is not available. This might occur when there is no default instance of SQL Server on the computer. For more information, see the topic "Configuring the Integration Services Service" in Server 2008 Books Online.Login failed for user 'XXXXX'. (MsDtsSrvr) Solution: Add the user XXXX as a login to the SQL serverwith sys_admin rights to msdb]]></content>
      <tags>
        <tag>SSIS</tag>
        <tag>issue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET MVC Request Life Cycle]]></title>
    <url>%2F2018%2F03%2F26%2Fasp-net-mvc-lifecycle%2F</url>
    <content type="text"><![CDATA[Ref A Detailed Walkthrough of ASP.NET MVC Request Life Cycle This is mainly for Page Life Cycle other than Application Life Cycle.A typical Application Life Cycle contains Application Start and Application End events while Http Life Cycle is something which is repeated for every request. MVC Request Life Cycle URL Routing ModuleThe incoming request from IIS pipeline is handed over to URL Routing module which analyses the request and looks up Routing table to figure out which controller the incoming request maps to. Routing table is a static container of routes defined in MVC application with corresponding controller action mapping. If the route is found in the routing table MVCRouteHandler executes and bring s the instance of MVCHttpHandler. MVC handler begins initializing and executing controller. The MVCHttpHandler also takes of converting route data into concrete controller that is capable of serving the request. MVC handler does all this with the help of MVC Controller factory and activator which are responsible for creating an instance of the controller. This is also the place where the Dependency Injection is performed if the application has been designed to invoke parameterized controller constructor and satisfy its dependencies. After the controller instance is created the next major step is to find and execute the corresponding action. A component called ActionInvoker finds and executes the action defined in routing table. Before the action method is called model bindings takes place which maps data from http request to action method parameters. After the model binding, action filters are invoked which includes OnActionExecuting filter. This is followed by action execution and Action Executed filter execution and finally preparing Action Result. Once the Action method has been finished executing the next step is Result execution. MVC separates the action declaration from Result execution. If the Result from action execution is view, then depending upon configuration, ASPX or Razor view engine will be called to find and render the html view as a response of http request. If the result was not view then it’s passed as-is to http response. Application Life CycleMVC application life cycle contains two application level events that are associated with start and end events of the application. Application start fires when the application is brought to life by a very first request to the application. Application end event is fired when application has been shut down. It’s important to understand application life cycle events to get a better understanding on how MVC life cycle starts. So far we have seen that URL Routing module is the starting point for MVC application that has a collection of predefined routes to map from. Now, the question here is how does URL routing handler gets this information from? The answer is simple, using Application start event. MVC applications provide these events in Global.asax file which contains all the application level events. All the prestart things are managed in the application start event. MVC Application_Start event is: An event that fires when first request is received. Can be used to run initial configuration and settings code The event takes care of registering all areas of MVC application, installing global filters, adding routes and bundles. Register RoutesSince Application_start event is the first event that gets called when application receives its very first request, all the pre application tasks like routing takes place here. As you see in the diagram below ResolveRequestCache needs to know the routes to choose from, and this needs to have static route collection already created. HttpHandlersHttpHandlers are classes that implement IHttpHandler and generate a response to HttpRequest. There could be httpHandler re-assignment in a life cycle of a request but only on http handler executes and provides response. Create HttpHandler:12345678public class SampleHttlHandler : IHttpHandler&#123; public book IsReusable &#123; get&#123; return false;&#125;&#125; public void ProcessRequest (HttpContext context) &#123; context.Response.Write("&lt;b&gt;This is the response from HttpHandler&lt;/b&gt;") &#125;&#125; HttpModulesHttpModules are classes that implement IHttpModule interface and are designed to respond to Life cycle events. In a given Http Life cycle, multiple http modules can respond to one single request and can also hook into multiple life cycle events. So they are not tied to any specific event, rather they can act at several places during the life cycle and expose multiple development possibilities. Features such as Logging and Authentication are best examples of wrapping things up in a HttpModule.]]></content>
      <tags>
        <tag>concept</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Func]]></title>
    <url>%2F2018%2F03%2F25%2FFunc%2F</url>
    <content type="text"><![CDATA[Func&lt;T1,T2,...,Tn,Tr&gt; represents a function that takes (T1, T2, ..., Tn) and returns Tr E.g., you have function:123double sqr(double s)&#123; return x*x;&#125; You could save it as some kind of a function-variable:12Func&lt;double, double&gt; f1 = sqr;Func&lt;double, double&gt; f2 = x=&gt; x*x; And then use exactly as you would use sqr:12f1(2);f2(f1(4)) .]]></content>
      <tags>
        <tag>c#</tag>
        <tag>concept</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ASP.NET Identity 原理]]></title>
    <url>%2F2018%2F03%2F25%2Fasp-net-identity%2F</url>
    <content type="text"><![CDATA[转自:MVC5 - ASP.NET Identity登录原理 - Claims-based认证和OWIN 实现登录实际上只有简单的三行代码123456789101112131415161718private IAuthenticationManager AuthenticationManager&#123; get&#123; return HttpContext.GetOwinContext().Authentication; &#125;&#125;private async Task SignInAsync()&#123; //1. 利用ASP.NET Identity获取用户对象 var user = await UserManager.FindAsync("UserName","Password"); //2. 利用ASP.NET Identity获取Identity对象 var identity = await UserManager.CreateIdentityAsync(user, DefaultAuthenticationTypes.ApplicationCookie); //3. 将上面拿到的identity对象登录 AuthenticationManager.SignIn(new AuthenticationProperties()&#123; IsPersistent = true &#125;, identity);&#125; CreateIdentityAsync返回的是一个ClaimsIdentity，这又是什么？ Claim-baised IdentityClaim-based 认证将Authentication 和 Authorization 与login 分开，将Authentication 和 Authorization 拆分为另外的web服务。 主要特点： 将认证与授权拆分成独立的服务 服务调用者不需要关注如何去认证 如果用户成功登陆，认证服务会返回令牌 服务调用者从令牌中读取所需信息，诸如用户名以及角色信息等 例如QQ登陆： 用户到网站访问一个需要登录的页面 网站检测到用户没有登录，返回一个跳转到QQ的登录页响应（302指向QQ登录页面的地址并加上一个返回的链接页面，通常为returnUrl=) 用户被跳转到指定的QQ登录页 用户在QQ登录页面上输入用户名和密码，QQ会在自己的数据库中查询，一旦登陆成功，会返回一个跳转到我们站点的响应（302指向我们的网站页面) 用户被跳转到我们网站的一个检测登录的页面，我们可以拿到用户的身份信息，建立ClaimsPrincipal和ClaimsIdentity对象，生成cookie等 我们再把用户带到指定的页面，也就是returnUrl，那是用户登录前最后一次访问的页面 ClaimsIdentity, ClaimsPrincipalClaimsIdentity和ClaimsPrincipal继承了接口IIdentity和IPrincipal Identity123456public interface IIdentity&#123; string AuthenticationType &#123; get; &#125; bool IsAUthenticated &#123; get; &#125; string Name &#123; get; &#125;&#125; IPrincipalIPrincipal代表了一个安全上下文，这个上下文对象包含了上面identity以及一些角色和组的信息，每一个线程都会关联一个Principal的对象，但是这个对象是属性进程或者AppDomain级别的. Ref: What is the idea behind IIdentity and IPrincipal in .NET IIdentity is just used for the user’s authenticated identity, regardless of what roles they may have. IPrincipal is used to combine a user’s identity with the authorized roles they have in a given security context. For example, you can use a third-party login provider, like Facebook or Google, to get the user’s identity, but you will not get a principal from those providers, as they don’t provide any roles. You can use your own application or a third-party role-based authorization provider to apply roles to , say, a FacebookIdentity or GoogleIdentity. A different application can expect a different principal, with its own roles , but still use the same identity as in another application 例子：12345678910111213public class HomeController : Controller&#123; [Authorize(Role = &quot;Users&quot;)] public ActionResult Index()&#123; return View(); &#125; [Authorize(Roles = &quot;Managers&quot;)] public ActionResult Manager() &#123; return View(); &#125;&#125; 登录, 在global.asax中添加了Application_AuthenticateRequest方法，就是每次MVC要对用户进行认证的时候都会进到这个方法里面，然后就神奇的把用户给登陆了。 12345678910protected void Application_AuthenticateRequest()&#123; var claims = new List&lt;Claim&gt;(); claims.Add(new Claim(ClaimTypes.Name, &quot;Zhang san&quot;)); claims.Add(new Claim(ClaimTypes.Role, &quot;Users&quot;)); var identity = new ClaimsIdentity(claims, &quot;MyClaimsLogin&quot;); ClaimsPrincipal principal = new ClaimsPrincipal(identity); HttpContext.Current.User = principal;&#125; 最后结论，我们讲了ClaimsIdentity什么的，讲了这么多和今天的主题有嘛关系？我们上面说ASPNET Identity登录有三句话，第一句话可以略过，第二句话就是我们上面讲的。 1var identity = await UserManager.CreateIdentityAsync(user, DefaultAuthenticationTypes.ApplicationCookie); UserManager实际上只是为我们创建了一个ClaimsIdentity的对象，还是通过我们自己从数据库里面取出来的对象来创建的，它也就干了那么点事，一层小小的封装而已。不要被后面的DefaultAuthenticationTypes.ApplicationCookie吓到了，这里还没有和cookie扯上半点关系，这就是一个字符串常量，和我们上面自己定义的MyClaimsLogin是没有区别的。 到这里，我想算是把登录代码的第二句话讲完了，讲清楚了，那么我们来看看第三句话，也就是最后一句，其实它才是登录的核心，第二句只是创建了一个ClaimsIdentity的对象。 12345private IAuthenticationManager AuthenticationManager&#123; get &#123; return HttpContext.GetOwinContext().Authentication; &#125;&#125;AuthenticationManager.SignIn(new AuthenticationProperties() &#123; IsPersistent = true &#125;, identity); IAuthenticationManager 在Microsoft.Owin.Security命名空间下，而这个接口是定义在Microsoft.Owin.dll中。 ##Owin OWIN目标是解耦服务器和应用，这里面的服务器主要是指web服务器，比如说IIS等，那么是如何做到的呢？ 解耦服务器与应用程序首先需要复习ASP.NET或者IIS集成模式管道模型，也就是说一个http请求在进入IIS之后（IIS7.0以上）一直到返回response这中间所经历的步骤。 Ref: A Detailed walkthrough of ASP.NET MVC Request lifecycle 我们可以开发自己的HttpModule(比方说是MyFormsModules)去注册这些事件，然后做相应的处理。比方说FormsAuthenticationModule就是注册了AuthenticateRequest事件，然后在这里去检查用户的cookie信息来判断用户是否登录了，这就是一个典型的应用程序与服务器之间的交互问题，而这些事件最后是被IIS触发的,我们是通过web.config把我们自定义的http module注册进了IIS，但是如果我们的网站不运行在IIS了，我们自己开发的这些HTTP module还能用么？ 另一个，我们Request和Response都是封装在HttpContext里面的，而这些信息从IIS里面来，最后也是交给IIS，如果web服务器不是IIS，那么这些信息从哪里获取呢？ 所以能够看出来，应用程序和服务器之间的耦合很大。我们不能够轻易换掉其中任何一个。 OWIN如何做到解耦它通过将服务器与应用程序之间的交互归纳为一个方法签名，称之为”应用程序代理(application delegate)” 1AppFunc = Func&lt;IDictionary&lt;string, object&gt;, Task&gt;; 在一个基于Owin的应用程序中的每一个组件都可以通过这样的一个代理来与服务器进行交互。 这们这里的交互其实是与服务器一起来处理http request，比如说ASP.NET管理模型中的那些事件，认证，授权，缓存等等，原先我们是通过自定义的http module，在里面拿到包含了request和response的HttpContext对象，进行处理。而现在我们能拿到的就是一个Dictionary。 可是别小看了这个Dictionary，我们所有的信息比如Application state, request state，server state等等这些信息全部存在这个数据结构中。这个dictionary会在Owin处理request的管道中进行传递，没错有了OWin之后，我们就不再是与ASP.NET 管道打交道了，而是OWin的管道，但是这个管道相对于ASP.NET 管道而言更灵活，更开放。 这个字典在OWin管道的各个组件中传输时，你可以任意的往里面添加或更改数据。 OWin默认为我们定义了以下的数据： 有了这些数据以后，我们就不需要和.NET的那些对象打交道了，比如说ASP.NET MVC中的HttpContextBase, 以及WEB API 中的HttpRequestMessage和HttpResponseMessage。我们也不需要再考虑system.web 这个dll里的东西，我们只需要通过OWin就可以拿到我们想要的信息，做我们想做的事了。而OWin，它本身和web服务器或者IIS没有任何关系。 Forms Authentication在Forms认证中我们检测完用户名和密码之后，只需要调用小面的代码就会为我们创建用户cookie.1FormsAuthentication.SetAuthCookie("Jesse", false); 然后FormsAuthenticationModule(这就是一个HTTP Module)会在ASP.NET管道的AuthenticateRequest阶段去检查是否有这个cookie，并把它转换成我们需要的Identity对象，这样的话我们就不需要每一次都让用户去输入用户名和密码了。所以登录过程如下：1。 用户在没有登录的情况下访问了我们需要登录的页面 FormsAuthenticationModule检查不到用户身份的cookie，没有生成identity对象，HttpContext.User.IsAuthenticated = false 在ASP.NET 管道 的Authroize 授权阶段，将用户跳转到登录页面 用户输入用户名和密码点击提交 我们检查用户名和密码，如果正确，就调用FormsAuthentication.SetAuthCookie方法生成登录cookie 用户可以正常访问我们需要登录的页面了 用户再次访问我们需要登录的页面 FormsAuthenticationModule检查到了用户身份的cookie，并生成identity对象，HttpContext.User.IsAuthenticated = true ASP.NET 管道的 Authroize授权阶段，HttpContext.User.IsAuthenticated=true，可以正常浏览 7,8,9循环 Forms Authentication有以下不足 用户名直接暴露在cookie中，需要额外的手段去将cookie加密 不支持claim-based认证 我们上面Forms的登录过程，对于OWin登录来说同样适用。我们在上面讲ASP.NET Identity登录第二句话的时候已经拿到了ClaimsIdentity，那么我们接下来要看的问题就是如何借助于IAuthenticationManager 去登录？ FormsAuthenticationModuel没有了，谁来负责检测cookie？您请接着往下看！ MVC5默认的StartUp配置类VS除了为我们引用OWin相关dll，以及移除FormsAuthenticationModule以外，还为我们在App_Start文件夹里添加了一个Startup.Auth.cs的文件。123456789101112public partial class Startup&#123; public void ConfigureAuth(IAppBuilder app) &#123; app.UseCookieAuthentication(new CookieAuthenticationOptions &#123; AuthenticationType = DefaultAuthenticationTypes.ApplicationCookie, LoginPath = new PathString("/Account/Login"), CookieSecure = CookieSecureOption.Never, &#125;); &#125;&#125; UseCookieAuthentication是一个IAppBuilder的扩展方法，定义在Microsoft.Owin.Security.Cookies.dll中123456789101112public static IAppBuilder UseCookieAuthentication(this IAppBuilder app, CookieAuthenticationOptions options)&#123; if(app == null) &#123; throw new ArgumentNullException("app"); &#125; //添加OWIN middleware组件到OWIN管道 app.Use(typeof(CookieAuthenticationMiddleware), app, options); //为前面添加的Middleware指定在IIS管道的哪个阶段执行 app.UseStageMarker(PipelineStage.Authenticate); return app;&#125; PipelineStage这个枚举定义与IIS管道里的那些顺序同，也是我们Http Module里面可以绑定的那些事件：123456789101112131415public enum PipelineStage&#123; Authenticate = 0, PostAuthenticate = 1, Authorize = 2, PostAuthorize = 3, ResolveCache = 4, PostResolveCache = 5, MapHandler = 6, PostMapHandler = 7, AcquireState = 8, PostAcquireState = 9, PreHandlerExecute = 10,&#125; 也就是说我们上面注册的CookieAuthenticationMiddleware会在AuthenticaRequest 阶段执行。而它就是真正生成cookie以及读取cookie的那只背后的手。顺便回顾一下如何在http module中为Authenticate绑定事件：123456789101112public class MyModule : IHttpModule&#123; public void Init(HttpApplication context) &#123; context.AuthenticateRequest += ctx_AuthRequest; &#125; void vtx_AuthRequest(object sender, EventArgs e) &#123; &#125;&#125; .]]></content>
      <tags>
        <tag>concept</tag>
        <tag>.NET</tag>
        <tag>Identity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c# constructor chaining]]></title>
    <url>%2F2018%2F03%2F25%2Fc-contructor-chaining%2F</url>
    <content type="text"><![CDATA[Consider this sample: 1234567891011121314151617181920212223class Student &#123; string _studengType = ""; string _id = ""; string _fName = ""; string _lName = ""; public Student(string id) : this(id, "", "")&#123; &#125; public Student(stirng id, string fName) : this(id, fName, "")&#123; &#125; public Student(string id, string fName, string lName)&#123; //Validation logic... _studentType = "&lt;student_type&gt;"; _id = id; _fName = fName; _lName = lName; &#125;&#125; 通过this，调用第三个构造参数，可以复用id赋值的这个语句：_id = id; 这样就不用每个构造函数都写这个逻辑，只需要用那个有最多参数构造函数即可]]></content>
      <tags>
        <tag>c#</tag>
        <tag>concept</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows身份验证]]></title>
    <url>%2F2018%2F03%2F22%2Fwindows-authentication%2F</url>
    <content type="text"><![CDATA[IPrincipal &amp; IIdentityIPrincipal定义用户对象的基本功能IIdentity定义标识对象的基本功能 Windows Authentication 过程IIS传递给Asp.Net一个Windows Token, 用这个Token创建一个WindowsIdentity对象,然后根据WindowsIdentity创建WindowsPrincipal对象，之后将这个对象赋值给HttpContext.User 1token = context.WorkerRequest.GetUserToken() Form Authentication 过程通过用户名和密码创建一个包含FormsAuthenticationTicket的登陆Cookie, ASP.NET 解析登陆的Cookie然后创建一个GenericPrincipal对象,这个对象包含FormsIdentity,之后把这个Principal对象赋值给HttpContext.User REF:细说ASP.NET Windows身份认证]]></content>
      <tags>
        <tag>concept</tag>
        <tag>practice</tag>
        <tag>Asp.Net</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS Resolution in Private Subnet with VPN to on-premises network]]></title>
    <url>%2F2018%2F03%2F20%2Fdns-forwarding%2F</url>
    <content type="text"><![CDATA[DNS Forwarding DefinitionDNS forwarding is the process by which particular sets of DNS queries are handled by a designated server, rather than being handled by the initial server contacted by the client. Usually, all DNS servers that handle address resolution within the network are configured to forward requests for addresses that are outside the network to a dedicated forwarder.reference doc IssueAWS EC2 instances in private subnet cannot resolve dns names.But EC2 instances can communicate with corporate network through VPN, the corporate network is able to correctly resolve dns. SolutionChange private subnet dns server to corporate dns server. How to see current network dns server: windows: ipconfig/all --&gt; dns server linux: cat /etc/resolv.conf can show your DNS servers How to check if corporate dns is success or not: windows: nslookup type server 10.82.XX.XX, where 10.82.XX.XX is your corporate dns server ip address type any dns name, like baidu.com, bing.com, and press Enter check if the ip address is returned: linux(centos): normally dig baidu.com check if ip address is returned: resolve use specific DNS server, like Google’s 1dig @8.8.8.8 baidu.com If you are just looking for IP address, you can add +short at the end 1dig @8.8.8.8 baidu.com +short]]></content>
      <tags>
        <tag>concept</tag>
        <tag>practice</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS CNAME ANAME]]></title>
    <url>%2F2018%2F03%2F19%2Fdns-cname%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>concept</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL identity column increment suddenly jumps]]></title>
    <url>%2F2018%2F03%2F15%2Fsql-id-increment-jump%2F</url>
    <content type="text"><![CDATA[SQL SERVER 2016 SQL Server 2012 now uses a cache size of 1,000 when allocating IDENTITY values in an int column and restarting the service can “lose” unused values (The cache size is 10,000 for bigint/numeric). Workarounds: You can use a SEQUENCE instead of an identity column and define a smaller cache size for example and use NEXT VALUE FOR in a column default e.g: 123456CREATE SEQUENCE Service_Ticket_Seq AS INTEGERSTART WITH 1INCREMENT BY 1MINVALUE 1MAXVALUE 100CYCLE; We can put a SEQUENCE in the DEFAULT clause of the DDL for table:1234CREATE TABLE Service_Tickets(ticket_nbr INTEGER DEFAULT NEXT VALUE FOR Service_Ticket_Seq, department_code CHAR(1) NOT NULL CHECK (department_code IN ('M', 'F'))); Now play with code:1234INSERT INTO Service_Tickets (department_code)VALUES ('M'); SELECT * FROM Service_Tickets; Now we get: ticket_nbr department_code 1 M Let’s re-do the Meats and Fish tables.123456789CREATE TABLE Meats(ticket_seq INTEGER DEFAULT NEXT VALUE FOR Service_Ticket_Seq PRIMARY KEY, meat_type VARCHAR(15) NOT NULL); CREATE TABLE Fish(ticket_seq INTEGER DEFAULT NEXT VALUE FOR Service_Ticket_Seq PRIMARY KEY, fish_type VARCHAR(15) NOT NULL); Now try:1234INSERT INTO Meats (meat_type) VALUES ('pig');INSERT INTO Fish (fish_type) VALUES ('squid');SELECT * FROM Meats;SELECT * FROM Fish; We get: ticket_nbr department_code 2 pig 3 squid Apply trace flag 272 which makes the IDENTITY allocation logged as in previous versions. Run SQL Server Configuration Manager Select SQL SERVER SERVICES, right-click SQL Server and select Properties, select Startup Parameters, type -T272 , Add, Apply, close and restart.]]></content>
      <tags>
        <tag>issue</tag>
        <tag>MSSQL</tag>
        <tag>configuration</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python List and Tuple, Dict and Set]]></title>
    <url>%2F2018%2F03%2F15%2Fpython-list-tuple%2F</url>
    <content type="text"><![CDATA[Python 3 list与tuple都是有序列表 LIST是一种有序的集合，可以随时添加或删除元素 123p = ['asp', 'php'] s = ['python', 'java', p, 'angular'] 如果想要拿到php，可以写成s[2][1],因此s可以看作为二维数组 常用方法：1234567&gt;&gt;&gt; len(classmates) ***获取元素个数***&gt;&gt;&gt; s[-2] ***获取倒数第二个元素***&gt;&gt;&gt; s.append('vue') ***追加元素到末尾***&gt;&gt;&gt; s.insert(2,'vue') ***把元素插入到索引号为2的位置，索引从0开始***&gt;&gt;&gt; s.pop() ***删除list末尾元素***&gt;&gt;&gt; s.pop(1) ***删除索引位置为i的元素***&gt;&gt;&gt; s[1] = 'vue' ***把某个索引位置的元素替换成另一个元素*** TUPLEtuple一旦初始化就不能修改，这里的不能修改指的是tuple中的每个元素的指向不变1classmates=('Jane', 'Anna', 'Ed') 现在这个classmates就无法更改，没有append(),insert()可以调用 但是有时候却能看见给tuple添加元素的操作：123456789101112131415def two(**s): print('s is ', s) t = () for i in s.values(): t += (i,) #这里tuple竟然可以添加元素 print(t) dic = dict( d1=1, d2=2, d3=3) if __name__ == '__main__': two(**dic) #输出为tuple(1, 2, 3) 当执行上面的操作的时，其实stucture is changed. 即你每新增一个新的，其实是一个新的Object.比如：123456&gt;&gt;&gt; tup = (1, 2, 3)&gt;&gt;&gt; id(tup)140153476307856&gt;&gt;&gt; tup += (4, 5)&gt;&gt;&gt; id(tup)140153479825840 而如果是list的话：123456&gt;&gt;&gt; lst = [1, 2, 3]&gt;&gt;&gt; id(lst)140153476247704&gt;&gt;&gt; lst += [4, 5]&gt;&gt;&gt; id(lst)140153476247704 Ref link 如果想要定义一个只有一个参数的tuple,不能写成123&gt;&gt;&gt; t = (1) &gt;&gt;&gt; t 因为这个时候t是数字1，（）这个时候当作数学括号来解析需要写成12345&gt;&gt;&gt; t = (1, ) &gt;&gt;&gt; t (1, ) DICT使用键值对存储, 且dict的key是不可变对象 123&gt;&gt;&gt; d = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125;&gt;&gt;&gt; d['Michael']95 为避免key不存在报错： 12345&gt;&gt;&gt; 'Thomas' in dFalse&gt;&gt;&gt; d.get('Thomas') //返回None&gt;&gt;&gt; d.get('Thomas', -1) 注意，dict的添加就是直接赋值就好了，例如d[&#39;newkey&#39;]=&#39;newvalue&#39; SETSet也是一组Key的集合，但不存储value，且Key也不能重复。 123&gt;&gt;&gt; s = set([1,2,3])&gt;&gt;&gt; s&#123;1,2,3&#125; 注意传入的参数[1,2,3]是一个list，而显示的{1,2,3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的 重复元素再set中会自动被过滤掉 123456789&gt;&gt;&gt; s = set([1,1,2,2,3,3,])&gt;&gt;&gt; s&#123;1,2,3&#125;&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1,2,3,4&#125;&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; s&#123;1,2,3&#125; SET可以看成无序且无重复元素的集合，因此两个set可以做数学意义上的交集、并集等操作 123456&gt;&gt;&gt; s1 = set([1,2,3])&gt;&gt;&gt; s2 = set([2,3,4])&gt;&gt;&gt; s1 &amp; s2&#123;2,3&#125;&gt;&gt;&gt; s1 | s2&#123;1,2,3,4&#125;]]></content>
      <tags>
        <tag>concept</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 可变参数，关键字参数]]></title>
    <url>%2F2018%2F03%2F15%2Fpython-parameter%2F</url>
    <content type="text"><![CDATA[可变参数*args 变的是个数 在函数调用的时候自动组装为一个tuple 传入的时候直接传值即可 关键字参数**kwargs 在函数调用的时候自动组装为一个dictionary 传入的时候必须是以含参数名的形式传递 1234567def func(a, b, c=0, *args, **kwargs): print ('a=', a, 'b=', b, 'c=', c, 'args=', args, 'kwargs=', kwargs) if __name__ == '__main__': func(1,2,3,spence,shao,name='spence',gender='male') &gt;&gt;&gt;a=1,b=2,c=3,args=(spence,shao),kwargs=&#123;'name':'spence','gender':'male'&#125;]]></content>
      <tags>
        <tag>concept</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML GET请求自动添加参数列表]]></title>
    <url>%2F2018%2F03%2F15%2Fhtml-auto-add-parameter%2F</url>
    <content type="text"><![CDATA[12345678910&lt;form action="/action" method="get"&gt;&lt;textarea name="message"&gt;&lt;/textarea&gt; &lt;input name="author"&gt; &lt;!-- /?message=输入的内容 --&gt; &lt;button type="submit"&gt;GET 提交&lt;/button&gt;&lt;/form&gt;&lt;form action="/" method="post"&gt; &lt;textarea name="message"&gt;&lt;/textarea&gt; &lt;button type="submit"&gt;POST 提交&lt;/button&gt;&lt;/form&gt; 对于GET请求，GET提交之后，浏览器会在host:port[action]?author=xx&amp;message=xx, 例如localhost:3000/action?author=spencer&amp;message=test]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Excel generate random value from a list]]></title>
    <url>%2F2018%2F03%2F15%2Fexcel-random-value%2F</url>
    <content type="text"><![CDATA[=INDEX($E:$E, RANDBETWEEN(1,COUNTA($E:$E)),1)]]></content>
      <tags>
        <tag>Excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux find directory]]></title>
    <url>%2F2018%2F03%2F15%2Flinux-find-directory%2F</url>
    <content type="text"><![CDATA[find / -type d -name &#39;dir-name-here&#39;]]></content>
      <tags>
        <tag>linux</tag>
        <tag>command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx location匹配]]></title>
    <url>%2F2018%2F03%2F14%2Fnginx-location%2F</url>
    <content type="text"><![CDATA[转载补充自http://seanlook.com/2015/05/17/nginx-location-rewrite/ 123456789101112131415161718192021location = / &#123; # 精确匹配 / ，主机名后面不能带任何字符串 [ configuration A ]&#125;location / &#123; # 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求 # 但是正则和最长字符串会优先匹配 [ configuration B ]&#125;location ^~ /images/ &#123; # 匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。 [ configuration D ]&#125;location ~* \.(gif|jpg|jpeg)$ &#123; # 匹配所有以 gif,jpg或jpeg 结尾的请求 # 然而，所有请求 /images/ 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则 [ configuration E ]&#125; 以=开头表示精确匹配如A中只匹配根目录结尾的请求，后面不能带任何字符串 ^~开头表示uri以某个常规字符串开头，不是正则匹配 ~开头表示区分大小写的正则匹配 ~*开头表示不区分大小写的正则匹配 /通用匹配， 如果没有其他匹配，任何请求都会匹配到 前缀匹配时，nginx不对url做编码，因此请求/static/20%/aa, 可以被规则 ^~ /static/ /aa 匹配到 多个 location 配置的情况下匹配顺序为： 首先精确匹配 = 其次完整路径 其次前缀匹配 ^~ 其次按文件中顺序的正则匹配 匹配不带任何修饰的前缀匹配 最后 / 通用匹配 当有匹配成功的时候，停止匹配，按当前匹配规则处理请求]]></content>
      <tags>
        <tag>concept</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
